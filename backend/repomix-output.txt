This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-02T17:12:03.290Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  config/
    database.js
    multer.js
    redis.js
  controllers/
    AuthController.js
    DashboardController.js
    EquipmentController.js
    MaintenanceController.js
    NotificationController.js
    ReportController.js
    ServiceOrderController.js
    UserController.js
  database/
    migrations/
      01-create-users.js
      02-create-equipment.js
      03-create-maintenance.js
      04-create-notifications.js
      05-create-reports.js
    index.js
  jobs/
    processors/
      index.js
    jobProcessor.js
  middlewares/
    auth.js
    errorHandler.js
    security.js
    validate.js
  models/
    Equipment.js
    File.js
    index.js
    MaintenanceHistory.js
    Notification.js
    ServiceOrder.js
    User.js
  routes/
    index.js
  services/
    AuditService.js
    CacheService.js
    EmailService.js
    FileService.js
    MediaService.js
    NotificationService.js
    PDFService.js
    PushNotificationService.js
    QRCodeService.js
    ReportService.js
    S3Service.js
    WebSocketService.js
  utils/
    logger.js
  validations/
    schemas.js
  views/
    emails/
      maintenance-complete.ejs
      maintenance-notification.ejs
  websocket/
    webSocketMananger.js
  app.js
  index.js
.sequelizerc
package.json
tree.js

================================================================
Files
================================================================

================
File: src/config/database.js
================
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    define: {
      timestamps: true,
      underscored: true,
    },
    logging: false,
  },
  test: {
    dialect: 'sqlite',
    storage: './__tests__/database.sqlite',
    logging: false,
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    define: {
      timestamps: true,
      underscored: true,
    },
    logging: false,
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000,
    },
  },
};

================
File: src/config/multer.js
================
const multer = require('multer');
const path = require('path');
const crypto = require('crypto');

module.exports = {
  storage: multer.diskStorage({
    destination: path.resolve(__dirname, '..', '..', 'tmp', 'uploads'),
    filename: (req, file, cb) => {
      crypto.randomBytes(16, (err, hash) => {
        if (err) cb(err);
        const fileName = `${hash.toString('hex')}-${file.originalname}`;
        cb(null, fileName);
      });
    },
  }),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = [
      'image/jpeg',
      'image/pjpeg',
      'image/png',
      'application/pdf',
    ];

    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Tipo de arquivo inválido.'));
    }
  },
};

================
File: src/config/redis.js
================
const Redis = require('ioredis');

const redisConfig = {
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: 3,
  retryStrategy(times) {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
  reconnectOnError(err) {
    const targetError = 'READONLY';
    if (err.message.includes(targetError)) {
      return true;
    }
    return false;
  }
};

let redisClient = null;

const getRedisClient = () => {
  if (!redisClient) {
    redisClient = new Redis(redisConfig);

    redisClient.on('error', (error) => {
      console.error('Erro na conexão com Redis:', error);
    });

    redisClient.on('connect', () => {
      console.log('Conectado ao Redis');
    });
  }

  return redisClient;
};

module.exports = {
  getRedisClient,
  redisConfig
};

================
File: src/controllers/AuthController.js
================
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { User } = require('../models/User');
const { Op } = require('sequelize');
const EmailService = require('../services/emailService');
const logger = require('../utils/logger');

class AuthController {
  async login(req, res) {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({
        where: { 
          email,
          active: true
        }
      });

      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      if (!(await bcrypt.compare(password, user.password_hash))) {
        return res.status(401).json({ error: 'Senha incorreta' });
      }

      const token = jwt.sign(
        { id: user.id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      );

      // Remove senha do retorno
      const { password_hash, ...userData } = user.toJSON();

      return res.json({
        user: userData,
        token
      });

    } catch (error) {
      logger.error('Erro no login:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async forgotPassword(req, res) {
    try {
      const { email } = req.body;

      const user = await User.findOne({ where: { email } });

      if (!user) {
        return res.status(404).json({ error: 'Usuário não encontrado' });
      }

      // Gera token de reset
      const resetToken = crypto.randomBytes(20).toString('hex');
      const resetTokenExpires = new Date();
      resetTokenExpires.setHours(resetTokenExpires.getHours() + 1); // Token válido por 1 hora

      await user.update({
        password_reset_token: resetToken,
        password_reset_expires: resetTokenExpires
      });

      // Envia email
      await EmailService.sendPasswordReset({
        name: user.name,
        email: user.email,
        token: resetToken,
        resetUrl: `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`
      });

      return res.json({ message: 'Email de recuperação enviado com sucesso' });

    } catch (error) {
      logger.error('Erro no forgot password:', error);
      return res.status(500).json({ error: 'Erro ao recuperar senha' });
    }
  }

  async resetPassword(req, res) {
    try {
      const { email, token, password } = req.body;

      const user = await User.findOne({
        where: {
          email,
          password_reset_token: token,
          password_reset_expires: {
            [Op.gt]: new Date()
          }
        }
      });

      if (!user) {
        return res.status(400).json({ error: 'Token inválido ou expirado' });
      }

      // Atualiza senha
      const password_hash = await bcrypt.hash(password, 8);

      await user.update({
        password_hash,
        password_reset_token: null,
        password_reset_expires: null
      });

      // Envia email de confirmação
      await EmailService.sendPasswordResetConfirmation({
        name: user.name,
        email: user.email
      });

      return res.json({ message: 'Senha alterada com sucesso' });

    } catch (error) {
      logger.error('Erro no reset password:', error);
      return res.status(500).json({ error: 'Erro ao resetar senha' });
    }
  }

  async refreshToken(req, res) {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        return res.status(401).json({ error: 'Refresh token não fornecido' });
      }

      // Verifica refresh token
      const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);

      const user = await User.findByPk(decoded.id);
      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      // Gera novo token
      const token = jwt.sign(
        { id: user.id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      );

      // Gera novo refresh token
      const newRefreshToken = jwt.sign(
        { id: user.id },
        process.env.REFRESH_TOKEN_SECRET,
        { expiresIn: '30d' }
      );

      return res.json({
        token,
        refreshToken: newRefreshToken
      });

    } catch (error) {
      logger.error('Erro no refresh token:', error);
      return res.status(401).json({ error: 'Refresh token inválido' });
    }
  }

  async validateToken(req, res) {
    try {
      const { token } = req.body;

      if (!token) {
        return res.status(401).json({ error: 'Token não fornecido' });
      }

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findByPk(decoded.id);

      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      return res.json({ valid: true });

    } catch (error) {
      return res.json({ valid: false });
    }
  }

  async changePassword(req, res) {
    try {
      const { currentPassword, newPassword } = req.body;
      const user = await User.findByPk(req.userId);

      if (!(await bcrypt.compare(currentPassword, user.password_hash))) {
        return res.status(401).json({ error: 'Senha atual incorreta' });
      }

      const password_hash = await bcrypt.hash(newPassword, 8);
      await user.update({ password_hash });

      // Envia email de notificação
      await EmailService.sendPasswordChangeNotification({
        name: user.name,
        email: user.email
      });

      return res.json({ message: 'Senha alterada com sucesso' });

    } catch (error) {
      logger.error('Erro na mudança de senha:', error);
      return res.status(500).json({ error: 'Erro ao alterar senha' });
    }
  }

  async logout(req, res) {
    try {
      // Aqui você pode implementar lógica adicional de logout
      // como invalidar refresh tokens, etc.
      
      return res.json({ message: 'Logout realizado com sucesso' });
    } catch (error) {
      logger.error('Erro no logout:', error);
      return res.status(500).json({ error: 'Erro ao realizar logout' });
    }
  }
}

module.exports = new AuthController();

================
File: src/controllers/DashboardController.js
================
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const { Op, Sequelize } = require('sequelize');
const CacheService = require('../services/CacheService');
const logger = require('../utils/logger');

class DashboardController {
  async getStats(req, res) {
    try {
      const { period = 'month' } = req.query;
      
      // Tenta buscar do cache
      const cacheKey = `dashboard:${period}:${req.userId}`;
      const cachedData = await CacheService.get(cacheKey);
      
      if (cachedData) {
        return res.json(cachedData);
      }

      // Calcula datas
      const endDate = new Date();
      const startDate = this.getStartDate(period);

      // Busca dados
      const [
        equipmentStats,
        maintenanceStats,
        performanceMetrics,
        upcomingMaintenances
      ] = await Promise.all([
        this.getEquipmentStats(),
        this.getMaintenanceStats(startDate, endDate),
        this.getPerformanceMetrics(startDate, endDate),
        this.getUpcomingMaintenances()
      ]);

      const dashboardData = {
        equipmentStats,
        maintenanceStats,
        performanceMetrics,
        upcomingMaintenances,
        lastUpdate: new Date()
      };

      // Salva no cache por 5 minutos
      await CacheService.set(cacheKey, dashboardData, 300);

      return res.json(dashboardData);

    } catch (error) {
      logger.error('Erro ao buscar estatísticas do dashboard:', error);
      return res.status(500).json({ error: 'Erro ao buscar estatísticas' });
    }
  }

  async getEquipmentStats() {
    const totalEquipments = await Equipment.count();
    const activeEquipments = await Equipment.count({ where: { status: 'active' } });
    const maintenanceEquipments = await Equipment.count({ where: { status: 'maintenance' } });
    
    return {
      total: totalEquipments,
      active: activeEquipments,
      inMaintenance: maintenanceEquipments,
      inactive: totalEquipments - activeEquipments - maintenanceEquipments
    };
  }

  async getMaintenanceStats(startDate, endDate) {
    const maintenances = await Maintenance.findAll({
      where: {
        created_at: {
          [Op.between]: [startDate, endDate]
        }
      },
      attributes: [
        'type',
        'status',
        [Sequelize.fn('COUNT', '*'), 'count'],
        [Sequelize.fn('SUM', Sequelize.col('cost')), 'totalCost']
      ],
      group: ['type', 'status']
    });

    const byType = {};
    const byStatus = {};

    maintenances.forEach(m => {
      byType[m.type] = (byType[m.type] || 0) + m.get('count');
      byStatus[m.status] = (byStatus[m.status] || 0) + m.get('count');
    });

    return {
      byType,
      byStatus,
      totalCost: maintenances.reduce((sum, m) => sum + (m.get('totalCost') || 0), 0)
    };
  }

  async getPerformanceMetrics(startDate, endDate) {
    const completedMaintenances = await Maintenance.findAll({
      where: {
        status: 'completed',
        completion_date: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ]
    });

    // Calcula métricas
    const totalTime = completedMaintenances.reduce((sum, m) => {
      const duration = new Date(m.completion_date) - new Date(m.created_at);
      return sum + duration;
    }, 0);

    const avgTime = completedMaintenances.length > 0 
      ? totalTime / completedMaintenances.length
      : 0;

    return {
      avgResolutionTime: Math.round(avgTime / (1000 * 60 * 60)), // em horas
      completionRate: await this.calculateCompletionRate(startDate, endDate),
      technicianPerformance: await this.calculateTechnicianPerformance(startDate, endDate)
    };
  }

  async getUpcomingMaintenances() {
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);

    return await Maintenance.findAll({
      where: {
        status: 'pending',
        scheduled_date: {
          [Op.lte]: nextWeek
        }
      },
      include: [
        {
          model: Equipment,
          attributes: ['id', 'name', 'code']
        },
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ],
      order: [['scheduled_date', 'ASC']],
      limit: 5
    });
  }

  async calculateCompletionRate(startDate, endDate) {
    const [completed, total] = await Promise.all([
      Maintenance.count({
        where: {
          status: 'completed',
          completion_date: {
            [Op.between]: [startDate, endDate]
          }
        }
      }),
      Maintenance.count({
        where: {
          created_at: {
            [Op.between]: [startDate, endDate]
          }
        }
      })
    ]);

    return total > 0 ? Math.round((completed / total) * 100) : 0;
  }

  async calculateTechnicianPerformance(startDate, endDate) {
    const performances = await Maintenance.findAll({
      attributes: [
        [Sequelize.fn('COUNT', '*'), 'total'],
        [Sequelize.fn('AVG', 
          Sequelize.literal('EXTRACT(EPOCH FROM (completion_date - created_at))/3600')
        ), 'avgTime']
      ],
      where: {
        status: 'completed',
        completion_date: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ],
      group: ['technician.id', 'technician.name']
    });

    return performances.map(p => ({
      technician: p.technician,
      completedMaintenances: p.get('total'),
      averageResolutionTime: Math.round(p.get('avgTime'))
    }));
  }

  getStartDate(period) {
    const date = new Date();
    switch (period) {
      case 'week':
        date.setDate(date.getDate() - 7);
        break;
      case 'month':
        date.setMonth(date.getMonth() - 1);
        break;
      case 'year':
        date.setFullYear(date.getFullYear() - 1);
        break;
      default:
        date.setMonth(date.getMonth() - 1); // Padrão: último mês
    }
    return date;
  }
}

module.exports = new DashboardController();

================
File: src/controllers/EquipmentController.js
================
const {Equipment} = require('../models/Equipment');
const {MaintenanceHistory} = require('../models/MaintenanceHistory');
const {User} = require('../models/User');
const QRCode = require('qrcode');

class EquipmentController {
  async store(req, res) {
    const equipment = await Equipment.create(req.body);

    // Gera QR Code
    const qrcodeData = `${process.env.APP_URL}/equipment/${equipment.id}`;
    const qrcodeUrl = await QRCode.toDataURL(qrcodeData);
    
    await equipment.update({ qrcode_url: qrcodeUrl });

    return res.status(201).json(equipment);
  }

  async index(req, res) {
    const { department, status, search } = req.query;
    const where = {};

    if (department) where.department = department;
    if (status) where.status = status;
    if (search) {
      where[Op.or] = [
        { name: { [Op.iLike]: `%${search}%` } },
        { code: { [Op.iLike]: `%${search}%` } },
        { serial_number: { [Op.iLike]: `%${search}%` } },
      ];
    }

    const equipment = await Equipment.findAll({
      where,
      include: [
        {
          model: MaintenanceHistory,
          as: 'maintenance_history',
          limit: 1,
          order: [['maintenance_date', 'DESC']],
        },
      ],
      order: [['created_at', 'DESC']],
    });

    return res.json(equipment);
  }

  async show(req, res) {
    const equipment = await Equipment.findByPk(req.params.id, {
      include: [
        {
          model: MaintenanceHistory,
          as: 'maintenance_history',
          include: [
            {
              model: User,
              as: 'technician',
              attributes: ['id', 'name'],
            },
          ],
        },
        {
          model: ServiceOrder,
          as: 'service_orders',
          include: [
            {
              model: User,
              as: 'creator',
              attributes: ['id', 'name'],
            },
          ],
        },
      ],
    });

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    return res.json(equipment);
  }

  async update(req, res) {
    const equipment = await Equipment.findByPk(req.params.id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    await equipment.update(req.body);

    return res.json(equipment);
  }

  async destroy(req, res) {
    const equipment = await Equipment.findByPk(req.params.id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    await equipment.destroy();

    return res.status(204).send();
  }
}

module.exports = new EquipmentController();

================
File: src/controllers/MaintenanceController.js
================
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const NotificationService = require('../services/NotificationService');
const S3Service = require('../services/S3Service');
const { maintenanceHistorySchema } = require('../validations/schemas');
const logger = require('../utils/logger');

class MaintenanceController {
  async store(req, res) {
    try {
      const {
        equipment_id,
        description,
        type,
        notes,
        cost
      } = req.body;

      // Valida equipamento
      const equipment = await Equipment.findByPk(equipment_id);
      if (!equipment) {
        return res.status(404).json({ error: 'Equipamento não encontrado' });
      }

      // Processa fotos
      let photoUrls = [];
      if (req.files?.photos) {
        const uploadPromises = req.files.photos.map(photo => 
          S3Service.uploadFile(photo, 'maintenance-photos')
        );
        photoUrls = await Promise.all(uploadPromises);
      }

      // Processa documentos
      let documentUrls = [];
      if (req.files?.documents) {
        const uploadPromises = req.files.documents.map(doc => 
          S3Service.uploadFile(doc, 'maintenance-documents')
        );
        documentUrls = await Promise.all(uploadPromises);
      }

      // Cria registro de manutenção
      const maintenance = await Maintenance.create({
        equipment_id,
        description,
        type,
        status: 'pending',
        notes,
        cost: cost || 0,
        photos: photoUrls,
        documents: documentUrls,
        created_by: req.userId
      });

      // Atualiza status do equipamento
      await equipment.update({ 
        status: 'maintenance',
        last_maintenance: new Date()
      });

      // Notifica responsáveis
      await NotificationService.notifyMaintenanceCreated(maintenance);

      return res.status(201).json(maintenance);

    } catch (error) {
      logger.error('Erro ao criar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao registrar manutenção' });
    }
  }

  async index(req, res) {
    try {
      const { 
        status,
        equipment_id,
        start_date,
        end_date,
        type
      } = req.query;

      const where = {};

      if (status) where.status = status;
      if (equipment_id) where.equipment_id = equipment_id;
      if (type) where.type = type;
      
      if (start_date && end_date) {
        where.created_at = {
          [Op.between]: [start_date, end_date]
        };
      }

      // Se não for admin, filtra por departamento
      if (req.userRole !== 'admin') {
        const user = await User.findByPk(req.userId);
        where['$Equipment.department$'] = user.department;
      }

      const maintenances = await Maintenance.findAll({
        where,
        include: [
          {
            model: Equipment,
            attributes: ['id', 'name', 'code', 'department']
          },
          {
            model: User,
            as: 'technician',
            attributes: ['id', 'name']
          }
        ],
        order: [['created_at', 'DESC']]
      });

      return res.json(maintenances);

    } catch (error) {
      logger.error('Erro ao listar manutenções:', error);
      return res.status(500).json({ error: 'Erro ao listar manutenções' });
    }
  }

  async update(req, res) {
    try {
      const { id } = req.params;
      const {
        status,
        notes,
        cost,
        completion_notes
      } = req.body;

      const maintenance = await Maintenance.findByPk(id, {
        include: [{ model: Equipment }]
      });

      if (!maintenance) {
        return res.status(404).json({ error: 'Manutenção não encontrada' });
      }

      // Se estiver completando a manutenção
      if (status === 'completed' && maintenance.status !== 'completed') {
        // Atualiza status do equipamento
        await maintenance.Equipment.update({ status: 'active' });
        
        // Notifica sobre conclusão
        await NotificationService.notifyMaintenanceCompleted(maintenance);
      }

      await maintenance.update({
        status,
        notes,
        cost,
        completion_notes,
        completed_at: status === 'completed' ? new Date() : null,
        completed_by: status === 'completed' ? req.userId : null
      });

      return res.json(maintenance);

    } catch (error) {
      logger.error('Erro ao atualizar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao atualizar manutenção' });
    }
  }

  async show(req, res) {
    try {
      const { id } = req.params;

      const maintenance = await Maintenance.findByPk(id, {
        include: [
          {
            model: Equipment,
            attributes: ['id', 'name', 'code', 'department']
          },
          {
            model: User,
            as: 'technician',
            attributes: ['id', 'name']
          },
          {
            model: User,
            as: 'creator',
            attributes: ['id', 'name']
          }
        ]
      });

      if (!maintenance) {
        return res.status(404).json({ error: 'Manutenção não encontrada' });
      }

      return res.json(maintenance);

    } catch (error) {
      logger.error('Erro ao buscar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao buscar manutenção' });
    }
  }
}

module.exports = new MaintenanceController();

================
File: src/controllers/NotificationController.js
================
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const {Notification} = require('../models/Notification');
const NotificationService = require('../services/NotificationService');
const WebSocketManager = require('../websocket/WebSocketManager');
const JobProcessor = require('../jobs/JobProcessor');
const logger = require('../utils/logger');

class NotificationController {
  async store(req, res) {
    try {
      const {
        type,
        title,
        message,
        recipient_id,
        reference_type,
        reference_id,
        priority = 'normal'
      } = req.body;

      // Cria notificação
      const notification = await Notification.create({
        type,
        title,
        message,
        recipient_id,
        reference_type,
        reference_id,
        priority,
        sender_id: req.userId
      });

      // Envia notificação em tempo real
      await NotificationService.send({
        notification,
        recipient_id
      });

      return res.status(201).json(notification);
    } catch (error) {
      logger.error('Erro ao criar notificação:', error);
      return res.status(500).json({ error: 'Erro ao criar notificação' });
    }
  }

  async list(req, res) {
    try {
      const { 
        page = 1, 
        limit = 20, 
        read, 
        type,
        priority 
      } = req.query;

      const where = { recipient_id: req.userId };
      if (read !== undefined) where.read = read === 'true';
      if (type) where.type = type;
      if (priority) where.priority = priority;

      const notifications = await Notification.findAndCountAll({
        where,
        include: [
          {
            model: User,
            as: 'sender',
            attributes: ['id', 'name']
          }
        ],
        order: [['created_at', 'DESC']],
        limit: parseInt(limit),
        offset: (page - 1) * limit
      });

      return res.json({
        items: notifications.rows,
        total: notifications.count,
        unread: await this.getUnreadCount(req.userId)
      });
    } catch (error) {
        logger.error('Erro ao listar notificações:', error);
        return res.status(500).json({ error: 'Erro ao listar notificações' });
      }
    }
  
    async markAsRead(req, res) {
      try {
        const { id } = req.params;
        const notification = await Notification.findOne({
          where: { 
            id,
            recipient_id: req.userId
          }
        });
  
        if (!notification) {
          return res.status(404).json({ error: 'Notificação não encontrada' });
        }
  
        await notification.update({ read: true });
  
        // Atualiza contadores em tempo real
        WebSocketManager.sendToClient(req.userId, {
          type: 'NOTIFICATION_READ',
          data: {
            notificationId: id,
            unreadCount: await this.getUnreadCount(req.userId)
          }
        });
  
        return res.json(notification);
      } catch (error) {
        logger.error('Erro ao marcar notificação como lida:', error);
        return res.status(500).json({ error: 'Erro ao atualizar notificação' });
      }
    }
  
    async markAllAsRead(req, res) {
      try {
        await Notification.update(
          { read: true },
          { 
            where: { 
              recipient_id: req.userId,
              read: false
            }
          }
        );
  
        // Atualiza contadores em tempo real
        WebSocketManager.sendToClient(req.userId, {
          type: 'ALL_NOTIFICATIONS_READ',
          data: { unreadCount: 0 }
        });
  
        return res.status(204).send();
      } catch (error) {
        logger.error('Erro ao marcar todas notificações como lidas:', error);
        return res.status(500).json({ error: 'Erro ao atualizar notificações' });
      }
    }
  
    async delete(req, res) {
      try {
        const { id } = req.params;
        const notification = await Notification.findOne({
          where: { 
            id,
            recipient_id: req.userId
          }
        });
  
        if (!notification) {
          return res.status(404).json({ error: 'Notificação não encontrada' });
        }
  
        await notification.destroy();
        return res.status(204).send();
      } catch (error) {
        logger.error('Erro ao deletar notificação:', error);
        return res.status(500).json({ error: 'Erro ao deletar notificação' });
      }
    }
  
    async getUnreadCount(userId) {
      return await Notification.count({
        where: {
          recipient_id: userId,
          read: false
        }
      });
    }
  
    async getUserPreferences(req, res) {
      try {
        const preferences = await NotificationPreference.findOne({
          where: { user_id: req.userId }
        });
  
        return res.json(preferences || {
          email: true,
          push: true,
          in_app: true,
          maintenance_reminders: true,
          equipment_alerts: true
        });
      } catch (error) {
        logger.error('Erro ao buscar preferências:', error);
        return res.status(500).json({ error: 'Erro ao buscar preferências' });
      }
    }
  
    async updateUserPreferences(req, res) {
      try {
        const {
          email,
          push,
          in_app,
          maintenance_reminders,
          equipment_alerts
        } = req.body;
  
        const [preferences] = await NotificationPreference.upsert({
          user_id: req.userId,
          email,
          push,
          in_app,
          maintenance_reminders,
          equipment_alerts
        });
  
        return res.json(preferences);
      } catch (error) {
        logger.error('Erro ao atualizar preferências:', error);
        return res.status(500).json({ error: 'Erro ao atualizar preferências' });
      }
    }
  
    // Métodos para envio de notificações específicas
    async notifyMaintenanceDue(equipment) {
      try {
        const users = await User.findAll({
          where: {
            [Op.or]: [
              { role: 'admin' },
              { role: 'technician', department: equipment.department }
            ]
          }
        });
  
        const notifications = users.map(user => ({
          type: 'MAINTENANCE_DUE',
          title: 'Manutenção Preventiva Necessária',
          message: `O equipamento ${equipment.name} (${equipment.code}) precisa de manutenção preventiva.`,
          recipient_id: user.id,
          reference_type: 'equipment',
          reference_id: equipment.id,
          priority: 'high'
        }));
  
        await Notification.bulkCreate(notifications);
  
        // Notifica em tempo real
        users.forEach(user => {
          WebSocketManager.sendToClient(user.id, {
            type: 'MAINTENANCE_DUE',
            data: { equipment }
          });
        });
  
        // Agenda envio de emails
        await JobProcessor.addNotificationJob('send_maintenance_due_emails', {
          equipment,
          users
        });
  
      } catch (error) {
        logger.error('Erro ao notificar manutenção necessária:', error);
      }
    }
  }
  
  module.exports = new NotificationController();

================
File: src/controllers/ReportController.js
================
const PDFService = require('../services/PDFService');
const ExcelService = require('../services/ExcelService');
const JobProcessor = require('../jobs/JobProcessor');
const CacheService = require('../services/CacheService');
const logger = require('../utils/logger');

class ReportController {
  async generate(req, res) {
    try {
      const {
        type,
        format = 'pdf',
        start_date,
        end_date,
        department,
        equipment_id
      } = req.query;

      // Valida parâmetros
      if (!type) {
        return res.status(400).json({ error: 'Tipo de relatório é obrigatório' });
      }

      // Gera chave de cache
      const cacheKey = `report:${type}:${format}:${start_date}:${end_date}:${department}:${equipment_id}`;
      
      // Verifica cache
      const cachedReport = await CacheService.get(cacheKey);
      if (cachedReport) {
        return res.json(cachedReport);
      }

      // Inicia job de geração
      const job = await JobProcessor.addReportJob({
        type,
        format,
        filters: {
          start_date,
          end_date,
          department,
          equipment_id
        },
        userId: req.userId
      });

      return res.json({
        message: 'Relatório está sendo gerado',
        jobId: job.id,
        estimatedTime: '1-2 minutos'
      });

    } catch (error) {
      logger.error('Erro ao gerar relatório:', error);
      return res.status(500).json({ error: 'Erro ao gerar relatório' });
    }
  }

  async getStatus(req, res) {
    try {
      const { jobId } = req.params;
      const status = await JobProcessor.getJobStatus(jobId);

      if (!status) {
        return res.status(404).json({ error: 'Job não encontrado' });
      }

      return res.json(status);
    } catch (error) {
      logger.error('Erro ao buscar status do relatório:', error);
      return res.status(500).json({ error: 'Erro ao buscar status' });
    }
  }

  async download(req, res) {
    try {
      const { reportId } = req.params;
      const { format = 'pdf' } = req.query;

      const report = await Report.findByPk(reportId);
      if (!report) {
        return res.status(404).json({ error: 'Relatório não encontrado' });
      }

      // Define headers baseado no formato
      if (format === 'pdf') {
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename=report-${reportId}.pdf`);
      } else {
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=report-${reportId}.xlsx`);
      }

      const fileStream = await report.getFileStream();
      fileStream.pipe(res);

    } catch (error) {
      logger.error('Erro ao baixar relatório:', error);
      return res.status(500).json({ error: 'Erro ao baixar relatório' });
    }
  }

  async list(req, res) {
    try {
      const { page = 1, limit = 10, type } = req.query;

      const where = {};
      if (type) where.type = type;

      const reports = await Report.findAndCountAll({
        where,
        order: [['created_at', 'DESC']],
        limit: parseInt(limit),
        offset: (page - 1) * limit
      });

      return res.json({
        items: reports.rows,
        total: reports.count,
        page: parseInt(page),
        pages: Math.ceil(reports.count / limit)
      });

    } catch (error) {
      logger.error('Erro ao listar relatórios:', error);
      return res.status(500).json({ error: 'Erro ao listar relatórios' });
    }
  }

  async delete(req, res) {
    try {
      const report = await Report.findByPk(req.params.id);
      if (!report) {
        return res.status(404).json({ error: 'Relatório não encontrado' });
      }

      await report.deleteFile(); // Remove arquivo do S3
      await report.destroy();

      return res.status(204).send();
    } catch (error) {
      logger.error('Erro ao deletar relatório:', error);
      return res.status(500).json({ error: 'Erro ao deletar relatório' });
    }
  }
}

module.exports = new ReportController();

================
File: src/controllers/ServiceOrderController.js
================
const {ServiceOrder} = require('../models/ServiceOrder');
const {File} = require('../models/File');
const {Equipment} = require('../models/Equipment');
const {MaintenanceHistory} = require('../models/MaintenanceHistory')
const {User} = require('../models/User');

const S3Service = require('../services/S3Service');

class ServiceOrderController {
  async store(req, res) {
    const {
      equipment_id,
      description,
      type,
      priority,
      scheduled_for,
    } = req.body;

    const equipment = await Equipment.findByPk(equipment_id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    const serviceOrder = await ServiceOrder.create({
      equipment_id,
      description,
      type,
      priority,
      scheduled_for,
      created_by: req.userId,
    });

    if (req.files) {
      const filesPromises = req.files.map(file => 
        S3Service.uploadToS3(file).then(url => 
          File.create({
            name: file.originalname,
            path: url,
            service_order_id: serviceOrder.id,
          })
        )
      );

      await Promise.all(filesPromises);
    }

    return res.status(201).json(serviceOrder);
  }

  async index(req, res) {
    const { status, equipment_id, date_start, date_end } = req.query;
    const where = {};

    if (status) where.status = status;
    if (equipment_id) where.equipment_id = equipment_id;
    if (date_start && date_end) {
      where.scheduled_for = {
        [Op.between]: [date_start, date_end],
      };
    }

    const serviceOrders = await ServiceOrder.findAll({
      where,
      include: [
        {
          model: Equipment,
          as: 'equipment',
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name'],
        },
        {
          model: File,
          as: 'files',
        },
      ],
      order: [['scheduled_for', 'ASC']],
    });

    return res.json(serviceOrders);
  }

  async update(req, res) {
    const serviceOrder = await ServiceOrder.findByPk(req.params.id);

    if (!serviceOrder) {
      return res.status(404).json({ error: 'Ordem de serviço não encontrada' });
    }

    if (req.body.status === 'completed') {
      req.body.completed_at = new Date();

      await MaintenanceHistory.create({
        equipment_id: serviceOrder.equipment_id,
        maintenance_date: req.body.completed_at,
        type: serviceOrder.type,
        description: serviceOrder.description,
        performed_by: req.userId,
      });
    }

    await serviceOrder.update(req.body);

    return res.json(serviceOrder);
  }
}

module.exports = new ServiceOrderController();

================
File: src/controllers/UserController.js
================
const { User } = require('../models');
const { generateToken } = require('../utils/auth');

class UserController {
  async store(req, res) {
    const { email } = req.body;

    const userExists = await User.findOne({ where: { email } });

    if (userExists) {
      return res.status(400).json({ error: 'Usuário já existe' });
    }

    const user = await User.create(req.body);

    user.password = undefined;

    return res.status(201).json({
      user,
      token: generateToken({ id: user.id }),
    });
  }

  async update(req, res) {
    const { email, oldPassword } = req.body;
    const user = await User.findByPk(req.userId);

    if (email && email !== user.email) {
      const userExists = await User.findOne({ where: { email } });
      if (userExists) {
        return res.status(400).json({ error: 'Email já está em uso' });
      }
    }

    if (oldPassword && !(await user.checkPassword(oldPassword))) {
      return res.status(401).json({ error: 'Senha incorreta' });
    }

    await user.update(req.body);

    user.password = undefined;

    return res.json(user);
  }

  async index(req, res) {
    const users = await User.findAll({
      attributes: { exclude: ['password'] },
    });

    return res.json(users);
  }
}

module.exports = new UserController();

================
File: src/database/migrations/01-create-users.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('users', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false
        },
        email: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true
        },
        password_hash: {
          type: Sequelize.STRING,
          allowNull: false
        },
        role: {
          type: Sequelize.ENUM('admin', 'manager', 'technician'),
          defaultValue: 'technician'
        },
        department: {
          type: Sequelize.STRING
        },
        active: {
          type: Sequelize.BOOLEAN,
          defaultValue: true
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('users');
    }
  };

================
File: src/database/migrations/02-create-equipment.js
================
// Migration: 02-create-equipment.js
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('equipment', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false
        },
        code: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true
        },
        serial_number: {
          type: Sequelize.STRING
        },
        department: {
          type: Sequelize.STRING,
          allowNull: false
        },
        description: {
          type: Sequelize.TEXT
        },
        status: {
          type: Sequelize.ENUM('active', 'maintenance', 'inactive'),
          defaultValue: 'active'
        },
        maintenance_frequency: {
          type: Sequelize.INTEGER, // em dias
          defaultValue: 30
        },
        last_maintenance: {
          type: Sequelize.DATE
        },
        qrcode_url: {
          type: Sequelize.STRING
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('equipment');
    }
  };

================
File: src/database/migrations/03-create-maintenance.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('maintenance', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        equipment_id: {
          type: Sequelize.INTEGER,
          references: { model: 'equipment', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        technician_id: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        type: {
          type: Sequelize.ENUM('preventive', 'corrective', 'predictive'),
          allowNull: false
        },
        status: {
          type: Sequelize.ENUM('pending', 'in_progress', 'completed', 'cancelled'),
          defaultValue: 'pending'
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: false
        },
        scheduled_date: {
          type: Sequelize.DATE,
          allowNull: false
        },
        completed_date: {
          type: Sequelize.DATE
        },
        cost: {
          type: Sequelize.DECIMAL(10, 2)
        },
        notes: {
          type: Sequelize.TEXT
        },
        created_by: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('maintenance');
    }
  };

================
File: src/database/migrations/04-create-notifications.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('notifications', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        recipient_id: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        type: {
          type: Sequelize.STRING,
          allowNull: false
        },
        title: {
          type: Sequelize.STRING,
          allowNull: false
        },
        message: {
          type: Sequelize.TEXT,
          allowNull: false
        },
        read: {
          type: Sequelize.BOOLEAN,
          defaultValue: false
        },
        reference_type: {
          type: Sequelize.STRING
        },
        reference_id: {
          type: Sequelize.INTEGER
        },
        priority: {
          type: Sequelize.ENUM('low', 'normal', 'high'),
          defaultValue: 'normal'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('notifications');
    }
  };

================
File: src/database/migrations/05-create-reports.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('reports', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        type: {
          type: Sequelize.STRING,
          allowNull: false
        },
        title: {
          type: Sequelize.STRING,
          allowNull: false
        },
        filters: {
          type: Sequelize.JSONB
        },
        file_url: {
          type: Sequelize.STRING
        },
        status: {
          type: Sequelize.ENUM('processing', 'completed', 'error'),
          defaultValue: 'processing'
        },
        error_message: {
          type: Sequelize.TEXT
        },
        created_by: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('reports');
    }
  };

================
File: src/database/index.js
================
const { sequelize } = require('../models'); // Importa os modelos já inicializados do `models/index.js`
const config = require('../config/database');

const env = process.env.NODE_ENV || 'development';
const dbConfig = config[env];

// Caso queira garantir que a instância esteja corretamente configurada
if (!sequelize) {
  throw new Error('Falha ao conectar com o banco de dados.');
}

// Sincroniza o banco de dados com os modelos
sequelize.authenticate()
  .then(() => console.log('Conexão com o banco de dados estabelecida com sucesso!'))
  .catch(err => console.error('Não foi possível conectar ao banco de dados:', err));

module.exports = sequelize;

================
File: src/jobs/processors/index.js
================
const reportProcessor = require('./reportProcessor');
const notificationProcessor = require('./notificationProcessor');
const fileProcessor = require('./fileProcessor');
const equipmentProcessor = require('./equipmentProcessor');

module.exports = {
  reportProcessor,
  notificationProcessor,
  fileProcessor,
  equipmentProcessor
};

// Processadores específicos
const processors = {
  // Processador de Relatórios
  reportProcessor: {
    async generate(type, filters) {
      // Implementação específica para cada tipo de relatório
      switch (type) {
        case 'maintenance':
          return await generateMaintenanceReport(filters);
        case 'equipment':
          return await generateEquipmentReport(filters);
        case 'cost':
          return await generateCostReport(filters);
        default:
          throw new Error(`Tipo de relatório não suportado: ${type}`);
      }
    }
  },

  // Processador de Notificações
  notificationProcessor: {
    async send(type, data) {
      switch (type) {
        case 'maintenance_due':
          return await sendMaintenanceNotification(data);
        case 'equipment_status':
          return await sendStatusNotification(data);
        case 'report_ready':
          return await sendReportNotification(data);
        default:
          throw new Error(`Tipo de notificação não suportado: ${type}`);
      }
    }
  },

  // Processador de Arquivos
  fileProcessor: {
    async process(file, type) {
      switch (type) {
        case 'image':
          return await processImage(file);
        case 'document':
          return await processDocument(file);
        case 'qrcode':
          return await generateQRCode(file);
        default:
          throw new Error(`Tipo de arquivo não suportado: ${type}`);
      }
    }
  },

  // Processador de Equipamentos
  equipmentProcessor: {
    async sync(equipmentId, changes) {
      try {
        // Sincroniza mudanças no equipamento
        const equipment = await Equipment.findByPk(equipmentId);
        if (!equipment) {
          throw new Error('Equipamento não encontrado');
        }

        // Atualiza dados
        await equipment.update(changes);

        // Gera novo QR Code se necessário
        if (changes.needsNewQRCode) {
          await generateAndUpdateQRCode(equipment);
        }

        // Atualiza cache
        await cacheService.invalidateEquipmentCache(equipmentId);

        return equipment;
      } catch (error) {
        console.error('Erro na sincronização:', error);
        throw error;
      }
    }
  }
};

module.exports = processors;

================
File: src/jobs/jobProcessor.js
================
const Queue = require('bull');
const path = require('path');
const processors = require('./processors');

class JobProcessor {
  constructor() {
    this.queues = {
      reportGeneration: new Queue('reportGeneration', {
        redis: {
          host: process.env.REDIS_HOST,
          port: process.env.REDIS_PORT,
          password: process.env.REDIS_PASSWORD
        },
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 1000
          },
          removeOnComplete: true
        }
      }),
      maintenanceNotification: new Queue('maintenanceNotification'),
      fileProcessing: new Queue('fileProcessing'),
      equipmentSync: new Queue('equipmentSync')
    };

    this.initializeProcessors();
  }

  initializeProcessors() {
    // Report Generation Queue
    this.queues.reportGeneration.process(async (job) => {
      try {
        const { type, filters, userId } = job.data;
        const report = await processors.reportProcessor.generate(type, filters);
        
        // Notifica o usuário que o relatório está pronto
        await this.queues.maintenanceNotification.add({
          type: 'REPORT_READY',
          userId,
          reportUrl: report.url
        });

        return report;
      } catch (error) {
        console.error('Erro ao gerar relatório:', error);
        throw error;
      }
    });

    // File Processing Queue
    this.queues.fileProcessing.process(async (job) => {
      const { file, type } = job.data;
      return await processors.fileProcessor.process(file, type);
    });

    // Equipment Sync Queue
    this.queues.equipmentSync.process(async (job) => {
      const { equipmentId, changes } = job.data;
      return await processors.equipmentProcessor.sync(equipmentId, changes);
    });

    // Maintenance Notification Queue
    this.queues.maintenanceNotification.process(async (job) => {
      const { type, data } = job.data;
      return await processors.notificationProcessor.send(type, data);
    });
  }

  // Adiciona job na fila de geração de relatórios
  async addReportJob(type, filters, userId) {
    return await this.queues.reportGeneration.add({
      type,
      filters,
      userId
    });
  }

  // Adiciona job na fila de processamento de arquivos
  async addFileProcessingJob(file, type) {
    return await this.queues.fileProcessing.add({
      file,
      type
    });
  }

  // Adiciona job na fila de sincronização de equipamentos
  async addEquipmentSyncJob(equipmentId, changes) {
    return await this.queues.equipmentSync.add({
      equipmentId,
      changes
    });
  }

  // Adiciona job na fila de notificações
  async addNotificationJob(type, data) {
    return await this.queues.maintenanceNotification.add({
      type,
      data
    });
  }

  // Retorna o status de todos os jobs
  async getJobsStatus() {
    const status = {};
    
    for (const [queueName, queue] of Object.entries(this.queues)) {
      status[queueName] = {
        waiting: await queue.getWaitingCount(),
        active: await queue.getActiveCount(),
        completed: await queue.getCompletedCount(),
        failed: await queue.getFailedCount()
      };
    }

    return status;
  }

  // Limpa jobs completados
  async cleanCompletedJobs() {
    for (const queue of Object.values(this.queues)) {
      await queue.clean(1000 * 60 * 60 * 24, 'completed'); // Remove jobs completados há mais de 24h
    }
  }
}

module.exports = new JobProcessor();

================
File: src/middlewares/auth.js
================
const jwt = require('jsonwebtoken');
const { User } = require('../models/User');

class AuthMiddleware {
  async authenticate(req, res, next) {
    try {
      const authHeader = req.headers.authorization;

      if (!authHeader) {
        return res.status(401).json({ error: 'Token não fornecido' });
      }

      const [, token] = authHeader.split(' ');

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      const user = await User.findByPk(decoded.id);
      
      if (!user || !user.active) {
        return res.status(401).json({ error: 'Usuário inválido ou inativo' });
      }

      req.userId = user.id;
      req.userRole = user.role;
      
      next();
    } catch (error) {
      return res.status(401).json({ error: 'Token inválido' });
    }
  }

  hasRole(roles) {
    return (req, res, next) => {
      if (!roles.includes(req.userRole)) {
        return res.status(403).json({ error: 'Acesso não autorizado' });
      }
      next();
    };
  }

  isAdmin(req, res, next) {
    if (req.userRole !== 'admin') {
      return res.status(403).json({ error: 'Acesso restrito a administradores' });
    }
    next();
  }

  // Middleware para verificar se o usuário tem acesso ao departamento
  async hasDepartmentAccess(req, res, next) {
    try {
      if (req.userRole === 'admin') {
        return next();
      }

      const user = await User.findByPk(req.userId);
      const requestedDepartment = req.body.department || req.query.department;

      if (!requestedDepartment || user.department === requestedDepartment) {
        return next();
      }

      return res.status(403).json({ error: 'Acesso não autorizado ao departamento' });
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new AuthMiddleware();

================
File: src/middlewares/errorHandler.js
================
const { ValidationError } = require('sequelize');

module.exports = (err, req, res, next) => {
  if (err instanceof ValidationError) {
    return res.status(400).json({
      error: 'Erro de validação',
      messages: err.errors.map(error => error.message),
    });
  }

  console.error(err);

  return res.status(500).json({
    error: 'Erro interno do servidor',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined,
  });
};

================
File: src/middlewares/security.js
================
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const xss = require('xss-clean');
const cors = require('cors');
const hpp = require('hpp');
const mongoSanitize = require('express-mongo-sanitize');

// Rate limiter
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // limite por IP
  message: 'Muitas requisições deste IP, tente novamente em 15 minutos'
});

// Limiter específico para autenticação
const authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 5, // 5 tentativas
  message: 'Muitas tentativas de login, tente novamente em 1 hora'
});

const security = {
  // Configurações básicas de segurança
  basic: [
    helmet(), // Segurança básica de headers
    xss(), // Prevenção XSS
    hpp(), // Proteção contra poluição de parâmetros
    mongoSanitize(), // Sanitização de dados
    cors({
      origin: process.env.CORS_ORIGIN || '*',
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
      allowedHeaders: ['Content-Type', 'Authorization']
    })
  ],

  // Rate limiting
  rateLimit: {
    all: limiter,
    auth: authLimiter
  },

  // Validação de uploads
  validateUpload: (req, res, next) => {
    const file = req.file;
    
    if (!file) {
      return next();
    }

    // Verifica tamanho máximo (5MB)
    const maxSize = 5 * 1024 * 1024;
    if (file.size > maxSize) {
      return res.status(400).json({
        error: 'Arquivo muito grande. Tamanho máximo: 5MB'
      });
    }

    // Verifica tipos permitidos
    const allowedTypes = [
      'image/jpeg',
      'image/png',
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];

    if (!allowedTypes.includes(file.mimetype)) {
      return res.status(400).json({
        error: 'Tipo de arquivo não permitido'
      });
    }

    next();
  },

  // Sanitização de dados
  sanitizeData: (req, res, next) => {
    if (req.body) {
      Object.keys(req.body).forEach(key => {
        if (typeof req.body[key] === 'string') {
          req.body[key] = req.body[key].trim();
        }
      });
    }
    next();
  },

  // Validação de tokens JWT
  validateJWT: (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ error: 'Token não fornecido' });
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.userId = decoded.id;
      next();
    } catch (error) {
      return res.status(401).json({ error: 'Token inválido' });
    }
  },

  // Controle de acesso baseado em roles
  checkRole: (roles) => {
    return async (req, res, next) => {
      try {
        const user = await User.findByPk(req.userId);
        
        if (!user) {
          return res.status(404).json({ error: 'Usuário não encontrado' });
        }

        if (!roles.includes(user.role)) {
          return res.status(403).json({ error: 'Acesso não autorizado' });
        }

        next();
      } catch (error) {
        next(error);
      }
    };
  }
};

module.exports = security;

================
File: src/middlewares/validate.js
================
const yup = require('yup');

module.exports = schema => async (req, res, next) => {
  try {
    await schema.validate(req.body, { abortEarly: false });
    return next();
  } catch (err) {
    return res.status(400).json({
      error: 'Erro de validação',
      messages: err.inner.map(error => ({
        field: error.path,
        message: error.message,
      })),
    });
  }
};

================
File: src/models/Equipment.js
================
const { Model, DataTypes } = require('sequelize');

class Equipment extends Model {
  static init(sequelize) {
    super.init(
      {
        name: {
          type: DataTypes.STRING,
          allowNull: false,
          validate: {
            notEmpty: true,
          },
        },
        code: {
          type: DataTypes.STRING,
          allowNull: false,
          unique: true,
        },
        serial_number: DataTypes.STRING,
        department: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        description: DataTypes.TEXT,
        status: {
          type: DataTypes.ENUM('active', 'maintenance', 'inactive'),
          defaultValue: 'active',
        },
        qrcode_url: DataTypes.STRING,
        last_maintenance: DataTypes.DATE,
        maintenance_frequency: {
          type: DataTypes.INTEGER,
          defaultValue: 30,
        },
      },
      {
        sequelize,
        tableName: 'equipment',
      }
    );
    return this;
  }

  static associate(models) {
    this.hasMany(models.ServiceOrder, {
      foreignKey: 'equipment_id',
      as: 'service_orders',
    });
    this.hasMany(models.MaintenanceHistory, {
      foreignKey: 'equipment_id',
      as: 'maintenance_history',
    });
  }
}

module.exports = Equipment;

================
File: src/models/File.js
================
const { Model, DataTypes } = require('sequelize');

class File extends Model {
  static init(sequelize) {
    super.init(
      {
        name: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        path: {
          type: DataTypes.STRING,
          allowNull: false,
          unique: true,
        },
        url: {
          type: DataTypes.VIRTUAL,
          get() {
            return `${process.env.APP_URL}/files/${this.path}`;
          },
        },
      },
      {
        sequelize,
        tableName: 'files',
      }
    );
    return this;
  }

  static associate(models) {
    this.belongsTo(models.ServiceOrder, { 
      foreignKey: 'service_order_id',
      as: 'service_order' 
    });
  }
}

module.exports = File;

================
File: src/models/index.js
================
const { Sequelize } = require('sequelize');
const dbConfig = require('../config/database');

const sequelize = new Sequelize(dbConfig);

const User = require('./User')(sequelize);
const ServiceOrder = require('./ServiceOrder')(sequelize);
const MaintenanceHistory = require('./MaintenanceHistory')(sequelize);
const Notification = require('./Notification')(sequelize);
const File = require('./File')(sequelize);
const Equipment = require('./Equipment')(sequelize);

const models = { User, ServiceOrder, MaintenanceHistory, Notification, File, Equipment };

Object.values(models).forEach(model => {
  if (model.associate) {
    model.associate(models);
  }
});

module.exports = { sequelize, Sequelize, ...models };

================
File: src/models/MaintenanceHistory.js
================
const { Model, DataTypes } = require('sequelize');

class MaintenanceHistory extends Model {
  static init(sequelize) {
    super.init(
      {
        maintenance_date: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        type: {
          type: DataTypes.ENUM('preventive', 'corrective', 'predictive'),
          allowNull: false,
        },
        description: DataTypes.TEXT,
        cost: {
          type: DataTypes.DECIMAL(10, 2),
          validate: {
            min: 0,
          },
        },
        parts_replaced: DataTypes.JSON,
      },
      {
        sequelize,
        tableName: 'maintenance_history',
      }
    );
    return this;
  }

  static associate(models) {
    this.belongsTo(models.Equipment, { 
      foreignKey: 'equipment_id',
      as: 'equipment',
    });
    this.belongsTo(models.User, { 
      foreignKey: 'performed_by',
      as: 'technician',
    });
  }
}

module.exports = MaintenanceHistory;

================
File: src/models/Notification.js
================
const { Model, DataTypes } = require('sequelize');

class Notification extends Model {
  static init(sequelize) {
    super.init(
      {
        id: {
          type: DataTypes.INTEGER,
          autoIncrement: true,
          primaryKey: true,
        },
        recipient_id: {
          type: DataTypes.INTEGER,
          allowNull: false,
          references: {
            model: 'users',
            key: 'id',
          },
        },
        sender_id: {
          type: DataTypes.INTEGER,
          allowNull: true,
          references: {
            model: 'users',
            key: 'id',
          },
        },
        type: {
          type: DataTypes.STRING,
          allowNull: false,
          validate: {
            notEmpty: true,
          },
        },
        title: {
          type: DataTypes.STRING,
          allowNull: false,
          validate: {
            len: [5, 255],
          },
        },
        message: {
          type: DataTypes.TEXT,
          allowNull: false,
          validate: {
            notEmpty: true,
          },
        },
        read: {
          type: DataTypes.BOOLEAN,
          defaultValue: false,
        },
        reference_type: {
          type: DataTypes.STRING,
          allowNull: true,
        },
        reference_id: {
          type: DataTypes.INTEGER,
          allowNull: true,
        },
        priority: {
          type: DataTypes.ENUM('low', 'normal', 'high'),
          defaultValue: 'normal',
          validate: {
            isIn: [['low', 'normal', 'high']],
          },
        },
      },
      {
        sequelize,
        modelName: 'Notification',
        tableName: 'notifications',
        timestamps: true,
        underscored: true,
        paranoid: false, // Se quiser soft delete, mude para `true`
        indexes: [
          {
            fields: ['recipient_id'],
          },
          {
            fields: ['read'],
          },
        ],
      }
    );
    return this;
  }

  static associate(models) {
    this.belongsTo(models.User, {
      foreignKey: 'recipient_id',
      as: 'recipient',
    });

    this.belongsTo(models.User, {
      foreignKey: 'sender_id',
      as: 'sender',
    });
  }
}

module.exports = Notification;

================
File: src/models/ServiceOrder.js
================
const { Model, DataTypes } = require('sequelize');

class ServiceOrder extends Model {
  static init(sequelize) {
    super.init(
      {
        description: {
          type: DataTypes.TEXT,
          allowNull: false,
        },
        type: {
          type: DataTypes.ENUM('preventive', 'corrective', 'predictive'),
          allowNull: false,
        },
        priority: {
          type: DataTypes.ENUM('low', 'medium', 'high', 'critical'),
          allowNull: false,
          defaultValue: 'medium',
        },
        status: {
          type: DataTypes.ENUM('pending', 'in_progress', 'completed', 'cancelled'),
          allowNull: false,
          defaultValue: 'pending',
        },
        scheduled_for: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        completed_at: {
          type: DataTypes.DATE,
          allowNull: true,
        },
        cost: {
          type: DataTypes.DECIMAL(10, 2),
          allowNull: true,
          validate: {
            min: 0,
          },
        },
        notes: {
          type: DataTypes.TEXT,
          allowNull: true,
        },
      },
      {
        sequelize,
        modelName: 'ServiceOrder',
        tableName: 'service_orders',
        underscored: true,
        timestamps: true,
      }
    );
    return this;
  }

  static associate(models) {
    this.belongsTo(models.Equipment, {
      foreignKey: 'equipment_id',
      as: 'equipment',
    });
    this.belongsTo(models.User, {
      foreignKey: 'created_by',
      as: 'creator',
    });
    this.belongsTo(models.User, {
      foreignKey: 'assigned_to',
      as: 'technician',
    });
    this.hasMany(models.File, {
      foreignKey: 'service_order_id',
      as: 'files',
    });
  }
}

module.exports = ServiceOrder;

================
File: src/models/User.js
================
const { Model, DataTypes } = require('sequelize');
const bcrypt = require('bcryptjs');

class User extends Model {
  static init(sequelize) {
    super.init(
      {
        name: {
          type: DataTypes.STRING,
          allowNull: false,
          validate: {
            notEmpty: true,
          },
        },
        email: {
          type: DataTypes.STRING,
          allowNull: false,
          unique: true,
          validate: {
            isEmail: true,
          },
        },
        password: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        role: {
          type: DataTypes.ENUM('admin', 'manager', 'technician'),
          allowNull: false,
          defaultValue: 'technician',
        },
        active: {
          type: DataTypes.BOOLEAN,
          defaultValue: true,
        },
      },
      {
        sequelize,
        modelName: 'User',
        tableName: 'users',
        timestamps: true,
        underscored: true,
        hooks: {
          beforeSave: async (user) => {
            if (user.changed('password')) {
              user.password = await bcrypt.hash(user.password, 8);
            }
          },
        },
      }
    );
    return this;
  }

  static associate(models) {
    this.hasMany(models.ServiceOrder, {
      foreignKey: 'created_by',
      as: 'service_orders',
    });
    this.hasMany(models.MaintenanceHistory, {
      foreignKey: 'performed_by',
      as: 'maintenance_history',
    });
  }

  checkPassword(password) {
    return bcrypt.compare(password, this.password);
  }
}

module.exports = User;

================
File: src/routes/index.js
================
const express = require('express');
const router = express.Router();
const multer = require('multer');
const multerConfig = require('../config/multer');

// Middlewares
const AuthMiddleware = require('../middlewares/auth');
const validate = require('../middlewares/validate');
const schemas = require('../validations/schemas');

// Controllers
const authController = require('../controllers/AuthController');
const equipmentController = require('../controllers/EquipmentController');
const serviceOrderController = require('../controllers/ServiceOrderController');
const userController = require('../controllers/UserController');
const maintenanceController = require('../controllers/MaintenanceController');
const notificationController = require('../controllers/NotificationController');
const reportController = require('../controllers/ReportController');
const dashboardController = require('../controllers/DashboardController');

const upload = multer(multerConfig);

// Rotas públicas
router.post('/auth/login', validate(schemas.loginSchema), authController.login);
router.post('/auth/forgot-password', authController.forgotPassword);
router.post('/auth/reset-password', authController.resetPassword);

// Middleware de autenticação para rotas protegidas
router.use(AuthMiddleware.authenticate);

// Equipamentos
router.get('/equipment', 
  AuthMiddleware.hasDepartmentAccess,
  equipmentController.index
);

router.post('/equipment',
  AuthMiddleware.hasRole(['admin', 'manager']),
  validate(schemas.equipmentSchema),
  upload.single('image'),
  equipmentController.store
);

router.get('/equipment/:id',
  AuthMiddleware.hasDepartmentAccess,
  equipmentController.show
);

router.put('/equipment/:id',
  AuthMiddleware.hasRole(['admin', 'manager']),
  validate(schemas.equipmentSchema),
  upload.single('image'),
  equipmentController.update
);

router.delete('/equipment/:id',
  AuthMiddleware.hasRole(['admin']),
  equipmentController.delete
);

router.get('/equipment/:id/qrcode',
  AuthMiddleware.hasDepartmentAccess,
  equipmentController.generateQRCode
);

// Manutenções
router.post('/maintenance',
  validate(schemas.maintenanceSchema),
  upload.fields([
    { name: 'photos', maxCount: 5 },
    { name: 'documents', maxCount: 3 }
  ]),
  maintenanceController.store
);

router.get('/maintenance',
  AuthMiddleware.hasDepartmentAccess,
  maintenanceController.index
);

router.get('/maintenance/:id',
  AuthMiddleware.hasDepartmentAccess,
  maintenanceController.show
);

router.put('/maintenance/:id',
  AuthMiddleware.hasRole(['admin', 'technician']),
  validate(schemas.maintenanceUpdateSchema),
  maintenanceController.update
);

// Ordens de Serviço
router.get('/service-orders',
  AuthMiddleware.hasDepartmentAccess,
  serviceOrderController.index
);

router.post('/service-orders',
  validate(schemas.serviceOrderSchema),
  upload.array('attachments', 5),
  serviceOrderController.store
);

router.get('/service-orders/:id',
  AuthMiddleware.hasDepartmentAccess,
  serviceOrderController.show
);

router.put('/service-orders/:id',
  AuthMiddleware.hasRole(['admin', 'technician']),
  validate(schemas.serviceOrderUpdateSchema),
  serviceOrderController.update
);

// Usuários
router.get('/users',
  AuthMiddleware.hasRole(['admin']),
  userController.index
);

router.post('/users',
  AuthMiddleware.hasRole(['admin']),
  validate(schemas.userSchema),
  userController.store
);

router.put('/users/:id',
  AuthMiddleware.hasRole(['admin']),
  validate(schemas.userUpdateSchema),
  userController.update
);

// Relatórios
router.get('/reports/maintenance',
  AuthMiddleware.hasRole(['admin', 'manager']),
  reportController.generateMaintenanceReport
);

router.get('/reports/equipment',
  AuthMiddleware.hasRole(['admin', 'manager']),
  reportController.generateEquipmentReport
);

router.get('/reports/performance',
  AuthMiddleware.hasRole(['admin', 'manager']),
  reportController.generatePerformanceReport
);

// Dashboard
router.get('/dashboard/stats',
  AuthMiddleware.hasDepartmentAccess,
  dashboardController.getStats
);

// Notificações
router.get('/notifications',
  notificationController.list
);

router.put('/notifications/preferences',
  notificationController.updatePreferences
);

router.put('/notifications/:id/read',
  notificationController.markAsRead
);

module.exports = router;

================
File: src/services/AuditService.js
================
const { AuditLog, User } = require('../models');
const logger = require('../utils/logger');

class AuditService {
  constructor() {
    this.ignoredFields = ['updated_at', 'created_at'];
  }

  async logAction(params) {
    try {
      const {
        userId,
        action,
        entityType,
        entityId,
        oldValues,
        newValues,
        metadata = {}
      } = params;

      await AuditLog.create({
        user_id: userId,
        action,
        entity_type: entityType,
        entity_id: entityId,
        old_values: oldValues,
        new_values: newValues,
        metadata: {
          ...metadata,
          ip: metadata.ip,
          userAgent: metadata.userAgent,
          timestamp: new Date()
        }
      });

    } catch (error) {
      logger.error('Erro ao registrar log de auditoria:', error);
    }
  }

  async trackChanges(entity, changes, userId, metadata = {}) {
    const changedFields = Object.keys(changes)
      .filter(field => !this.ignoredFields.includes(field));

    if (changedFields.length === 0) return;

    const oldValues = {};
    const newValues = {};

    changedFields.forEach(field => {
      oldValues[field] = entity[field];
      newValues[field] = changes[field];
    });

    await this.logAction({
      userId,
      action: 'UPDATE',
      entityType: entity.constructor.name,
      entityId: entity.id,
      oldValues,
      newValues,
      metadata
    });
  }

  async getAuditTrail(params) {
    try {
      const {
        entityType,
        entityId,
        startDate,
        endDate,
        userId,
        page = 1,
        limit = 20
      } = params;

      const where = {};
      
      if (entityType) where.entity_type = entityType;
      if (entityId) where.entity_id = entityId;
      if (userId) where.user_id = userId;
      if (startDate || endDate) {
        where.created_at = {};
        if (startDate) where.created_at[Op.gte] = startDate;
        if (endDate) where.created_at[Op.lte] = endDate;
      }

      const logs = await AuditLog.findAndCountAll({
        where,
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'name', 'email']
          }
        ],
        order: [['created_at', 'DESC']],
        limit,
        offset: (page - 1) * limit
      });

      return {
        logs: logs.rows,
        total: logs.count,
        page,
        pages: Math.ceil(logs.count / limit)
      };

    } catch (error) {
      logger.error('Erro ao buscar logs de auditoria:', error);
      throw new Error('Falha ao buscar histórico de auditoria');
    }
  }

  async getEntityHistory(entityType, entityId) {
    try {
      const logs = await AuditLog.findAll({
        where: {
          entity_type: entityType,
          entity_id: entityId
        },
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'name', 'email']
          }
        ],
        order: [['created_at', 'DESC']]
      });

      return this.formatEntityHistory(logs);

    } catch (error) {
      logger.error('Erro ao buscar histórico da entidade:', error);
      throw new Error('Falha ao buscar histórico');
    }
  }

  formatEntityHistory(logs) {
    return logs.map(log => {
      const changes = this.compareValues(log.old_values, log.new_values);
      
      return {
        id: log.id,
        date: log.created_at,
        user: log.user,
        action: log.action,
        changes,
        metadata: log.metadata
      };
    });
  }

  compareValues(oldValues, newValues) {
    const changes = [];
    const allFields = new Set([
      ...Object.keys(oldValues || {}),
      ...Object.keys(newValues || {})
    ]);

    allFields.forEach(field => {
      if (this.ignoredFields.includes(field)) return;

      const oldValue = oldValues?.[field];
      const newValue = newValues?.[field];

      if (oldValue !== newValue) {
        changes.push({
          field,
          from: oldValue,
          to: newValue
        });
      }
    });

    return changes;
  }

  // Migration para a tabela de auditoria
  static get migration() {
    return {
      up: async (queryInterface, Sequelize) => {
        await queryInterface.createTable('audit_logs', {
          id: {
            type: Sequelize.INTEGER,
            primaryKey: true,
            autoIncrement: true
          },
          user_id: {
            type: Sequelize.INTEGER,
            references: { model: 'users', key: 'id' },
            onUpdate: 'CASCADE',
            onDelete: 'SET NULL'
          },
          action: {
            type: Sequelize.STRING,
            allowNull: false
          },
          entity_type: {
            type: Sequelize.STRING,
            allowNull: false
          },
          entity_id: {
            type: Sequelize.INTEGER,
            allowNull: false
          },
          old_values: {
            type: Sequelize.JSONB
          },
          new_values: {
            type: Sequelize.JSONB
          },
          metadata: {
            type: Sequelize.JSONB
          },
          created_at: {
            type: Sequelize.DATE,
            allowNull: false
          },
          // Continuação da migration anterior...
          updated_at: {
            type: Sequelize.DATE,
            allowNull: false
          },
          ip_address: {
            type: Sequelize.STRING
          },
          user_agent: {
            type: Sequelize.STRING
          },
          browser: {
            type: Sequelize.STRING
          },
          platform: {
            type: Sequelize.STRING
          }
        });

        // Índices para melhor performance
        await queryInterface.addIndex('audit_logs', ['entity_type', 'entity_id']);
        await queryInterface.addIndex('audit_logs', ['user_id']);
        await queryInterface.addIndex('audit_logs', ['created_at']);
      },

      down: async (queryInterface) => {
        await queryInterface.dropTable('audit_logs');
      }
    };
  }
}

// Modelo Sequelize para AuditLog
const AuditLogModel = (sequelize, DataTypes) => {
  const AuditLog = sequelize.define('AuditLog', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    user_id: {
      type: DataTypes.INTEGER,
      references: {
        model: 'users',
        key: 'id'
      }
    },
    action: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        isIn: [['CREATE', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT', 'FAILED_LOGIN']]
      }
    },
    entity_type: {
      type: DataTypes.STRING,
      allowNull: false
    },
    entity_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    old_values: {
      type: DataTypes.JSONB
    },
    new_values: {
      type: DataTypes.JSONB
    },
    metadata: {
      type: DataTypes.JSONB
    },
    ip_address: DataTypes.STRING,
    user_agent: DataTypes.STRING,
    browser: DataTypes.STRING,
    platform: DataTypes.STRING
  }, {
    tableName: 'audit_logs',
    timestamps: true
  });

  AuditLog.associate = (models) => {
    AuditLog.belongsTo(models.User, {
      foreignKey: 'user_id',
      as: 'user'
    });
  };

  return AuditLog;
};

// Middleware para capturar automaticamente mudanças nos modelos
const auditMiddleware = (schema) => {
  schema.addHook('beforeUpdate', async (instance, options) => {
    if (!options.userId) return;

    const changes = instance.changed();
    if (!changes) return;

    const oldValues = {};
    const newValues = {};

    changes.forEach(field => {
      oldValues[field] = instance._previousDataValues[field];
      newValues[field] = instance.dataValues[field];
    });

    await AuditLog.create({
      user_id: options.userId,
      action: 'UPDATE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      old_values: oldValues,
      new_values: newValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });

  schema.addHook('afterCreate', async (instance, options) => {
    if (!options.userId) return;

    await AuditLog.create({
      user_id: options.userId,
      action: 'CREATE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      new_values: instance.dataValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });

  schema.addHook('beforeDestroy', async (instance, options) => {
    if (!options.userId) return;

    await AuditLog.create({
      user_id: options.userId,
      action: 'DELETE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      old_values: instance.dataValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });
};

// Middleware Express para incluir informações de auditoria
const auditMiddlewareExpress = (req, res, next) => {
  if (req.user) {
    req.auditInfo = {
      userId: req.user.id,
      ip: req.ip,
      userAgent: req.get('user-agent'),
      browser: req.get('sec-ch-ua'),
      platform: req.get('sec-ch-ua-platform')
    };
  }
  next();
};

module.exports = {
  AuditService,
  AuditLogModel,
  auditMiddleware,
  auditMiddlewareExpress
};

================
File: src/services/CacheService.js
================
const { getRedisClient } = require('../config/redis');
const logger = require('../utils/logger');

class CacheService {
  constructor() {
    this.redis = getRedisClient();
    this.defaultTTL = 3600; // 1 hora em segundos
  }

  async get(key) {
    try {
      const value = await this.redis.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      logger.error('Erro ao recuperar do cache:', { key, error: error.message });
      return null;
    }
  }

  async set(key, value, ttl = this.defaultTTL) {
    try {
      await this.redis.set(
        key,
        JSON.stringify(value),
        'EX',
        ttl
      );
      return true;
    } catch (error) {
      logger.error('Erro ao definir cache:', { key, error: error.message });
      return false;
    }
  }

  async delete(key) {
    try {
      await this.redis.del(key);
      return true;
    } catch (error) {
      logger.error('Erro ao deletar cache:', { key, error: error.message });
      return false;
    }
  }

  async getOrSet(key, callback, ttl = this.defaultTTL) {
    let data = await this.get(key);
    
    if (!data) {
      data = await callback();
      if (data) {
        await this.set(key, data, ttl);
      }
    }

    return data;
  }

  async invalidatePattern(pattern) {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(keys);
      }
      return true;
    } catch (error) {
      logger.error('Erro ao invalidar padrão de cache:', { pattern, error: error.message });
      return false;
    }
  }

  generateKey(...args) {
    return args.join(':');
  }

  // Cache específico para equipamentos
  async getEquipmentCache(id) {
    return this.get(`equipment:${id}`);
  }

  async setEquipmentCache(id, data) {
    return this.set(`equipment:${id}`, data);
  }

  async invalidateEquipmentCache(id) {
    return this.delete(`equipment:${id}`);
  }

  // Cache para listagens com paginação
  async getListCache(entity, page, limit, filters = {}) {
    const filterString = JSON.stringify(filters);
    const key = this.generateKey(entity, 'list', page, limit, filterString);
    return this.get(key);
  }

  async setListCache(entity, page, limit, filters = {}, data) {
    const filterString = JSON.stringify(filters);
    const key = this.generateKey(entity, 'list', page, limit, filterString);
    return this.set(key, data, 300); // 5 minutos para listas
  }

  // Cache para dashboards
  async getDashboardCache(userId) {
    return this.get(`dashboard:${userId}`);
  }

  async setDashboardCache(userId, data) {
    return this.set(`dashboard:${userId}`, data, 900); // 15 minutos para dashboard
  }

  async clearAllCache() {
    try {
      await this.redis.flushall();
      return true;
    } catch (error) {
      logger.error('Erro ao limpar todo o cache:', error.message);
      return false;
    }
  }
}

module.exports = new CacheService();

================
File: src/services/EmailService.js
================
const nodemailer = require('nodemailer');
const path = require('path');
const ejs = require('ejs');

class EmailService {
  constructor() {
    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    });

    this.templatesPath = path.resolve(__dirname, '..', 'views', 'emails');
  }

  async sendMail({ to, subject, template, context }) {
    const templatePath = path.join(this.templatesPath, `${template}.ejs`);
    
    const html = await ejs.renderFile(templatePath, context);

    return this.transporter.sendMail({
      from: process.env.SMTP_FROM,
      to,
      subject,
      html,
    });
  }

  async sendMaintenanceNotification({ user, equipment, serviceOrder }) {
    return this.sendMail({
      to: user.email,
      subject: `Manutenção Agendada - ${equipment.name}`,
      template: 'maintenance-notification',
      context: {
        userName: user.name,
        equipmentName: equipment.name,
        equipmentCode: equipment.code,
        maintenanceDate: serviceOrder.scheduled_for,
        maintenanceType: serviceOrder.type,
        description: serviceOrder.description,
      },
    });
  }

  async sendMaintenanceComplete({ user, equipment, serviceOrder }) {
    return this.sendMail({
      to: user.email,
      subject: `Manutenção Concluída - ${equipment.name}`,
      template: 'maintenance-complete',
      context: {
        userName: user.name,
        equipmentName: equipment.name,
        equipmentCode: equipment.code,
        completedDate: serviceOrder.completed_at,
        maintenanceType: serviceOrder.type,
        description: serviceOrder.description,
      },
    });
  }
}

module.exports = new EmailService();

================
File: src/services/FileService.js
================
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class FileService {
  constructor() {
    this.uploadPath = path.resolve(__dirname, '..', '..', 'uploads');
    this.ensureUploadDirectory();
  }

  ensureUploadDirectory() {
    if (!fs.existsSync(this.uploadPath)) {
      fs.mkdirSync(this.uploadPath, { recursive: true });
    }
  }

  async saveFile(file) {
    const hash = crypto.randomBytes(10).toString('hex');
    const fileName = `${hash}-${file.originalname}`;
    const filePath = path.join(this.uploadPath, fileName);

    return new Promise((resolve, reject) => {
      fs.writeFile(filePath, file.buffer, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve({
          name: fileName,
          path: filePath,
          url: `/uploads/${fileName}`,
        });
      });
    });
  }

  async deleteFile(fileName) {
    const filePath = path.join(this.uploadPath, fileName);
    return new Promise((resolve, reject) => {
      fs.unlink(filePath, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
}

module.exports = new FileService();

================
File: src/services/MediaService.js
================
const AWS = require('aws-sdk');
const path = require('path');
const sharp = require('sharp');
const { v4: uuid } = require('uuid');

class MediaService {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });
    this.bucketName = process.env.AWS_BUCKET_NAME;
  }

  async uploadPhoto(file, folder = 'photos') {
    try {
      // Processa a imagem com sharp
      const processedImage = await sharp(file.buffer)
        .resize(1200, 1200, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({ quality: 80 })
        .toBuffer();

      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;

      const uploadParams = {
        Bucket: this.bucketName,
        Key: fileName,
        Body: processedImage,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(uploadParams).promise();

      return {
        url: result.Location,
        key: fileName
      };
    } catch (error) {
      console.error('Erro no upload da foto:', error);
      throw new Error('Falha no upload da foto');
    }
  }

  async uploadFile(file, folder = 'attachments') {
    try {
      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;

      const uploadParams = {
        Bucket: this.bucketName,
        Key: fileName,
        Body: file.buffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(uploadParams).promise();

      return {
        url: result.Location,
        key: fileName,
        name: file.originalname,
        type: file.mimetype
      };
    } catch (error) {
      console.error('Erro no upload do arquivo:', error);
      throw new Error('Falha no upload do arquivo');
    }
  }

  async deleteFile(key) {
    try {
      const deleteParams = {
        Bucket: this.bucketName,
        Key: key
      };

      await this.s3.deleteObject(deleteParams).promise();
    } catch (error) {
      console.error('Erro ao deletar arquivo:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async getSignedUrl(key, expirationInSeconds = 3600) {
    try {
      const params = {
        Bucket: this.bucketName,
        Key: key,
        Expires: expirationInSeconds
      };

      return await this.s3.getSignedUrlPromise('getObject', params);
    } catch (error) {
      console.error('Erro ao gerar URL assinada:', error);
      throw new Error('Falha ao gerar URL de acesso');
    }
  }
}

module.exports = new MediaService();

================
File: src/services/NotificationService.js
================
const AWS = require('aws-sdk');
const nodemailer = require('nodemailer');
const cron = require('node-cron');
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const { Op } = require('sequelize');
const logger = require('../utils/logger');

class NotificationService {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });

    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });

    // Inicia os jobs de verificação
    this.initializeJobs();
  }

  initializeJobs() {
    // Verifica manutenções pendentes diariamente às 8h
    cron.schedule('0 8 * * *', () => {
      this.checkPendingMaintenances();
    });

    // Verifica equipamentos com manutenções frequentes semanalmente
    cron.schedule('0 9 * * 1', () => {
      this.checkFrequentMaintenances();
    });
  }

  async uploadFile(file, folder = 'general') {
    try {
      const fileName = `${folder}/${Date.now()}-${file.originalname}`;
      
      const params = {
        Bucket: process.env.AWS_BUCKET_NAME,
        Key: fileName,
        Body: file.buffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(params).promise();
      return result.Location;
    } catch (error) {
      logger.error('Erro no upload para S3:', error);
      throw new Error('Falha no upload do arquivo');
    }
  }

  async deleteFile(fileUrl) {
    try {
      const key = fileUrl.split(`${process.env.AWS_BUCKET_NAME}/`)[1];
      
      await this.s3.deleteObject({
        Bucket: process.env.AWS_BUCKET_NAME,
        Key: key
      }).promise();
      
      return true;
    } catch (error) {
      logger.error('Erro ao deletar arquivo do S3:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async checkPendingMaintenances() {
    try {
      const today = new Date();
      const maintenances = await Maintenance.findAll({
        where: {
          status: 'pending',
          scheduled_for: {
            [Op.lte]: today
          }
        },
        include: [
          {
            model: Equipment,
            attributes: ['name', 'code', 'department']
          }
        ]
      });

      if (maintenances.length > 0) {
        // Busca administradores
        const admins = await User.findAll({
          where: { role: 'admin' }
        });

        // Envia notificações
        for (const admin of admins) {
          await this.sendPendingMaintenanceEmail(admin, maintenances);
        }
      }
    } catch (error) {
      logger.error('Erro ao verificar manutenções pendentes:', error);
    }
  }

  async checkFrequentMaintenances() {
    try {
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      // Busca equipamentos com mais de 3 manutenções nos últimos 30 dias
      const equipments = await Equipment.findAll({
        include: [{
          model: Maintenance,
          where: {
            created_at: {
              [Op.gte]: thirtyDaysAgo
            }
          }
        }],
        having: sequelize.literal('COUNT(Maintenances.id) > 3'),
        group: ['Equipment.id']
      });

      if (equipments.length > 0) {
        const admins = await User.findAll({ where: { role: 'admin' } });
        for (const admin of admins) {
          await this.sendFrequentMaintenanceAlert(admin, equipments);
        }
      }
    } catch (error) {
      logger.error('Erro ao verificar manutenções frequentes:', error);
    }
  }

  async sendPendingMaintenanceEmail(user, maintenances) {
    const mailOptions = {
      from: process.env.SMTP_FROM,
      to: user.email,
      subject: 'Manutenções Pendentes - Atenção Necessária',
      html: `
        <h2>Manutenções Pendentes</h2>
        <p>As seguintes manutenções estão pendentes e requerem atenção:</p>
        <ul>
          ${maintenances.map(m => `
            <li>
              <strong>${m.Equipment.name}</strong> (${m.Equipment.code})<br>
              Departamento: ${m.Equipment.department}<br>
              Agendado para: ${m.scheduled_for.toLocaleDateString()}
            </li>
          `).join('')}
        </ul>
      `
    };

    await this.transporter.sendMail(mailOptions);
  }

  async sendFrequentMaintenanceAlert(user, equipments) {
    const mailOptions = {
      from: process.env.SMTP_FROM,
      to: user.email,
      subject: 'Alerta - Equipamentos com Manutenções Frequentes',
      html: `
        <h2>Equipamentos com Manutenções Frequentes</h2>
        <p>Os seguintes equipamentos apresentaram mais de 3 manutenções nos últimos 30 dias:</p>
        <ul>
          ${equipments.map(e => `
            <li>
              <strong>${e.name}</strong> (${e.code})<br>
              Departamento: ${e.department}<br>
              Total de manutenções: ${e.Maintenances.length}
            </li>
          `).join('')}
        </ul>
      `
    };

    await this.transporter.sendMail(mailOptions);
  }
}

module.exports = new NotificationService();

================
File: src/services/PDFService.js
================
const PDFDocument = require('pdfkit');
const { format } = require('date-fns');
const ptBR = require('date-fns/locale/pt-BR');

class PDFService {
  createMaintenanceReport(equipment, maintenances) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Cabeçalho
        doc.fontSize(20).text('Relatório de Manutenções', { align: 'center' });
        doc.moveDown();

        // Informações do Equipamento
        doc.fontSize(16).text('Dados do Equipamento');
        doc.fontSize(12)
           .text(`Nome: ${equipment.name}`)
           .text(`Código: ${equipment.code}`)
           .text(`Departamento: ${equipment.department}`)
           .text(`Status: ${equipment.status}`);
        
        doc.moveDown();

        // Resumo
        const totalCost = maintenances.reduce((sum, m) => sum + (m.cost || 0), 0);
        doc.fontSize(16).text('Resumo');
        doc.fontSize(12)
           .text(`Total de Manutenções: ${maintenances.length}`)
           .text(`Custo Total: R$ ${totalCost.toFixed(2)}`);
        
        doc.moveDown();

        // Lista de Manutenções
        doc.fontSize(16).text('Histórico de Manutenções');
        doc.moveDown();

        maintenances.forEach(maintenance => {
          doc.fontSize(12)
             .text(`Data: ${format(new Date(maintenance.maintenance_date), 'dd/MM/yyyy')}`)
             .text(`Tipo: ${maintenance.type}`)
             .text(`Descrição: ${maintenance.description}`)
             .text(`Custo: R$ ${maintenance.cost?.toFixed(2) || '0,00'}`)
             .text(`Técnico: ${maintenance.technician?.name || 'Não informado'}`);
          
          if (maintenance.parts_replaced?.length > 0) {
            doc.text('Peças Substituídas:');
            maintenance.parts_replaced.forEach(part => {
              doc.text(`  - ${part.name}: ${part.quantity} unidade(s)`);
            });
          }

          doc.moveDown();
        });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  createEquipmentReport(equipments) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Cabeçalho
        doc.fontSize(20).text('Relatório de Equipamentos', { align: 'center' });
        doc.moveDown();

        // Resumo por Departamento
        const departmentSummary = equipments.reduce((acc, eq) => {
          acc[eq.department] = (acc[eq.department] || 0) + 1;
          return acc;
        }, {});

        doc.fontSize(16).text('Resumo por Departamento');
        Object.entries(departmentSummary).forEach(([dept, count]) => {
          doc.fontSize(12).text(`${dept}: ${count} equipamento(s)`);
        });
        
        doc.moveDown();

        // Lista de Equipamentos
        doc.fontSize(16).text('Lista de Equipamentos');
        doc.moveDown();

        equipments.forEach(equipment => {
          doc.fontSize(12)
             .text(`Nome: ${equipment.name}`)
             .text(`Código: ${equipment.code}`)
             .text(`Departamento: ${equipment.department}`)
             .text(`Status: ${equipment.status}`)
             .text(`Última Manutenção: ${equipment.last_maintenance ? 
               format(new Date(equipment.last_maintenance), 'dd/MM/yyyy') : 
               'Nunca realizada'}`);
          
          doc.moveDown();
        });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }
}

module.exports = new PDFService();

================
File: src/services/PushNotificationService.js
================
import * as Notifications from 'expo-notifications';
import * as Device from 'expo-device';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Platform } from 'react-native';

class PushNotificationService {
  constructor() {
    this.configure();
  }

  async configure() {
    if (Device.isDevice) {
      const { status: existingStatus } = await Notifications.getPermissionsAsync();
      let finalStatus = existingStatus;
      
      if (existingStatus !== 'granted') {
        const { status } = await Notifications.requestPermissionsAsync();
        finalStatus = status;
      }

      if (finalStatus !== 'granted') {
        console.log('Permissão para notificações não concedida!');
        return;
      }

      const token = await this.getDevicePushToken();
      if (token) {
        await this.registerDeviceToken(token);
      }
    }

    // Configuração das notificações
    Notifications.setNotificationHandler({
      handleNotification: async () => ({
        shouldShowAlert: true,
        shouldPlaySound: true,
        shouldSetBadge: true,
      }),
    });
  }

  async getDevicePushToken() {
    try {
      const token = await Notifications.getExpoPushTokenAsync({
        experienceId: '@your-org/your-app'
      });
      return token.data;
    } catch (error) {
      console.error('Erro ao obter token:', error);
      return null;
    }
  }

  async registerDeviceToken(token) {
    try {
      const userId = await AsyncStorage.getItem('userId');
      if (!userId) return;

      await fetch(`${process.env.API_URL}/users/push-token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${await AsyncStorage.getItem('token')}`
        },
        body: JSON.stringify({
          token,
          device: Platform.OS,
          userId
        })
      });
    } catch (error) {
      console.error('Erro ao registrar token:', error);
    }
  }

  async scheduleLocalNotification(title, body, data = {}, trigger = null) {
    try {
      const notificationId = await Notifications.scheduleNotificationAsync({
        content: {
          title,
          body,
          data,
          sound: true,
          priority: 'high',
        },
        trigger: trigger || null,
      });
      return notificationId;
    } catch (error) {
      console.error('Erro ao agendar notificação:', error);
    }
  }

  async cancelNotification(notificationId) {
    try {
      await Notifications.cancelScheduledNotificationAsync(notificationId);
    } catch (error) {
      console.error('Erro ao cancelar notificação:', error);
    }
  }

  async setBadgeCount(count) {
    try {
      await Notifications.setBadgeCountAsync(count);
    } catch (error) {
      console.error('Erro ao definir badge:', error);
    }
  }

  addNotificationReceivedListener(callback) {
    return Notifications.addNotificationReceivedListener(callback);
  }

  addNotificationResponseReceivedListener(callback) {
    return Notifications.addNotificationResponseReceivedListener(callback);
  }

  removeNotificationSubscription(subscription) {
    subscription.remove();
  }

  // Helpers para tipos específicos de notificações
  async scheduleMaintenance(maintenance) {
    const scheduledDate = new Date(maintenance.scheduled_for);
    
    // Notificação 24h antes
    await this.scheduleLocalNotification(
      'Manutenção Agendada',
      `Manutenção do equipamento ${maintenance.equipment.name} amanhã`,
      { maintenanceId: maintenance.id },
      {
        date: new Date(scheduledDate.getTime() - 24 * 60 * 60 * 1000)
      }
    );

    // Notificação 1h antes
    await this.scheduleLocalNotification(
      'Manutenção em Breve',
      `Manutenção do equipamento ${maintenance.equipment.name} em 1 hora`,
      { maintenanceId: maintenance.id },
      {
        date: new Date(scheduledDate.getTime() - 60 * 60 * 1000)
      }
    );
  }

  async notifyMaintenanceComplete(maintenance) {
    await this.scheduleLocalNotification(
      'Manutenção Concluída',
      `A manutenção do equipamento ${maintenance.equipment.name} foi finalizada`,
      { maintenanceId: maintenance.id }
    );
  }

  async notifyMaintenanceOverdue(maintenance) {
    await this.scheduleLocalNotification(
      'Manutenção Atrasada',
      `A manutenção do equipamento ${maintenance.equipment.name} está atrasada`,
      { maintenanceId: maintenance.id }
    );
  }
}

export default new PushNotificationService();

================
File: src/services/QRCodeService.js
================
const QRCode = require('qrcode');
const { v4: uuid } = require('uuid');
const S3Service = require('./S3Service');
const logger = require('../utils/logger');

class QRCodeService {
  constructor() {
    this.baseUrl = process.env.APP_URL;
    this.defaultOptions = {
      errorCorrectionLevel: 'H',
      type: 'svg',
      margin: 1,
      color: {
        dark: '#000000',
        light: '#ffffff'
      }
    };
  }

  async generateForEquipment(equipment) {
    try {
      const data = {
        id: equipment.id,
        code: equipment.code,
        type: 'equipment',
        timestamp: new Date().toISOString()
      };

      const qrUrl = `${this.baseUrl}/equipment/scan/${equipment.id}`;
      
      // Gera o QR Code como SVG
      const qrSvg = await QRCode.toString(qrUrl, {
        ...this.defaultOptions,
        width: 300
      });

      // Converte SVG para Buffer para upload
      const qrBuffer = Buffer.from(qrSvg);

      // Upload para S3
      const fileName = `qrcodes/equipment/${equipment.id}-${uuid()}.svg`;
      const uploaded = await S3Service.uploadFile({
        buffer: qrBuffer,
        originalname: fileName,
        mimetype: 'image/svg+xml'
      }, 'qrcodes');

      return {
        url: uploaded.url,
        key: uploaded.key,
        data: qrUrl
      };

    } catch (error) {
      logger.error('Erro ao gerar QR Code:', error);
      throw new Error('Falha ao gerar QR Code');
    }
  }

  async generateBatch(equipments) {
    try {
      const results = await Promise.all(
        equipments.map(equipment => this.generateForEquipment(equipment))
      );

      return results;
    } catch (error) {
      logger.error('Erro ao gerar lote de QR Codes:', error);
      throw new Error('Falha ao gerar QR Codes em lote');
    }
  }

  async generatePrintableSheet(equipments) {
    try {
      const qrCodes = await this.generateBatch(equipments);

      // Gera HTML para impressão
      const html = this.generatePrintTemplate(equipments, qrCodes);

      // Converte HTML para PDF
      const pdf = await this.convertToPDF(html);

      // Upload do PDF para S3
      const fileName = `qrcodes/sheets/batch-${uuid()}.pdf`;
      const uploaded = await S3Service.uploadFile({
        buffer: pdf,
        originalname: fileName,
        mimetype: 'application/pdf'
      }, 'qrcodes');

      return uploaded.url;

    } catch (error) {
      logger.error('Erro ao gerar folha de QR Codes:', error);
      throw new Error('Falha ao gerar folha de QR Codes');
    }
  }

  generatePrintTemplate(equipments, qrCodes) {
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <style>
            .qr-container {
              display: inline-block;
              margin: 10px;
              padding: 15px;
              border: 1px solid #ccc;
              text-align: center;
            }
            .qr-code {
              width: 200px;
              height: 200px;
            }
            .qr-info {
              margin-top: 10px;
              font-family: Arial, sans-serif;
            }
          </style>
        </head>
        <body>
          ${qrCodes.map((qr, index) => `
            <div class="qr-container">
              <img src="${qr.url}" class="qr-code"/>
              <div class="qr-info">
                <strong>${equipments[index].name}</strong><br/>
                Código: ${equipments[index].code}
              </div>
            </div>
          `).join('')}
        </body>
      </html>
    `;
  }

  validateQRCode(qrData) {
    try {
      // Verifica se o QR Code é válido e pertence ao sistema
      const url = new URL(qrData);
      return url.origin === this.baseUrl && url.pathname.includes('/equipment/scan/');
    } catch (error) {
      return false;
    }
  }
}

module.exports = new QRCodeService();

================
File: src/services/ReportService.js
================
const ExcelJS = require('exceljs');
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const { Op } = require('sequelize');

class ReportService {
  async generateMaintenanceReport(startDate, endDate, department = null) {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Manutenções');

    // Define cabeçalhos
    worksheet.columns = [
      { header: 'Equipamento', key: 'equipment', width: 20 },
      { header: 'Código', key: 'code', width: 15 },
      { header: 'Departamento', key: 'department', width: 15 },
      { header: 'Tipo', key: 'type', width: 15 },
      { header: 'Data', key: 'date', width: 15 },
      { header: 'Status', key: 'status', width: 15 },
      { header: 'Técnico', key: 'technician', width: 20 },
      { header: 'Custo', key: 'cost', width: 15 }
    ];

    // Aplica estilo aos cabeçalhos
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' }
    };

    // Busca dados
    const query = {
      where: {
        created_at: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: Equipment,
          ...(department && {
            where: { department }
          })
        },
        {
          model: User,
          as: 'technician',
          attributes: ['name']
        }
      ]
    };

    const maintenances = await Maintenance.findAll(query);

    // Adiciona dados
    maintenances.forEach(maintenance => {
      worksheet.addRow({
        equipment: maintenance.Equipment.name,
        code: maintenance.Equipment.code,
        department: maintenance.Equipment.department,
        type: maintenance.type,
        date: maintenance.maintenance_date.toLocaleDateString(),
        status: maintenance.status,
        technician: maintenance.technician?.name || 'N/A',
        cost: maintenance.cost || 0
      });
    });

    // Aplica formatação condicional para status
    worksheet.addConditionalFormatting({
      ref: 'F2:F1000',
      rules: [
        {
          type: 'cellIs',
          operator: 'equal',
          formulae: ['"completed"'],
          style: { fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FF90EE90' } } }
        },
        {
          type: 'cellIs',
          operator: 'equal',
          formulae: ['"pending"'],
          style: { fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FFFFCCCB' } } }
        }
      ]
    });

    // Formata coluna de custo
    worksheet.getColumn('cost').numFmt = '"R$ "#,##0.00';

    // Adiciona totais
    const lastRow = worksheet.rowCount + 2;
    worksheet.addRow(['Total de Manutenções:', maintenances.length]);
    worksheet.addRow([
      'Custo Total:',
      {
        formula: `SUM(H2:H${worksheet.rowCount-2})`,
        numFmt: '"R$ "#,##0.00'
      }
    ]);

    // Retorna o buffer
    return await workbook.xlsx.writeBuffer();
  }

  async generateEquipmentReport() {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Equipamentos');

    worksheet.columns = [
      { header: 'Nome', key: 'name', width: 20 },
      { header: 'Código', key: 'code', width: 15 },
      { header: 'Departamento', key: 'department', width: 15 },
      { header: 'Status', key: 'status', width: 15 },
      { header: 'Total Manutenções', key: 'maintenances', width: 18 },
      { header: 'Última Manutenção', key: 'lastMaintenance', width: 18 },
      { header: 'Custo Total', key: 'totalCost', width: 15 }
    ];

    const equipments = await Equipment.findAll({
      include: [{
        model: Maintenance,
        attributes: ['maintenance_date', 'cost']
      }]
    });

    equipments.forEach(equipment => {
      worksheet.addRow({
        name: equipment.name,
        code: equipment.code,
        department: equipment.department,
        status: equipment.status,
        maintenances: equipment.Maintenances.length,
        lastMaintenance: equipment.Maintenances.length ? 
          new Date(Math.max(...equipment.Maintenances.map(m => m.maintenance_date))).toLocaleDateString() : 
          'N/A',
        totalCost: equipment.Maintenances.reduce((sum, m) => sum + (m.cost || 0), 0)
      });
    });

    // Estilização e formatação
    worksheet.getRow(1).font = { bold: true };
    worksheet.getColumn('totalCost').numFmt = '"R$ "#,##0.00';

    return await workbook.xlsx.writeBuffer();
  }
}

module.exports = new ReportService();

================
File: src/services/S3Service.js
================
const AWS = require('aws-sdk');
const sharp = require('sharp');
const mime = require('mime-types');
const path = require('path');
const { v4: uuid } = require('uuid');
const logger = require('../utils/logger');

class S3Service {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });
    this.bucket = process.env.AWS_BUCKET_NAME;
    this.allowedMimes = [
      'image/jpeg',
      'image/png',
      'image/webp',
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
  }

  async uploadFile(file, folder = 'general') {
    try {
      if (!this.allowedMimes.includes(file.mimetype)) {
        throw new Error('Tipo de arquivo não permitido');
      }

      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;
      let processedBuffer = file.buffer;

      // Processa imagens antes do upload
      if (file.mimetype.startsWith('image/')) {
        processedBuffer = await this.processImage(file.buffer);
      }

      const params = {
        Bucket: this.bucket,
        Key: fileName,
        Body: processedBuffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(params).promise();

      return {
        url: result.Location,
        key: fileName,
        type: file.mimetype,
        size: processedBuffer.length
      };

    } catch (error) {
      logger.error('Erro no upload para S3:', error);
      throw new Error('Falha ao fazer upload do arquivo');
    }
  }

  async processImage(buffer) {
    try {
      return await sharp(buffer)
        .resize(1200, 1200, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({
          quality: 80,
          progressive: true
        })
        .toBuffer();
    } catch (error) {
      logger.error('Erro ao processar imagem:', error);
      throw new Error('Falha ao processar imagem');
    }
  }

  async deleteFile(key) {
    try {
      await this.s3.deleteObject({
        Bucket: this.bucket,
        Key: key
      }).promise();

      return true;
    } catch (error) {
      logger.error('Erro ao deletar arquivo do S3:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async generateSignedUrl(key, expiresIn = 3600) {
    try {
      return await this.s3.getSignedUrlPromise('getObject', {
        Bucket: this.bucket,
        Key: key,
        Expires: expiresIn
      });
    } catch (error) {
      logger.error('Erro ao gerar URL assinada:', error);
      throw new Error('Falha ao gerar URL de acesso');
    }
  }

  async moveFile(oldKey, newKey) {
    try {
      // Copia o arquivo para novo local
      await this.s3.copyObject({
        Bucket: this.bucket,
        CopySource: `${this.bucket}/${oldKey}`,
        Key: newKey,
        ACL: 'public-read'
      }).promise();

      // Remove arquivo original
      await this.deleteFile(oldKey);

      return true;
    } catch (error) {
      logger.error('Erro ao mover arquivo:', error);
      throw new Error('Falha ao mover arquivo');
    }
  }
}

module.exports = new S3Service();

================
File: src/services/WebSocketService.js
================
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');
const http = require('http');

class WebSocketService {
  constructor(server) {
    this.wss = new WebSocket.Server({ server });
    this.clients = new Map(); // Map para armazenar conexões de clientes
    this.initialize();
  }

  initialize() {
    this.wss.on('connection', async (ws, req) => {
      try {
        // Autenticação do WebSocket
        const token = this.extractToken(req);
        if (!token) {
          ws.close(4001, 'Unauthorized');
          return;
        }

        const user = await this.authenticateToken(token);
        if (!user) {
          ws.close(4001, 'Invalid token');
          return;
        }

        // Armazena a conexão do cliente
        this.clients.set(user.id, {
          ws,
          user
        });

        // Setup de heartbeat
        ws.isAlive = true;
        ws.on('pong', () => {
          ws.isAlive = true;
        });

        // Listener de mensagens
        ws.on('message', async (message) => {
          try {
            await this.handleMessage(user.id, JSON.parse(message));
          } catch (error) {
            console.error('Erro ao processar mensagem:', error);
            this.sendError(ws, error.message);
          }
        });

        // Listener de fechamento
        ws.on('close', () => {
          this.clients.delete(user.id);
        });

        // Envia confirmação de conexão
        this.sendToClient(user.id, {
          type: 'CONNECTION_ESTABLISHED',
          data: {
            userId: user.id,
            timestamp: new Date()
          }
        });

      } catch (error) {
        console.error('Erro na conexão WebSocket:', error);
        ws.close(4000, 'Internal server error');
      }
    });

    // Configuração do heartbeat
    setInterval(() => {
      this.wss.clients.forEach((ws) => {
        if (!ws.isAlive) {
          return ws.terminate();
        }
        ws.isAlive = false;
        ws.ping(() => {});
      });
    }, 30000);
  }

  async handleMessage(userId, message) {
    const { type, data } = message;

    switch (type) {
      case 'MAINTENANCE_UPDATE':
        await this.handleMaintenanceUpdate(userId, data);
        break;

      case 'EQUIPMENT_STATUS_CHANGE':
        await this.handleEquipmentStatusChange(userId, data);
        break;

      case 'JOIN_EQUIPMENT_ROOM':
        await this.handleJoinEquipmentRoom(userId, data);
        break;

      default:
        throw new Error('Tipo de mensagem não suportado');
    }
  }

  async handleMaintenanceUpdate(userId, data) {
    // Notifica todos os admins e o técnico responsável
    const notification = {
      type: 'MAINTENANCE_UPDATED',
      data: {
        maintenanceId: data.maintenanceId,
        status: data.status,
        updatedBy: userId,
        timestamp: new Date()
      }
    };

    await this.notifyAdmins(notification);
    if (data.technicianId) {
      this.sendToClient(data.technicianId, notification);
    }
  }

  async handleEquipmentStatusChange(userId, data) {
    const notification = {
      type: 'EQUIPMENT_STATUS_CHANGED',
      data: {
        equipmentId: data.equipmentId,
        status: data.status,
        changedBy: userId,
        timestamp: new Date()
      }
    };

    await this.notifyDepartment(data.departmentId, notification);
  }

  async handleJoinEquipmentRoom(userId, data) {
    const client = this.clients.get(userId);
    if (client) {
      client.equipmentRooms = client.equipmentRooms || new Set();
      client.equipmentRooms.add(data.equipmentId);
    }
  }

  // Envia mensagem para um cliente específico
  sendToClient(userId, message) {
    const client = this.clients.get(userId);
    if (client && client.ws.readyState === WebSocket.OPEN) {
      client.ws.send(JSON.stringify(message));
    }
  }

  // Envia mensagem para todos os admins
  async notifyAdmins(message) {
    this.clients.forEach((client) => {
      if (client.user.role === 'admin' && client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(JSON.stringify(message));
      }
    });
  }

  // Envia mensagem para todos os usuários de um departamento
  async notifyDepartment(departmentId, message) {
    this.clients.forEach((client) => {
      if (client.user.departmentId === departmentId && client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(JSON.stringify(message));
      }
    });
  }

  // Envia mensagem de erro para um cliente
  sendError(ws, message) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'ERROR',
        data: { message }
      }));
    }
  }

  // Extrai token do request
  extractToken(req) {
    const auth = req.headers.authorization;
    if (!auth) return null;
    return auth.replace('Bearer ', '');
  }

  // Autentica o token
  async authenticateToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findByPk(decoded.id);
      return user;
    } catch (error) {
      return null;
    }
  }

  // Broadcast para todos os clientes conectados
  broadcast(message) {
    this.wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(message));
      }
    });
  }
}

module.exports = WebSocketService;

================
File: src/utils/logger.js
================
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');
const path = require('path');

const logDir = 'logs';
const { combine, timestamp, printf, colorize, errors } = winston.format;

const customFormat = printf(({ level, message, timestamp, ...metadata }) => {
  let msg = `${timestamp} [${level}] : ${message}`;
  
  if (Object.keys(metadata).length > 0) {
    msg += ` ${JSON.stringify(metadata)}`;
  }
  
  return msg;
});

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: combine(
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    errors({ stack: true }),
    customFormat
  ),
  transports: [
    // Logs de erro
    new DailyRotateFile({
      filename: path.join(logDir, 'error-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      level: 'error',
      maxSize: '20m',
      maxFiles: '14d',
      zippedArchive: true
    }),

    // Logs gerais
    new DailyRotateFile({
      filename: path.join(logDir, 'combined-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d',
      zippedArchive: true
    })
  ]
});

// Adiciona logs no console em desenvolvimento
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: combine(
      colorize(),
      customFormat
    )
  }));
}

module.exports = logger;

================
File: src/validations/schemas.js
================
const yup = require('yup');

const schemas = {
  loginSchema: yup.object().shape({
    email: yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    password: yup.string()
      .required('Senha é obrigatória')
  }),

  equipmentSchema: yup.object().shape({
    name: yup.string()
      .required('Nome é obrigatório')
      .min(3, 'Nome deve ter no mínimo 3 caracteres'),
    code: yup.string()
      .required('Código é obrigatório')
      .matches(/^[A-Za-z0-9-]+$/, 'Código deve conter apenas letras, números e hífen'),
    department: yup.string()
      .required('Departamento é obrigatório'),
    description: yup.string()
      .max(500, 'Descrição deve ter no máximo 500 caracteres'),
    maintenance_frequency: yup.number()
      .min(1, 'Frequência deve ser maior que 0')
  }),

  maintenanceSchema: yup.object().shape({
    equipment_id: yup.number()
      .required('Equipamento é obrigatório'),
    description: yup.string()
      .required('Descrição é obrigatória')
      .min(10, 'Descrição deve ter no mínimo 10 caracteres'),
    type: yup.string()
      .oneOf(['corrective', 'preventive', 'predictive'], 'Tipo inválido')
      .required('Tipo é obrigatório'),
    cost: yup.number()
      .min(0, 'Custo não pode ser negativo'),
    notes: yup.string()
      .max(1000, 'Observações devem ter no máximo 1000 caracteres')
  }),

  maintenanceUpdateSchema: yup.object().shape({
    status: yup.string()
      .oneOf(['pending', 'in_progress', 'completed', 'cancelled'], 'Status inválido')
      .required('Status é obrigatório'),
    completion_notes: yup.string()
      .when('status', {
        is: 'completed',
        then: yup.string().required('Notas de conclusão são obrigatórias')
      }),
    cost: yup.number()
      .min(0, 'Custo não pode ser negativo')
  })
};

module.exports = schemas;

================
File: src/views/emails/maintenance-complete.ejs
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      background-color: #f8f9fa;
      padding: 20px;
      text-align: center;
      border-bottom: 3px solid #007bff;
    }
    .content {
      padding: 20px;
    }
    .footer {
      text-align: center;
      padding: 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>Manutenção Concluída</h2>
    </div>
    <div class="content">
      <p>Olá <%= userName %>,</p>
      
      <p>A manutenção do equipamento foi concluída:</p>
      
      <ul>
        <li><strong>Equipamento:</strong> <%= equipmentName %></li>
        <li><strong>Código:</strong> <%= equipmentCode %></li>
        <li><strong>Data Conclusão:</strong> <%= completedDate.toLocaleDateString() %></li>
        <li><strong>Tipo:</strong> <%= maintenanceType %></li>
      </ul>

      <p><strong>Detalhes da Manutenção:</strong></p>
      <p><%= description %></p>
    </div>
    <div class="footer">
      <p>Esta é uma mensagem automática, não responda este email.</p>
    </div>
  </div>
</body>
</html>

================
File: src/views/emails/maintenance-notification.ejs
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      background-color: #f8f9fa;
      padding: 20px;
      text-align: center;
      border-bottom: 3px solid #007bff;
    }
    .content {
      padding: 20px;
    }
    .footer {
      text-align: center;
      padding: 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>Manutenção Agendada</h2>
    </div>
    <div class="content">
      <p>Olá <%= userName %>,</p>
      
      <p>Uma nova manutenção foi agendada para o equipamento:</p>
      
      <ul>
        <li><strong>Equipamento:</strong> <%= equipmentName %></li>
        <li><strong>Código:</strong> <%= equipmentCode %></li>
        <li><strong>Data Agendada:</strong> <%= maintenanceDate.toLocaleDateString() %></li>
        <li><strong>Tipo:</strong> <%= maintenanceType %></li>
      </ul>

      <p><strong>Descrição:</strong></p>
      <p><%= description %></p>
    </div>
    <div class="footer">
      <p>Esta é uma mensagem automática, não responda este email.</p>
    </div>
  </div>
</body>
</html>

================
File: src/websocket/webSocketMananger.js
================
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');
const logger = require('../utils/logger');

class WebSocketManager {
  constructor(server) {
    this.wss = new WebSocket.Server({ server });
    this.clients = new Map();
    this.rooms = new Map();
    
    this.initialize();
  }

  initialize() {
    this.wss.on('connection', async (ws, req) => {
      try {
        // Autenticação
        const token = this.extractToken(req);
        if (!token) {
          ws.close(4001, 'Token não fornecido');
          return;
        }

        const user = await this.verifyToken(token);
        if (!user) {
          ws.close(4001, 'Token inválido');
          return;
        }

        // Registra o cliente
        const clientId = user.id;
        this.clients.set(clientId, { ws, user });

        // Setup de heartbeat
        ws.isAlive = true;
        ws.on('pong', () => { ws.isAlive = true; });

        // Manipuladores de eventos
        ws.on('message', async (message) => {
          try {
            const data = JSON.parse(message);
            await this.handleMessage(clientId, data);
          } catch (error) {
            logger.error('Erro ao processar mensagem:', error);
            this.sendError(ws, error.message);
          }
        });

        ws.on('close', () => {
          this.handleDisconnect(clientId);
        });

        // Notifica conexão bem-sucedida
        this.sendToClient(clientId, {
          type: 'CONNECTED',
          data: { userId: clientId }
        });

      } catch (error) {
        logger.error('Erro na conexão WebSocket:', error);
        ws.close(4000, 'Erro interno');
      }
    });

    // Heartbeat interval
    setInterval(() => {
      this.wss.clients.forEach((ws) => {
        if (!ws.isAlive) return ws.terminate();
        ws.isAlive = false;
        ws.ping();
      });
    }, 30000);
  }

  async handleMessage(clientId, message) {
    const { type, data } = message;

    switch (type) {
      case 'JOIN_ROOM':
        await this.handleJoinRoom(clientId, data.roomId);
        break;

      case 'LEAVE_ROOM':
        await this.handleLeaveRoom(clientId, data.roomId);
        break;

      case 'EQUIPMENT_UPDATE':
        await this.handleEquipmentUpdate(clientId, data);
        break;

      case 'MAINTENANCE_STATUS':
        await this.handleMaintenanceStatus(clientId, data);
        break;

      default:
        logger.warn('Tipo de mensagem desconhecido:', type);
        break;
    }
  }

  async handleJoinRoom(clientId, roomId) {
    if (!this.rooms.has(roomId)) {
      this.rooms.set(roomId, new Set());
    }
    this.rooms.get(roomId).add(clientId);
  }

  async handleLeaveRoom(clientId, roomId) {
    if (this.rooms.has(roomId)) {
      this.rooms.get(roomId).delete(clientId);
    }
  }

  async handleEquipmentUpdate(clientId, data) {
    const { equipmentId, status, changes } = data;
    
    // Notifica todos na sala do equipamento
    this.broadcastToRoom(`equipment_${equipmentId}`, {
      type: 'EQUIPMENT_UPDATED',
      data: {
        equipmentId,
        status,
        changes,
        updatedBy: clientId,
        timestamp: new Date()
      }
    });
  }

  async handleMaintenanceStatus(clientId, data) {
    const { maintenanceId, status, notes } = data;

    // Notifica interessados sobre atualização da manutenção
    this.broadcastToRoom(`maintenance_${maintenanceId}`, {
      type: 'MAINTENANCE_UPDATED',
      data: {
        maintenanceId,
        status,
        notes,
        updatedBy: clientId,
        timestamp: new Date()
      }
    });
  }

  handleDisconnect(clientId) {
    // Remove cliente de todas as salas
    this.rooms.forEach((clients, roomId) => {
      clients.delete(clientId);
    });

    // Remove cliente da lista
    this.clients.delete(clientId);
  }

  sendToClient(clientId, message) {
    const client = this.clients.get(clientId);
    if (client && client.ws.readyState === WebSocket.OPEN) {
      client.ws.send(JSON.stringify(message));
    }
  }

  broadcastToRoom(roomId, message) {
    const clients = this.rooms.get(roomId);
    if (clients) {
      clients.forEach(clientId => {
        this.sendToClient(clientId, message);
      });
    }
  }

  broadcastToAll(message) {
    this.clients.forEach((client, clientId) => {
      this.sendToClient(clientId, message);
    });
  }

  sendError(ws, message) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'ERROR',
        data: { message }
      }));
    }
  }

  extractToken(req) {
    const auth = req.headers.authorization;
    return auth ? auth.replace('Bearer ', '') : null;
  }

  async verifyToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      return await User.findByPk(decoded.id);
    } catch (error) {
      return null;
    }
  }
}

module.exports = WebSocketManager;

================
File: src/app.js
================
require('dotenv').config();
require('express-async-errors');
const express = require('express');
const cors = require('cors');
const routes = require('./routes');
const errorHandler = require('./middlewares/errorHandler');
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./config/swagger');

const app = express();

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Documentação da API
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Rotas
app.use('/api', routes);

// Tratamento de erros
app.use(errorHandler);

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

module.exports = app;

================
File: src/index.js
================
require('dotenv').config();
const app = require('./app'); // Importa a aplicação configurada
const logger = require('./utils/logger');
const sequelize = require('../database'); 

const startServer = async () => {
  try {
    // Conecta ao banco de dados
    await sequelize.authenticate();
    logger.info('Conexão com banco de dados estabelecida.');

    const port = process.env.PORT || 3000;
    app.listen(port, () => {
      logger.info(`Servidor rodando na porta ${port}`);
      logger.info(`Ambiente: ${process.env.NODE_ENV}`);
    });

    // Graceful shutdown
    const shutdown = async () => {
      logger.info('Iniciando shutdown graceful...');
      
      // Fecha conexões
      await sequelize.close();
      logger.info('Conexões com banco fechadas');

      process.exit(0);
    };

    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);

  } catch (error) {
    logger.error('Erro fatal ao iniciar aplicação:', error);
    process.exit(1);
  }
};

startServer();

================
File: .sequelizerc
================
const path = require('path');

module.exports = {
  config: path.resolve('src', 'config', 'database.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'database', 'seeders'),
  'migrations-path': path.resolve('src', 'database', 'migrations'),
};

================
File: package.json
================
{
  "name": "equipment-management-backend",
  "version": "1.0.0",
  "description": "Sistema de Gerenciamento de Equipamentos - Backend",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "migrate": "sequelize db:migrate",
    "migrate:undo": "sequelize db:migrate:undo:all",
    "seed": "sequelize db:seed:all",
    "test": "jest"
  },
  "dependencies": {
    "@sendgrid/mail": "^7.7.0",
    "aws-sdk": "^2.1338.0",
    "bcryptjs": "^2.4.3",
    "bull": "^4.10.4",
    "cors": "^2.8.5",
    "date-fns": "^2.30.0",
    "dotenv": "^16.0.3",
    "ejs": "^3.1.9",
    "express": "^4.18.2",
    "express-async-errors": "^3.1.1",
    "express-rate-limit": "^6.7.0",
    "express-validator": "^7.0.1",
    "helmet": "^6.0.1",
    "hpp": "^0.2.3",
    "ioredis": "^5.3.1",
    "jsonwebtoken": "^9.0.0",
    "multer": "^1.4.5-lts.1",
    "node-cron": "^3.0.3",
    "nodemailer": "^6.9.7",
    "pg": "^8.10.0",
    "pg-hstore": "^2.3.4",
    "qrcode": "^1.5.1",
    "sequelize": "^6.30.0",
    "sharp": "^0.32.0",
    "socket.io": "^4.6.1",
    "winston": "^3.8.2",
    "winston-daily-rotate-file": "^4.7.1",
    "yup": "^1.0.2",
    "express-mongo-sanitize": "^2.2.0",
    "exceljs": "^4.4.0",
    "pdfkit": "^0.14.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "eslint": "^8.36.0",
    "jest": "^29.5.0",
    "nodemon": "^2.0.22",
    "sequelize-cli": "^6.6.0",
    "supertest": "^6.3.3"
  }
}

================
File: tree.js
================
const fs = require('fs');
const path = require('path');

// Função recursiva para gerar o mapa de pastas/arquivos
function generateFileStructure(dir, depth = 0) {
    let structure = '';
    const files = fs.readdirSync(dir);

    files.forEach((file) => {
        const filePath = path.join(dir, file);
        const isDirectory = fs.statSync(filePath).isDirectory();

        structure += `${'  '.repeat(depth)}- ${file}\n`;

        if (isDirectory) {
            structure += generateFileStructure(filePath, depth + 1);
        }
    });

    return structure;
}

// Caminhos do backend e frontend
const backendDir = path.join(__dirname, '/src');
const frontendDir = path.join(__dirname, '../frontend/src');
const mobileDir = path.join(__dirname, "../mobile");

// Gerar mapas de ambos os diretórios
let output = 'Estrutura de Arquivos do Projeto\n\n';
output += 'Backend:\n';
output += generateFileStructure(backendDir);
output += '\nFrontend:\n';
output += generateFileStructure(frontendDir);
output += '\nMobile:\n';
output += generateFileStructure(mobileDir);

// Exibir no console
console.log(output);

// Opcional: salvar em um arquivo
const outputPath = path.join(__dirname, 'estrutura_projeto.txt');
fs.writeFileSync(outputPath, output);
console.log(`Estrutura salva em: ${outputPath}`);

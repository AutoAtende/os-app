This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-03T10:36:02.963Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/
  config/
    database.js
    multer.js
    redis.js
  controllers/
    AuthController.js
    DashboardController.js
    EquipmentController.js
    MaintenanceController.js
    NotificationController.js
    ReportController.js
    ServiceOrderController.js
    UserController.js
  database/
    migrations/
      01-create-users.js
      02-create-equipment.js
      03-create-service-orders.js
      04-create-files.js
      05-create-maintenance-history.js
      06-create-notifications.js
      07-create-reports.js
    seeders/
      20250203021507-admin-user.js
    index.js
  jobs/
    processors/
      equipmentProcessor.js
      fileProcessor.js
      index.js
      notificationProcessor.js
      reportProcessor.js
    JobProcessor.js
  middlewares/
    auth.js
    errorHandler.js
    security.js
    validate.js
  models/
    Equipment.js
    File.js
    index.js
    MaintenanceHistory.js
    Notification.js
    Report.js
    ServiceOrder.js
    User.js
  routes/
    index.js
  services/
    AuditService.js
    CacheService.js
    EmailService.js
    ExcelService.js
    FileService.js
    MediaService.js
    NotificationService.js
    PDFService.js
    PushNotificationService.js
    QRCodeService.js
    ReportService.js
    S3Service.js
    WebSocketService.js
  utils/
    auth.js
    logger.js
  validations/
    schemas.js
  views/
    emails/
      maintenance-complete.ejs
      maintenance-notification.ejs
  websocket/
    WebSocketManager.js
  app.js
  index.js
.sequelizerc
package.json
tree.js

================================================================
Files
================================================================

================
File: src/config/database.js
================
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: 'postgres',
    logging: console.log,
    define: {
      timestamps: true,
      underscored: true,
      underscoredAll: true
    },
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000
    }
  },
  test: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: 'postgres',
    logging: false,
    define: {
      timestamps: true,
      underscored: true,
      underscoredAll: true
    }
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    dialect: 'postgres',
    logging: false,
    define: {
      timestamps: true,
      underscored: true,
      underscoredAll: true
    },
    pool: {
      max: 10,
      min: 2,
      acquire: 30000,
      idle: 10000
    }
  }
};

================
File: src/config/multer.js
================
const multer = require('multer');
const path = require('path');
const crypto = require('crypto');

module.exports = {
  storage: multer.diskStorage({
    destination: path.resolve(__dirname, '..', '..', 'tmp', 'uploads'),
    filename: (req, file, cb) => {
      crypto.randomBytes(16, (err, hash) => {
        if (err) cb(err);
        const fileName = `${hash.toString('hex')}-${file.originalname}`;
        cb(null, fileName);
      });
    },
  }),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = [
      'image/jpeg',
      'image/pjpeg',
      'image/png',
      'application/pdf',
    ];

    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Tipo de arquivo inválido.'));
    }
  },
};

================
File: src/config/redis.js
================
const Redis = require('ioredis');
const logger = require('../utils/logger');

const redisConfig = {
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: 3,
  retryStrategy(times) {
    if (times > 3) {
      return null; // Desiste após 3 tentativas
    }
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
  lazyConnect: true // Não tenta conectar automaticamente
};

let redisClient = null;

const getRedisClient = async () => {
  if (!redisClient) {
    try {
      redisClient = new Redis(redisConfig);
      
      // Tenta conectar
      await redisClient.connect();
      
      redisClient.on('error', (error) => {
        logger.warn('Erro na conexão com Redis:', error);
      });

      redisClient.on('connect', () => {
        logger.info('Conectado ao Redis');
      });
    } catch (error) {
      logger.warn('Redis não disponível, sistema funcionará sem cache:', error.message);
      return null;
    }
  }
  return redisClient;
};

// Função para verificar se o Redis está disponível
const isRedisAvailable = async () => {
  const client = await getRedisClient();
  return client !== null;
};

module.exports = {
  getRedisClient,
  isRedisAvailable,
  redisConfig
};

================
File: src/controllers/AuthController.js
================
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { User } = require('../models/User');
const { Op } = require('sequelize');
const EmailService = require('../services/emailService');
const logger = require('../utils/logger');

class AuthController {
  async login(req, res) {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({
        where: { 
          email,
          active: true
        }
      });

      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      if (!(await bcrypt.compare(password, user.password_hash))) {
        return res.status(401).json({ error: 'Senha incorreta' });
      }

      const token = jwt.sign(
        { id: user.id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      );

      // Remove senha do retorno
      const { password_hash, ...userData } = user.toJSON();

      return res.json({
        user: userData,
        token
      });

    } catch (error) {
      logger.error('Erro no login:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async forgotPassword(req, res) {
    try {
      const { email } = req.body;

      const user = await User.findOne({ where: { email } });

      if (!user) {
        return res.status(404).json({ error: 'Usuário não encontrado' });
      }

      // Gera token de reset
      const resetToken = crypto.randomBytes(20).toString('hex');
      const resetTokenExpires = new Date();
      resetTokenExpires.setHours(resetTokenExpires.getHours() + 1); // Token válido por 1 hora

      await user.update({
        password_reset_token: resetToken,
        password_reset_expires: resetTokenExpires
      });

      // Envia email
      await EmailService.sendPasswordReset({
        name: user.name,
        email: user.email,
        token: resetToken,
        resetUrl: `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`
      });

      return res.json({ message: 'Email de recuperação enviado com sucesso' });

    } catch (error) {
      logger.error('Erro no forgot password:', error);
      return res.status(500).json({ error: 'Erro ao recuperar senha' });
    }
  }

  async resetPassword(req, res) {
    try {
      const { email, token, password } = req.body;

      const user = await User.findOne({
        where: {
          email,
          password_reset_token: token,
          password_reset_expires: {
            [Op.gt]: new Date()
          }
        }
      });

      if (!user) {
        return res.status(400).json({ error: 'Token inválido ou expirado' });
      }

      // Atualiza senha
      const password_hash = await bcrypt.hash(password, 8);

      await user.update({
        password_hash,
        password_reset_token: null,
        password_reset_expires: null
      });

      // Envia email de confirmação
      await EmailService.sendPasswordResetConfirmation({
        name: user.name,
        email: user.email
      });

      return res.json({ message: 'Senha alterada com sucesso' });

    } catch (error) {
      logger.error('Erro no reset password:', error);
      return res.status(500).json({ error: 'Erro ao resetar senha' });
    }
  }

  async refreshToken(req, res) {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        return res.status(401).json({ error: 'Refresh token não fornecido' });
      }

      // Verifica refresh token
      const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);

      const user = await User.findByPk(decoded.id);
      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      // Gera novo token
      const token = jwt.sign(
        { id: user.id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      );

      // Gera novo refresh token
      const newRefreshToken = jwt.sign(
        { id: user.id },
        process.env.REFRESH_TOKEN_SECRET,
        { expiresIn: '30d' }
      );

      return res.json({
        token,
        refreshToken: newRefreshToken
      });

    } catch (error) {
      logger.error('Erro no refresh token:', error);
      return res.status(401).json({ error: 'Refresh token inválido' });
    }
  }

  async validateToken(req, res) {
    try {
      const { token } = req.body;

      if (!token) {
        return res.status(401).json({ error: 'Token não fornecido' });
      }

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findByPk(decoded.id);

      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      return res.json({ valid: true });

    } catch (error) {
      return res.json({ valid: false });
    }
  }

  async changePassword(req, res) {
    try {
      const { currentPassword, newPassword } = req.body;
      const user = await User.findByPk(req.userId);

      if (!(await bcrypt.compare(currentPassword, user.password_hash))) {
        return res.status(401).json({ error: 'Senha atual incorreta' });
      }

      const password_hash = await bcrypt.hash(newPassword, 8);
      await user.update({ password_hash });

      // Envia email de notificação
      await EmailService.sendPasswordChangeNotification({
        name: user.name,
        email: user.email
      });

      return res.json({ message: 'Senha alterada com sucesso' });

    } catch (error) {
      logger.error('Erro na mudança de senha:', error);
      return res.status(500).json({ error: 'Erro ao alterar senha' });
    }
  }

  async logout(req, res) {
    try {
      // Aqui você pode implementar lógica adicional de logout
      // como invalidar refresh tokens, etc.
      
      return res.json({ message: 'Logout realizado com sucesso' });
    } catch (error) {
      logger.error('Erro no logout:', error);
      return res.status(500).json({ error: 'Erro ao realizar logout' });
    }
  }
}

module.exports = new AuthController();

================
File: src/controllers/DashboardController.js
================
const {Equipment} = require('../models/Equipment');
const {MaintenanceHistory} = require('../models/MaintenanceHistory')
const {User} = require('../models/User');
const { Op, Sequelize } = require('sequelize');
const CacheService = require('../services/CacheService');
const logger = require('../utils/logger');

class DashboardController {
  async getStats(req, res) {
    try {
      const { period = 'month' } = req.query;
      
      // Tenta buscar do cache
      const cacheKey = `dashboard:${period}:${req.userId}`;
      const cachedData = await CacheService.get(cacheKey);
      
      if (cachedData) {
        return res.json(cachedData);
      }

      // Calcula datas
      const endDate = new Date();
      const startDate = this.getStartDate(period);

      // Busca dados
      const [
        equipmentStats,
        maintenanceStats,
        performanceMetrics,
        upcomingMaintenances
      ] = await Promise.all([
        this.getEquipmentStats(),
        this.getMaintenanceStats(startDate, endDate),
        this.getPerformanceMetrics(startDate, endDate),
        this.getUpcomingMaintenances()
      ]);

      const dashboardData = {
        equipmentStats,
        maintenanceStats,
        performanceMetrics,
        upcomingMaintenances,
        lastUpdate: new Date()
      };

      // Salva no cache por 5 minutos
      await CacheService.set(cacheKey, dashboardData, 300);

      return res.json(dashboardData);

    } catch (error) {
      logger.error('Erro ao buscar estatísticas do dashboard:', error);
      return res.status(500).json({ error: 'Erro ao buscar estatísticas' });
    }
  }

  async getEquipmentStats() {
    const totalEquipments = await Equipment.count();
    const activeEquipments = await Equipment.count({ where: { status: 'active' } });
    const maintenanceEquipments = await Equipment.count({ where: { status: 'maintenance' } });
    
    return {
      total: totalEquipments,
      active: activeEquipments,
      inMaintenance: maintenanceEquipments,
      inactive: totalEquipments - activeEquipments - maintenanceEquipments
    };
  }

  async getMaintenanceStats(startDate, endDate) {
    const maintenances = await MaintenanceHistory.findAll({
      where: {
        created_at: {
          [Op.between]: [startDate, endDate]
        }
      },
      attributes: [
        'type',
        'status',
        [Sequelize.fn('COUNT', '*'), 'count'],
        [Sequelize.fn('SUM', Sequelize.col('cost')), 'totalCost']
      ],
      group: ['type', 'status']
    });

    const byType = {};
    const byStatus = {};

    maintenances.forEach(m => {
      byType[m.type] = (byType[m.type] || 0) + m.get('count');
      byStatus[m.status] = (byStatus[m.status] || 0) + m.get('count');
    });

    return {
      byType,
      byStatus,
      totalCost: maintenances.reduce((sum, m) => sum + (m.get('totalCost') || 0), 0)
    };
  }

  async getPerformanceMetrics(startDate, endDate) {
    const completedMaintenances = await MaintenanceHistory.findAll({
      where: {
        status: 'completed',
        completion_date: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ]
    });

    // Calcula métricas
    const totalTime = completedMaintenances.reduce((sum, m) => {
      const duration = new Date(m.completion_date) - new Date(m.created_at);
      return sum + duration;
    }, 0);

    const avgTime = completedMaintenances.length > 0 
      ? totalTime / completedMaintenances.length
      : 0;

    return {
      avgResolutionTime: Math.round(avgTime / (1000 * 60 * 60)), // em horas
      completionRate: await this.calculateCompletionRate(startDate, endDate),
      technicianPerformance: await this.calculateTechnicianPerformance(startDate, endDate)
    };
  }

  async getUpcomingMaintenances() {
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);

    return await MaintenanceHistory.findAll({
      where: {
        status: 'pending',
        scheduled_date: {
          [Op.lte]: nextWeek
        }
      },
      include: [
        {
          model: Equipment,
          attributes: ['id', 'name', 'code']
        },
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ],
      order: [['scheduled_date', 'ASC']],
      limit: 5
    });
  }

  async calculateCompletionRate(startDate, endDate) {
    const [completed, total] = await Promise.all([
      MaintenanceHistory.count({
        where: {
          status: 'completed',
          completion_date: {
            [Op.between]: [startDate, endDate]
          }
        }
      }),
      MaintenanceHistory.count({
        where: {
          created_at: {
            [Op.between]: [startDate, endDate]
          }
        }
      })
    ]);

    return total > 0 ? Math.round((completed / total) * 100) : 0;
  }

  async calculateTechnicianPerformance(startDate, endDate) {
    const performances = await MaintenanceHistory.findAll({
      attributes: [
        [Sequelize.fn('COUNT', '*'), 'total'],
        [Sequelize.fn('AVG', 
          Sequelize.literal('EXTRACT(EPOCH FROM (completion_date - created_at))/3600')
        ), 'avgTime']
      ],
      where: {
        status: 'completed',
        completion_date: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ],
      group: ['technician.id', 'technician.name']
    });

    return performances.map(p => ({
      technician: p.technician,
      completedMaintenances: p.get('total'),
      averageResolutionTime: Math.round(p.get('avgTime'))
    }));
  }

  getStartDate(period) {
    const date = new Date();
    switch (period) {
      case 'week':
        date.setDate(date.getDate() - 7);
        break;
      case 'month':
        date.setMonth(date.getMonth() - 1);
        break;
      case 'year':
        date.setFullYear(date.getFullYear() - 1);
        break;
      default:
        date.setMonth(date.getMonth() - 1); // Padrão: último mês
    }
    return date;
  }
}

module.exports = new DashboardController();

================
File: src/controllers/EquipmentController.js
================
const { Equipment, MaintenanceHistory, User, ServiceOrder } = require('../models');
const { Op } = require('sequelize');
const QRCode = require('qrcode');

class EquipmentController {
  async store(req, res) {
    try {
      const equipment = await Equipment.create(req.body);

      // Gera QR Code
      const qrcodeData = `${process.env.APP_URL}/equipment/${equipment.id}`;
      const qrcodeUrl = await QRCode.toDataURL(qrcodeData);
      
      await equipment.update({ qrcode_url: qrcodeUrl });

      return res.status(201).json(equipment);
    } catch (error) {
      console.error(error);
      return res.status(500).json({ error: 'Erro ao criar equipamento' });
    }
  }

  async index(req, res) {
    try {
      const { department, status, search } = req.query;
      const where = {};

      if (department) where.department = department;
      if (status) where.status = status;
      if (search) {
        where[Op.or] = [
          { name: { [Op.iLike]: `%${search}%` } },
          { code: { [Op.iLike]: `%${search}%` } },
          { serial_number: { [Op.iLike]: `%${search}%` } },
        ];
      }

      const equipment = await Equipment.findAll({
        where,
        include: [
          {
            model: MaintenanceHistory,
            as: 'maintenance_history',
            limit: 1,
            order: [['maintenance_date', 'DESC']],
          },
        ],
        order: [['created_at', 'DESC']],
      });

      return res.json(equipment);
    } catch (error) {
      console.error(error);
      return res.status(500).json({ error: 'Erro ao listar equipamentos' });
    }
  }

  async show(req, res) {
    const equipment = await Equipment.findByPk(req.params.id, {
      include: [
        {
          model: MaintenanceHistory,
          as: 'maintenance_history',
          include: [
            {
              model: User,
              as: 'technician',
              attributes: ['id', 'name'],
            },
          ],
        },
        {
          model: ServiceOrder,
          as: 'service_orders',
          include: [
            {
              model: User,
              as: 'creator',
              attributes: ['id', 'name'],
            },
          ],
        },
      ],
    });

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    return res.json(equipment);
  }

  async update(req, res) {
    const equipment = await Equipment.findByPk(req.params.id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    await equipment.update(req.body);

    return res.json(equipment);
  }

  async destroy(req, res) {
    const equipment = await Equipment.findByPk(req.params.id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    await equipment.destroy();

    return res.status(204).send();
  }
}

module.exports = new EquipmentController();

================
File: src/controllers/MaintenanceController.js
================
const {Equipment} = require('../models/Equipment');
const {MaintenanceHistory} = require('../models/MaintenanceHistory')
const {User} = require('../models/User');
const NotificationService = require('../services/NotificationService');
const S3Service = require('../services/S3Service');
const { maintenanceHistorySchema } = require('../validations/schemas');
const logger = require('../utils/logger');

class MaintenanceController {
  async store(req, res) {
    try {
      const {
        equipment_id,
        description,
        type,
        notes,
        cost
      } = req.body;

      // Valida equipamento
      const equipment = await Equipment.findByPk(equipment_id);
      if (!equipment) {
        return res.status(404).json({ error: 'Equipamento não encontrado' });
      }

      // Processa fotos
      let photoUrls = [];
      if (req.files?.photos) {
        const uploadPromises = req.files.photos.map(photo => 
          S3Service.uploadFile(photo, 'maintenance-photos')
        );
        photoUrls = await Promise.all(uploadPromises);
      }

      // Processa documentos
      let documentUrls = [];
      if (req.files?.documents) {
        const uploadPromises = req.files.documents.map(doc => 
          S3Service.uploadFile(doc, 'maintenance-documents')
        );
        documentUrls = await Promise.all(uploadPromises);
      }

      // Cria registro de manutenção
      const maintenance = await MaintenanceHistory.create({
        equipment_id,
        description,
        type,
        status: 'pending',
        notes,
        cost: cost || 0,
        photos: photoUrls,
        documents: documentUrls,
        created_by: req.userId
      });

      // Atualiza status do equipamento
      await equipment.update({ 
        status: 'maintenance',
        last_maintenance: new Date()
      });

      // Notifica responsáveis
      await NotificationService.notifyMaintenanceCreated(maintenance);

      return res.status(201).json(maintenance);

    } catch (error) {
      logger.error('Erro ao criar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao registrar manutenção' });
    }
  }

  async index(req, res) {
    try {
      const { 
        status,
        equipment_id,
        start_date,
        end_date,
        type
      } = req.query;

      const where = {};

      if (status) where.status = status;
      if (equipment_id) where.equipment_id = equipment_id;
      if (type) where.type = type;
      
      if (start_date && end_date) {
        where.created_at = {
          [Op.between]: [start_date, end_date]
        };
      }

      // Se não for admin, filtra por departamento
      if (req.userRole !== 'admin') {
        const user = await User.findByPk(req.userId);
        where['$Equipment.department$'] = user.department;
      }

      const maintenances = await MaintenanceHistory.findAll({
        where,
        include: [
          {
            model: Equipment,
            attributes: ['id', 'name', 'code', 'department']
          },
          {
            model: User,
            as: 'technician',
            attributes: ['id', 'name']
          }
        ],
        order: [['created_at', 'DESC']]
      });

      return res.json(maintenances);

    } catch (error) {
      logger.error('Erro ao listar manutenções:', error);
      return res.status(500).json({ error: 'Erro ao listar manutenções' });
    }
  }

  async update(req, res) {
    try {
      const { id } = req.params;
      const {
        status,
        notes,
        cost,
        completion_notes
      } = req.body;

      const maintenance = await MaintenanceHistory.findByPk(id, {
        include: [{ model: Equipment }]
      });

      if (!maintenance) {
        return res.status(404).json({ error: 'Manutenção não encontrada' });
      }

      // Se estiver completando a manutenção
      if (status === 'completed' && maintenance.status !== 'completed') {
        // Atualiza status do equipamento
        await maintenance.Equipment.update({ status: 'active' });
        
        // Notifica sobre conclusão
        await NotificationService.notifyMaintenanceCompleted(maintenance);
      }

      await maintenance.update({
        status,
        notes,
        cost,
        completion_notes,
        completed_at: status === 'completed' ? new Date() : null,
        completed_by: status === 'completed' ? req.userId : null
      });

      return res.json(maintenance);

    } catch (error) {
      logger.error('Erro ao atualizar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao atualizar manutenção' });
    }
  }

  async show(req, res) {
    try {
      const { id } = req.params;

      const maintenance = await MaintenanceHistory.findByPk(id, {
        include: [
          {
            model: Equipment,
            attributes: ['id', 'name', 'code', 'department']
          },
          {
            model: User,
            as: 'technician',
            attributes: ['id', 'name']
          },
          {
            model: User,
            as: 'creator',
            attributes: ['id', 'name']
          }
        ]
      });

      if (!maintenance) {
        return res.status(404).json({ error: 'Manutenção não encontrada' });
      }

      return res.json(maintenance);

    } catch (error) {
      logger.error('Erro ao buscar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao buscar manutenção' });
    }
  }
}

module.exports = new MaintenanceController();

================
File: src/controllers/NotificationController.js
================
const {Equipment} = require('../models/Equipment');
const {MaintenanceHistory} = require('../models/MaintenanceHistory')
const {User} = require('../models/User');
const {Notification} = require('../models/Notification');
const NotificationService = require('../services/NotificationService');
const WebSocketManager = require('../websocket/WebSocketManager');
const JobProcessor = require('../jobs/JobProcessor');
const logger = require('../utils/logger');

class NotificationController {
  async store(req, res) {
    try {
      const {
        type,
        title,
        message,
        recipient_id,
        reference_type,
        reference_id,
        priority = 'normal'
      } = req.body;

      // Cria notificação
      const notification = await Notification.create({
        type,
        title,
        message,
        recipient_id,
        reference_type,
        reference_id,
        priority,
        sender_id: req.userId
      });

      // Envia notificação em tempo real
      await NotificationService.send({
        notification,
        recipient_id
      });

      return res.status(201).json(notification);
    } catch (error) {
      logger.error('Erro ao criar notificação:', error);
      return res.status(500).json({ error: 'Erro ao criar notificação' });
    }
  }

  async list(req, res) {
    try {
      const { 
        page = 1, 
        limit = 20, 
        read, 
        type,
        priority 
      } = req.query;

      const where = { recipient_id: req.userId };
      if (read !== undefined) where.read = read === 'true';
      if (type) where.type = type;
      if (priority) where.priority = priority;

      const notifications = await Notification.findAndCountAll({
        where,
        include: [
          {
            model: User,
            as: 'sender',
            attributes: ['id', 'name']
          }
        ],
        order: [['created_at', 'DESC']],
        limit: parseInt(limit),
        offset: (page - 1) * limit
      });

      return res.json({
        items: notifications.rows,
        total: notifications.count,
        unread: await this.getUnreadCount(req.userId)
      });
    } catch (error) {
        logger.error('Erro ao listar notificações:', error);
        return res.status(500).json({ error: 'Erro ao listar notificações' });
      }
    }
  
    async markAsRead(req, res) {
      try {
        const { id } = req.params;
        const notification = await Notification.findOne({
          where: { 
            id,
            recipient_id: req.userId
          }
        });
  
        if (!notification) {
          return res.status(404).json({ error: 'Notificação não encontrada' });
        }
  
        await notification.update({ read: true });
  
        // Atualiza contadores em tempo real
        WebSocketManager.sendToClient(req.userId, {
          type: 'NOTIFICATION_READ',
          data: {
            notificationId: id,
            unreadCount: await this.getUnreadCount(req.userId)
          }
        });
  
        return res.json(notification);
      } catch (error) {
        logger.error('Erro ao marcar notificação como lida:', error);
        return res.status(500).json({ error: 'Erro ao atualizar notificação' });
      }
    }
  
    async markAllAsRead(req, res) {
      try {
        await Notification.update(
          { read: true },
          { 
            where: { 
              recipient_id: req.userId,
              read: false
            }
          }
        );
  
        // Atualiza contadores em tempo real
        WebSocketManager.sendToClient(req.userId, {
          type: 'ALL_NOTIFICATIONS_READ',
          data: { unreadCount: 0 }
        });
  
        return res.status(204).send();
      } catch (error) {
        logger.error('Erro ao marcar todas notificações como lidas:', error);
        return res.status(500).json({ error: 'Erro ao atualizar notificações' });
      }
    }
  
    async delete(req, res) {
      try {
        const { id } = req.params;
        const notification = await Notification.findOne({
          where: { 
            id,
            recipient_id: req.userId
          }
        });
  
        if (!notification) {
          return res.status(404).json({ error: 'Notificação não encontrada' });
        }
  
        await notification.destroy();
        return res.status(204).send();
      } catch (error) {
        logger.error('Erro ao deletar notificação:', error);
        return res.status(500).json({ error: 'Erro ao deletar notificação' });
      }
    }
  
    async getUnreadCount(userId) {
      return await Notification.count({
        where: {
          recipient_id: userId,
          read: false
        }
      });
    }
  
    async getUserPreferences(req, res) {
      try {
        const preferences = await NotificationPreference.findOne({
          where: { user_id: req.userId }
        });
  
        return res.json(preferences || {
          email: true,
          push: true,
          in_app: true,
          maintenance_reminders: true,
          equipment_alerts: true
        });
      } catch (error) {
        logger.error('Erro ao buscar preferências:', error);
        return res.status(500).json({ error: 'Erro ao buscar preferências' });
      }
    }
  
    async updateUserPreferences(req, res) {
      try {
        const {
          email,
          push,
          in_app,
          maintenance_reminders,
          equipment_alerts
        } = req.body;
  
        const [preferences] = await NotificationPreference.upsert({
          user_id: req.userId,
          email,
          push,
          in_app,
          maintenance_reminders,
          equipment_alerts
        });
  
        return res.json(preferences);
      } catch (error) {
        logger.error('Erro ao atualizar preferências:', error);
        return res.status(500).json({ error: 'Erro ao atualizar preferências' });
      }
    }
  
    // Métodos para envio de notificações específicas
    async notifyMaintenanceDue(equipment) {
      try {
        const users = await User.findAll({
          where: {
            [Op.or]: [
              { role: 'admin' },
              { role: 'technician', department: equipment.department }
            ]
          }
        });
  
        const notifications = users.map(user => ({
          type: 'MAINTENANCE_DUE',
          title: 'Manutenção Preventiva Necessária',
          message: `O equipamento ${equipment.name} (${equipment.code}) precisa de manutenção preventiva.`,
          recipient_id: user.id,
          reference_type: 'equipment',
          reference_id: equipment.id,
          priority: 'high'
        }));
  
        await Notification.bulkCreate(notifications);
  
        // Notifica em tempo real
        users.forEach(user => {
          WebSocketManager.sendToClient(user.id, {
            type: 'MAINTENANCE_DUE',
            data: { equipment }
          });
        });
  
        // Agenda envio de emails
        await JobProcessor.addNotificationJob('send_maintenance_due_emails', {
          equipment,
          users
        });
  
      } catch (error) {
        logger.error('Erro ao notificar manutenção necessária:', error);
      }
    }
  }
  
  module.exports = new NotificationController();

================
File: src/controllers/ReportController.js
================
const PDFService = require('../services/PDFService');
const ExcelService = require('../services/ExcelService');
const JobProcessor = require('../jobs/JobProcessor');
const CacheService = require('../services/CacheService');
const logger = require('../utils/logger');
const { Equipment, MaintenanceHistory, User } = require('../models');
const { Op } = require('sequelize');

class ReportController {
  async generate(req, res) {
    try {
      const {
        type,
        format = 'pdf',
        start_date,
        end_date,
        department,
        equipment_id
      } = req.query;

      if (!type) {
        return res.status(400).json({ error: 'Tipo de relatório é obrigatório' });
      }

      // Gera chave de cache
      const cacheKey = `report:${type}:${format}:${start_date}:${end_date}:${department}:${equipment_id}`;
      
      // Verifica cache
      const cachedReport = await CacheService.get(cacheKey);
      if (cachedReport) {
        return res.json(cachedReport);
      }

      // Define filtros base
      const where = {};
      if (start_date && end_date) {
        where.created_at = { [Op.between]: [start_date, end_date] };
      }
      if (department) {
        where.department = department;
      }
      if (equipment_id) {
        where.equipment_id = equipment_id;
      }

      let data;
      let buffer;

      // Busca dados baseado no tipo de relatório
      switch (type) {
        case 'maintenance':
          data = await MaintenanceHistory.findAll({
            where,
            include: [
              { model: Equipment, as: 'equipment' },
              { model: User, as: 'technician', attributes: ['name'] }
            ],
            order: [['created_at', 'DESC']]
          });
          buffer = format === 'pdf' ? 
            await PDFService.createMaintenanceReport(data) :
            await ExcelService.generateMaintenanceReport(data);
          break;

        case 'equipment':
          data = await Equipment.findAll({
            where,
            include: [{ model: MaintenanceHistory, as: 'maintenance_history' }],
            order: [['name', 'ASC']]
          });
          buffer = format === 'pdf' ? 
            await PDFService.createEquipmentReport(data) :
            await ExcelService.generateEquipmentReport(data);
          break;

        default:
          return res.status(400).json({ error: 'Tipo de relatório inválido' });
      }

      // Define headers baseado no formato
      res.setHeader('Content-Disposition', `attachment; filename=report-${type}.${format}`);
      if (format === 'pdf') {
        res.setHeader('Content-Type', 'application/pdf');
      } else {
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
      }

      return res.send(buffer);

    } catch (error) {
      logger.error('Erro ao gerar relatório:', error);
      return res.status(500).json({ error: 'Erro ao gerar relatório' });
    }
  }

  async getStatus(req, res) {
    try {
      const { jobId } = req.params;
      const status = await JobProcessor.getJobStatus(jobId);

      if (!status) {
        return res.status(404).json({ error: 'Job não encontrado' });
      }

      return res.json(status);
    } catch (error) {
      logger.error('Erro ao buscar status do relatório:', error);
      return res.status(500).json({ error: 'Erro ao buscar status' });
    }
  }

  async download(req, res) {
    try {
      const { reportId } = req.params;
      const { format = 'pdf' } = req.query;

      const report = await Report.findByPk(reportId);
      if (!report) {
        return res.status(404).json({ error: 'Relatório não encontrado' });
      }

      // Define headers baseado no formato
      if (format === 'pdf') {
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename=report-${reportId}.pdf`);
      } else {
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=report-${reportId}.xlsx`);
      }

      const fileStream = await report.getFileStream();
      fileStream.pipe(res);

    } catch (error) {
      logger.error('Erro ao baixar relatório:', error);
      return res.status(500).json({ error: 'Erro ao baixar relatório' });
    }
  }

  async list(req, res) {
    try {
      const { page = 1, limit = 10, type } = req.query;

      const where = {};
      if (type) where.type = type;

      const reports = await Report.findAndCountAll({
        where,
        order: [['created_at', 'DESC']],
        limit: parseInt(limit),
        offset: (page - 1) * limit
      });

      return res.json({
        items: reports.rows,
        total: reports.count,
        page: parseInt(page),
        pages: Math.ceil(reports.count / limit)
      });

    } catch (error) {
      logger.error('Erro ao listar relatórios:', error);
      return res.status(500).json({ error: 'Erro ao listar relatórios' });
    }
  }

  async delete(req, res) {
    try {
      const report = await Report.findByPk(req.params.id);
      if (!report) {
        return res.status(404).json({ error: 'Relatório não encontrado' });
      }

      await report.deleteFile(); // Remove arquivo do S3
      await report.destroy();

      return res.status(204).send();
    } catch (error) {
      logger.error('Erro ao deletar relatório:', error);
      return res.status(500).json({ error: 'Erro ao deletar relatório' });
    }
  }
}

module.exports = new ReportController();

================
File: src/controllers/ServiceOrderController.js
================
const {ServiceOrder} = require('../models/ServiceOrder');
const {File} = require('../models/File');
const {Equipment} = require('../models/Equipment');
const {MaintenanceHistory} = require('../models/MaintenanceHistory')
const {User} = require('../models/User');

const S3Service = require('../services/S3Service');

class ServiceOrderController {
  async store(req, res) {
    const {
      equipment_id,
      description,
      type,
      priority,
      scheduled_for,
    } = req.body;

    const equipment = await Equipment.findByPk(equipment_id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    const serviceOrder = await ServiceOrder.create({
      equipment_id,
      description,
      type,
      priority,
      scheduled_for,
      created_by: req.userId,
    });

    if (req.files) {
      const filesPromises = req.files.map(file => 
        S3Service.uploadToS3(file).then(url => 
          File.create({
            name: file.originalname,
            path: url,
            service_order_id: serviceOrder.id,
          })
        )
      );

      await Promise.all(filesPromises);
    }

    return res.status(201).json(serviceOrder);
  }

  async index(req, res) {
    const { status, equipment_id, date_start, date_end } = req.query;
    const where = {};

    if (status) where.status = status;
    if (equipment_id) where.equipment_id = equipment_id;
    if (date_start && date_end) {
      where.scheduled_for = {
        [Op.between]: [date_start, date_end],
      };
    }

    const serviceOrders = await ServiceOrder.findAll({
      where,
      include: [
        {
          model: Equipment,
          as: 'equipment',
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name'],
        },
        {
          model: File,
          as: 'files',
        },
      ],
      order: [['scheduled_for', 'ASC']],
    });

    return res.json(serviceOrders);
  }

  async show(req, res) {
    try {
      const serviceOrder = await ServiceOrder.findByPk(req.params.id, {
        include: [
          {
            model: Equipment,
            as: 'equipment',
            attributes: ['id', 'name', 'code', 'department']
          },
          {
            model: User,
            as: 'creator',
            attributes: ['id', 'name']
          },
          {
            model: User,
            as: 'technician',
            attributes: ['id', 'name']
          },
          {
            model: File,
            as: 'files'
          }
        ]
      });
  
      if (!serviceOrder) {
        return res.status(404).json({ error: 'Ordem de serviço não encontrada' });
      }
  
      // Verifica permissão de acesso ao departamento
      if (req.userRole !== 'admin' && 
          serviceOrder.equipment.department !== req.userDepartment) {
        return res.status(403).json({ error: 'Acesso não autorizado' });
      }
  
      return res.json(serviceOrder);
    } catch (error) {
      console.error('Erro ao buscar ordem de serviço:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async update(req, res) {
    const serviceOrder = await ServiceOrder.findByPk(req.params.id);

    if (!serviceOrder) {
      return res.status(404).json({ error: 'Ordem de serviço não encontrada' });
    }

    if (req.body.status === 'completed') {
      req.body.completed_at = new Date();

      await MaintenanceHistory.create({
        equipment_id: serviceOrder.equipment_id,
        maintenance_date: req.body.completed_at,
        type: serviceOrder.type,
        description: serviceOrder.description,
        performed_by: req.userId,
      });
    }

    await serviceOrder.update(req.body);

    return res.json(serviceOrder);
  }
}

module.exports = new ServiceOrderController();

================
File: src/controllers/UserController.js
================
const { User } = require('../models');
const { generateToken } = require('../utils/auth');
const logger = require('../utils/logger');

class UserController {
  async store(req, res) {
    try {
      const { email } = req.body;

      const userExists = await User.findOne({ where: { email } });

      if (userExists) {
        return res.status(400).json({ error: 'Usuário já existe' });
      }

      const user = await User.create(req.body);

      // Remove o password do retorno
      const { password_hash, ...userData } = user.get();

      return res.status(201).json({
        user: userData,
        token: generateToken({ id: user.id, role: user.role })
      });
    } catch (error) {
      logger.error('Erro ao criar usuário:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async update(req, res) {
    try {
      const { email, oldPassword } = req.body;
      const user = await User.findByPk(req.userId);

      if (!user) {
        return res.status(404).json({ error: 'Usuário não encontrado' });
      }

      if (email && email !== user.email) {
        const userExists = await User.findOne({ where: { email } });
        if (userExists) {
          return res.status(400).json({ error: 'Email já está em uso' });
        }
      }

      if (oldPassword && !(await user.checkPassword(oldPassword))) {
        return res.status(401).json({ error: 'Senha incorreta' });
      }

      await user.update(req.body);

      const { password_hash, ...userData } = user.get();

      return res.json(userData);
    } catch (error) {
      logger.error('Erro ao atualizar usuário:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async index(req, res) {
    try {
      const users = await User.findAll({
        attributes: { exclude: ['password_hash'] }
      });

      return res.json(users);
    } catch (error) {
      logger.error('Erro ao listar usuários:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async show(req, res) {
    try {
      const { id } = req.params;
      const user = await User.findByPk(id, {
        attributes: { exclude: ['password_hash'] }
      });

      if (!user) {
        return res.status(404).json({ error: 'Usuário não encontrado' });
      }

      return res.json(user);
    } catch (error) {
      logger.error('Erro ao buscar usuário:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async delete(req, res) {
    try {
      const { id } = req.params;
      const user = await User.findByPk(id);

      if (!user) {
        return res.status(404).json({ error: 'Usuário não encontrado' });
      }

      await user.destroy();
      return res.status(204).send();
    } catch (error) {
      logger.error('Erro ao deletar usuário:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }
}

module.exports = new UserController();

================
File: src/database/migrations/01-create-users.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('users', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false
        },
        email: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true
        },
        password_hash: {
          type: Sequelize.STRING,
          allowNull: false
        },
        role: {
          type: Sequelize.ENUM('admin', 'manager', 'technician'),
          defaultValue: 'technician'
        },
        department: {
          type: Sequelize.STRING
        },
        active: {
          type: Sequelize.BOOLEAN,
          defaultValue: true
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('users');
    }
  };

================
File: src/database/migrations/02-create-equipment.js
================
// Migration: 02-create-equipment.js
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('equipment', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false
        },
        code: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true
        },
        serial_number: {
          type: Sequelize.STRING
        },
        department: {
          type: Sequelize.STRING,
          allowNull: false
        },
        description: {
          type: Sequelize.TEXT
        },
        status: {
          type: Sequelize.ENUM('active', 'maintenance', 'inactive'),
          defaultValue: 'active'
        },
        maintenance_frequency: {
          type: Sequelize.INTEGER, // em dias
          defaultValue: 30
        },
        last_maintenance: {
          type: Sequelize.DATE
        },
        qrcode_url: {
          type: Sequelize.STRING
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('equipment');
    }
  };

================
File: src/database/migrations/03-create-service-orders.js
================
// src/database/migrations/08-create-service-orders.js
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('service_orders', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        equipment_id: {
          type: Sequelize.INTEGER,
          references: { model: 'equipment', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: false
        },
        type: {
          type: Sequelize.ENUM('preventive', 'corrective', 'predictive'),
          allowNull: false
        },
        priority: {
          type: Sequelize.ENUM('low', 'medium', 'high', 'critical'),
          defaultValue: 'medium'
        },
        status: {
          type: Sequelize.ENUM('pending', 'in_progress', 'completed', 'cancelled'),
          defaultValue: 'pending'
        },
        scheduled_for: {
          type: Sequelize.DATE,
          allowNull: false
        },
        completed_at: {
          type: Sequelize.DATE
        },
        cost: {
          type: Sequelize.DECIMAL(10, 2)
        },
        notes: {
          type: Sequelize.TEXT
        },
        created_by: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        assigned_to: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('service_orders');
    }
  };

================
File: src/database/migrations/04-create-files.js
================
// src/database/migrations/06-create-files.js
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('files', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false
        },
        path: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true
        },
        service_order_id: {
          type: Sequelize.INTEGER,
          references: { model: 'service_orders', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('files');
    }
  };

================
File: src/database/migrations/05-create-maintenance-history.js
================
// src/database/migrations/07-create-maintenance-history.js
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('maintenance_history', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        equipment_id: {
          type: Sequelize.INTEGER,
          references: { model: 'equipment', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        maintenance_date: {
          type: Sequelize.DATE,
          allowNull: false
        },
        type: {
          type: Sequelize.ENUM('preventive', 'corrective', 'predictive'),
          allowNull: false
        },
        description: {
          type: Sequelize.TEXT
        },
        cost: {
          type: Sequelize.DECIMAL(10, 2),
          validate: {
            min: 0
          }
        },
        parts_replaced: {
          type: Sequelize.JSON
        },
        performed_by: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('maintenance_history');
    }
  };

================
File: src/database/migrations/06-create-notifications.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('notifications', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        recipient_id: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        type: {
          type: Sequelize.STRING,
          allowNull: false
        },
        title: {
          type: Sequelize.STRING,
          allowNull: false
        },
        message: {
          type: Sequelize.TEXT,
          allowNull: false
        },
        read: {
          type: Sequelize.BOOLEAN,
          defaultValue: false
        },
        reference_type: {
          type: Sequelize.STRING
        },
        reference_id: {
          type: Sequelize.INTEGER
        },
        priority: {
          type: Sequelize.ENUM('low', 'normal', 'high'),
          defaultValue: 'normal'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('notifications');
    }
  };

================
File: src/database/migrations/07-create-reports.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('reports', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        type: {
          type: Sequelize.STRING,
          allowNull: false
        },
        title: {
          type: Sequelize.STRING,
          allowNull: false
        },
        filters: {
          type: Sequelize.JSONB
        },
        file_url: {
          type: Sequelize.STRING
        },
        status: {
          type: Sequelize.ENUM('processing', 'completed', 'error'),
          defaultValue: 'processing'
        },
        error_message: {
          type: Sequelize.TEXT
        },
        created_by: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('reports');
    }
  };

================
File: src/database/seeders/20250203021507-admin-user.js
================
'use strict';
const bcrypt = require('bcryptjs');

module.exports = {
  up: async (queryInterface, Sequelize) => {
    return queryInterface.bulkInsert('users', [{
      name: 'Administrador',
      email: 'admin@admin.com',
      password_hash: await bcrypt.hash('123456', 8),  // Mudamos de password para password_hash
      role: 'admin',
      active: true,
      created_at: new Date(),
      updated_at: new Date()
    }]);
  },

  down: (queryInterface, Sequelize) => {
    return queryInterface.bulkDelete('users', null, {});
  }
};

================
File: src/database/index.js
================
const { sequelize } = require('../models'); // Importa os modelos já inicializados do `models/index.js`
const config = require('../config/database');

const env = process.env.NODE_ENV || 'development';
const dbConfig = config[env];

// Caso queira garantir que a instância esteja corretamente configurada
if (!sequelize) {
  throw new Error('Falha ao conectar com o banco de dados.');
}

// Sincroniza o banco de dados com os modelos
sequelize.authenticate()
  .then(() => console.log('Conexão com o banco de dados estabelecida com sucesso!'))
  .catch(err => console.error('Não foi possível conectar ao banco de dados:', err));

module.exports = sequelize;

================
File: src/jobs/processors/equipmentProcessor.js
================
const QRCodeService = require('../../services/QRCodeService');
const {Equipment} = require('../../models/Equipment');
const logger = require('../../utils/logger');

const equipmentProcessor = {
  async sync(equipmentId, changes) {
    try {
      const equipment = await Equipment.findByPk(equipmentId);
      
      if (!equipment) {
        throw new Error('Equipamento não encontrado');
      }

      // Atualiza dados
      await equipment.update(changes);

      // Gera novo QR Code se necessário
      if (changes.needsNewQRCode) {
        const qrcode = await QRCodeService.generateForEquipment(equipment);
        await equipment.update({ qrcode_url: qrcode.url });
      }

      return equipment;

    } catch (error) {
      logger.error('Erro na sincronização do equipamento:', error);
      throw error;
    }
  }
};

module.exports = equipmentProcessor;

================
File: src/jobs/processors/fileProcessor.js
================
const sharp = require('sharp');
const S3Service = require('../../services/S3Service');
const logger = require('../../utils/logger');

const fileProcessor = {
  async process(file, type) {
    try {
      let processedFile = file;

      // Processa imagens
      if (type === 'image') {
        processedFile.buffer = await sharp(file.buffer)
          .resize(1200, 1200, { fit: 'inside', withoutEnlargement: true })
          .jpeg({ quality: 80 })
          .toBuffer();
      }

      // Upload para S3
      const result = await S3Service.uploadFile(processedFile);

      return result;

    } catch (error) {
      logger.error('Erro ao processar arquivo:', error);
      throw error;
    }
  }
};

module.exports = fileProcessor;

================
File: src/jobs/processors/index.js
================
const reportProcessor = require('./reportProcessor');
const notificationProcessor = require('./notificationProcessor');
const fileProcessor = require('./fileProcessor');
const equipmentProcessor = require('./equipmentProcessor');

module.exports = {
  reportProcessor,
  notificationProcessor,
  fileProcessor,
  equipmentProcessor
};

================
File: src/jobs/processors/notificationProcessor.js
================
const EmailService = require('../../services/emailService');
const WebSocketManager = require('../../websocket/WebSocketManager');
const {Notification} = require('../../models/Notification');
const logger = require('../../utils/logger');

const notificationProcessor = {
  async send(type, data) {
    try {
      const notification = await Notification.create({
        type,
        ...data
      });

      // Envia email se configurado
      if (data.sendEmail) {
        await EmailService.sendMail({
          to: data.user.email,
          subject: data.subject,
          template: data.template,
          context: data.context
        });
      }

      // Notifica em tempo real
      WebSocketManager.sendToClient(data.userId, {
        type: 'NOTIFICATION',
        data: notification
      });

      return notification;

    } catch (error) {
      logger.error('Erro ao processar notificação:', error);
      throw error;
    }
  }
};

module.exports = notificationProcessor;

================
File: src/jobs/processors/reportProcessor.js
================
const PDFService = require('../../services/PDFService');
const S3Service = require('../../services/S3Service');
const {Report} = require('../../models/Report');
const logger = require('../../utils/logger');

const reportProcessor = {
  async generate(type, filters, userId) {
    try {
      let report;
      let buffer;

      switch (type) {
        case 'maintenance':
          buffer = await PDFService.createMaintenanceReport(filters);
          break;
        case 'equipment':
          buffer = await PDFService.createEquipmentReport(filters);
          break;
        default:
          throw new Error(`Tipo de relatório não suportado: ${type}`);
      }

      // Upload do relatório para S3
      const fileName = `reports/${type}/${Date.now()}.pdf`;
      const uploadResult = await S3Service.uploadFile({
        buffer,
        originalname: fileName,
        mimetype: 'application/pdf'
      });

      // Atualiza status no banco
      report = await Report.create({
        type,
        filters,
        file_url: uploadResult.url,
        status: 'completed',
        created_by: userId
      });

      return report;

    } catch (error) {
      logger.error('Erro ao gerar relatório:', error);
      throw error;
    }
  }
};

module.exports = reportProcessor;

================
File: src/jobs/JobProcessor.js
================
const Queue = require('bull');
const path = require('path');
const processors = require('./processors');

class JobProcessor {
  constructor() {
    this.queues = {
      reportGeneration: new Queue('reportGeneration', {
        redis: {
          host: process.env.REDIS_HOST,
          port: process.env.REDIS_PORT,
          password: process.env.REDIS_PASSWORD
        },
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 1000
          },
          removeOnComplete: true
        }
      }),
      maintenanceNotification: new Queue('maintenanceNotification'),
      fileProcessing: new Queue('fileProcessing'),
      equipmentSync: new Queue('equipmentSync')
    };

    this.initializeProcessors();
  }

  initializeProcessors() {
    // Report Generation Queue
    this.queues.reportGeneration.process(async (job) => {
      try {
        const { type, filters, userId } = job.data;
        const report = await processors.reportProcessor.generate(type, filters);
        
        // Notifica o usuário que o relatório está pronto
        await this.queues.maintenanceNotification.add({
          type: 'REPORT_READY',
          userId,
          reportUrl: report.url
        });

        return report;
      } catch (error) {
        console.error('Erro ao gerar relatório:', error);
        throw error;
      }
    });

    // File Processing Queue
    this.queues.fileProcessing.process(async (job) => {
      const { file, type } = job.data;
      return await processors.fileProcessor.process(file, type);
    });

    // Equipment Sync Queue
    this.queues.equipmentSync.process(async (job) => {
      const { equipmentId, changes } = job.data;
      return await processors.equipmentProcessor.sync(equipmentId, changes);
    });

    // Maintenance Notification Queue
    this.queues.maintenanceNotification.process(async (job) => {
      const { type, data } = job.data;
      return await processors.notificationProcessor.send(type, data);
    });
  }

  // Adiciona job na fila de geração de relatórios
  async addReportJob(type, filters, userId) {
    return await this.queues.reportGeneration.add({
      type,
      filters,
      userId
    });
  }

  // Adiciona job na fila de processamento de arquivos
  async addFileProcessingJob(file, type) {
    return await this.queues.fileProcessing.add({
      file,
      type
    });
  }

  // Adiciona job na fila de sincronização de equipamentos
  async addEquipmentSyncJob(equipmentId, changes) {
    return await this.queues.equipmentSync.add({
      equipmentId,
      changes
    });
  }

  // Adiciona job na fila de notificações
  async addNotificationJob(type, data) {
    return await this.queues.maintenanceNotification.add({
      type,
      data
    });
  }

  // Retorna o status de todos os jobs
  async getJobsStatus() {
    const status = {};
    
    for (const [queueName, queue] of Object.entries(this.queues)) {
      status[queueName] = {
        waiting: await queue.getWaitingCount(),
        active: await queue.getActiveCount(),
        completed: await queue.getCompletedCount(),
        failed: await queue.getFailedCount()
      };
    }

    return status;
  }

  // Limpa jobs completados
  async cleanCompletedJobs() {
    for (const queue of Object.values(this.queues)) {
      await queue.clean(1000 * 60 * 60 * 24, 'completed'); // Remove jobs completados há mais de 24h
    }
  }
}

module.exports = new JobProcessor();

================
File: src/middlewares/auth.js
================
const jwt = require('jsonwebtoken');
const { User } = require('../models/User');

class AuthMiddleware {
  async authenticate(req, res, next) {
    try {
      const authHeader = req.headers.authorization;

      if (!authHeader) {
        return res.status(401).json({ error: 'Token não fornecido' });
      }

      const [, token] = authHeader.split(' ');

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      const user = await User.findByPk(decoded.id);
      
      if (!user || !user.active) {
        return res.status(401).json({ error: 'Usuário inválido ou inativo' });
      }

      req.userId = user.id;
      req.userRole = user.role;
      
      next();
    } catch (error) {
      return res.status(401).json({ error: 'Token inválido' });
    }
  }

  hasRole(roles) {
    return (req, res, next) => {
      if (!roles.includes(req.userRole)) {
        return res.status(403).json({ error: 'Acesso não autorizado' });
      }
      next();
    };
  }

  isAdmin(req, res, next) {
    if (req.userRole !== 'admin') {
      return res.status(403).json({ error: 'Acesso restrito a administradores' });
    }
    next();
  }

  // Middleware para verificar se o usuário tem acesso ao departamento
  async hasDepartmentAccess(req, res, next) {
    try {
      if (req.userRole === 'admin') {
        return next();
      }

      const user = await User.findByPk(req.userId);
      const requestedDepartment = req.body.department || req.query.department;

      if (!requestedDepartment || user.department === requestedDepartment) {
        return next();
      }

      return res.status(403).json({ error: 'Acesso não autorizado ao departamento' });
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new AuthMiddleware();

================
File: src/middlewares/errorHandler.js
================
const { ValidationError } = require('sequelize');

module.exports = (err, req, res, next) => {
  if (err instanceof ValidationError) {
    return res.status(400).json({
      error: 'Erro de validação',
      messages: err.errors.map(error => error.message),
    });
  }

  console.error(err);

  return res.status(500).json({
    error: 'Erro interno do servidor',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined,
  });
};

================
File: src/middlewares/security.js
================
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const hpp = require('hpp');
const cors = require('cors');

// Rate limiter para rotas gerais
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // limite por IP
  message: 'Muitas requisições deste IP, tente novamente em 15 minutos'
});

// Rate limiter específico para autenticação
const authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 5, // 5 tentativas
  message: 'Muitas tentativas de login, tente novamente em 1 hora'
});

const security = {
  // Middlewares básicos de segurança
  basic: [
    helmet(),
    mongoSanitize(),
    hpp(),
    cors({
      origin: process.env.CORS_ORIGIN || '*',
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
      allowedHeaders: ['Content-Type', 'Authorization']
    })
  ],

  // Rate limiting
  rateLimit: {
    all: limiter,
    auth: authLimiter
  }
};

module.exports = security;

================
File: src/middlewares/validate.js
================
const yup = require('yup');

module.exports = schema => async (req, res, next) => {
  try {
    await schema.validate(req.body, { abortEarly: false });
    return next();
  } catch (err) {
    return res.status(400).json({
      error: 'Erro de validação',
      messages: err.inner.map(error => ({
        field: error.path,
        message: error.message,
      })),
    });
  }
};

================
File: src/models/Equipment.js
================
module.exports = (sequelize, DataTypes) => {
  const Equipment = sequelize.define('Equipment', {
    name: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        notEmpty: true,
      },
    },
    code: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    serial_number: DataTypes.STRING,
    department: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    description: DataTypes.TEXT,
    status: {
      type: DataTypes.ENUM('active', 'maintenance', 'inactive'),
      defaultValue: 'active',
    },
    qrcode_url: DataTypes.STRING,
    last_maintenance: DataTypes.DATE,
    maintenance_frequency: {
      type: DataTypes.INTEGER,
      defaultValue: 30,
    },
  }, {
    tableName: 'equipment'
  });

  Equipment.associate = function(models) {
    Equipment.hasMany(models.ServiceOrder, {
      foreignKey: 'equipment_id',
      as: 'service_orders',
    });
    Equipment.hasMany(models.MaintenanceHistory, {
      foreignKey: 'equipment_id',
      as: 'maintenance_history',
    });
  };

  return Equipment;
};

================
File: src/models/File.js
================
module.exports = (sequelize, DataTypes) => {
  const File = sequelize.define('File', {
    name: {
      type: DataTypes.STRING,
      allowNull: false,
    },
    path: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
    },
    url: {
      type: DataTypes.VIRTUAL,
      get() {
        return `${process.env.APP_URL}/files/${this.path}`;
      },
    },
  }, {
    tableName: 'files'
  });

  File.associate = function(models) {
    File.belongsTo(models.ServiceOrder, {
      foreignKey: 'service_order_id',
      as: 'service_order'
    });
  };

  return File;
};

================
File: src/models/index.js
================
const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const config = require('../config/database');

const db = {};
const sequelize = new Sequelize(config[process.env.NODE_ENV || 'development']);

// Carrega todos os modelos automaticamente
const modelsPath = __dirname;
fs.readdirSync(modelsPath)
  .filter(file => {
    return (file.indexOf('.') !== 0) && 
           (file !== path.basename(__filename)) && 
           (file.slice(-3) === '.js');
  })
  .forEach(file => {
    const modelDefinition = require(path.join(modelsPath, file));
    const model = modelDefinition(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;

================
File: src/models/MaintenanceHistory.js
================
module.exports = (sequelize, DataTypes) => {
  const MaintenanceHistory = sequelize.define('MaintenanceHistory', {
    maintenance_date: {
      type: DataTypes.DATE,
      allowNull: false,
    },
    type: {
      type: DataTypes.ENUM('preventive', 'corrective', 'predictive'),
      allowNull: false,
    },
    description: DataTypes.TEXT,
    cost: {
      type: DataTypes.DECIMAL(10, 2),
      validate: {
        min: 0,
      },
    },
    parts_replaced: DataTypes.JSON,
  }, {
    tableName: 'maintenance_history',
  });

  MaintenanceHistory.associate = function(models) {
    MaintenanceHistory.belongsTo(models.Equipment, {
      foreignKey: 'equipment_id',
      as: 'equipment',
    });
    MaintenanceHistory.belongsTo(models.User, {
      foreignKey: 'performed_by',
      as: 'technician',
    });
  };

  return MaintenanceHistory;
};

================
File: src/models/Notification.js
================
module.exports = (sequelize, DataTypes) => {
  const Notification = sequelize.define('Notification', {
    recipient_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: {
        model: 'users',
        key: 'id',
      },
    },
    sender_id: {
      type: DataTypes.INTEGER,
      allowNull: true,
      references: {
        model: 'users',
        key: 'id',
      },
    },
    type: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        notEmpty: true,
      },
    },
    title: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        len: [5, 255],
      },
    },
    message: {
      type: DataTypes.TEXT,
      allowNull: false,
      validate: {
        notEmpty: true,
      },
    },
    read: {
      type: DataTypes.BOOLEAN,
      defaultValue: false,
    },
    reference_type: {
      type: DataTypes.STRING,
      allowNull: true,
    },
    reference_id: {
      type: DataTypes.INTEGER,
      allowNull: true,
    },
    priority: {
      type: DataTypes.ENUM('low', 'normal', 'high'),
      defaultValue: 'normal',
      validate: {
        isIn: [['low', 'normal', 'high']],
      },
    },
  }, {
    tableName: 'notifications',
    timestamps: true,
    underscored: true,
    paranoid: false,
    indexes: [
      {
        fields: ['recipient_id'],
      },
      {
        fields: ['read'],
      },
    ],
  });

  Notification.associate = function(models) {
    Notification.belongsTo(models.User, {
      foreignKey: 'recipient_id',
      as: 'recipient',
    });

    Notification.belongsTo(models.User, {
      foreignKey: 'sender_id',
      as: 'sender',
    });
  };

  return Notification;
};

================
File: src/models/Report.js
================
module.exports = (sequelize, DataTypes) => {
    const Report = sequelize.define('Report', {
      type: {
        type: DataTypes.STRING,
        allowNull: false
      },
      title: {
        type: DataTypes.STRING,
        allowNull: false
      },
      filters: {
        type: DataTypes.JSONB
      },
      file_url: {
        type: DataTypes.STRING
      },
      status: {
        type: DataTypes.ENUM('processing', 'completed', 'error'),
        defaultValue: 'processing'
      },
      error_message: {
        type: DataTypes.TEXT
      }
    }, {
      tableName: 'reports'
    });
  
    Report.associate = function(models) {
      Report.belongsTo(models.User, {
        foreignKey: 'created_by',
        as: 'creator'
      });
    };
  
    return Report;
  };

================
File: src/models/ServiceOrder.js
================
module.exports = (sequelize, DataTypes) => {
  const ServiceOrder = sequelize.define('ServiceOrder', {
    description: {
      type: DataTypes.TEXT,
      allowNull: false,
    },
    type: {
      type: DataTypes.ENUM('preventive', 'corrective', 'predictive'),
      allowNull: false,
    },
    priority: {
      type: DataTypes.ENUM('low', 'medium', 'high', 'critical'),
      allowNull: false,
      defaultValue: 'medium',
    },
    status: {
      type: DataTypes.ENUM('pending', 'in_progress', 'completed', 'cancelled'),
      allowNull: false,
      defaultValue: 'pending',
    },
    scheduled_for: {
      type: DataTypes.DATE,
      allowNull: false,
    },
    completed_at: {
      type: DataTypes.DATE,
      allowNull: true,
    },
    cost: {
      type: DataTypes.DECIMAL(10, 2),
      allowNull: true,
      validate: {
        min: 0,
      },
    },
    notes: {
      type: DataTypes.TEXT,
      allowNull: true,
    },
  }, {
    tableName: 'service_orders',
    underscored: true,
    timestamps: true,
  });

  ServiceOrder.associate = function(models) {
    ServiceOrder.belongsTo(models.Equipment, {
      foreignKey: 'equipment_id',
      as: 'equipment',
    });
    ServiceOrder.belongsTo(models.User, {
      foreignKey: 'created_by',
      as: 'creator',
    });
    ServiceOrder.belongsTo(models.User, {
      foreignKey: 'assigned_to',
      as: 'technician',
    });
    ServiceOrder.hasMany(models.File, {
      foreignKey: 'service_order_id',
      as: 'files',
    });
  };

  return ServiceOrder;
};

================
File: src/models/User.js
================
const bcrypt = require('bcryptjs');

module.exports = (sequelize, DataTypes) => {
  const User = sequelize.define('User', {
    name: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        notEmpty: true
      }
    },
    email: {
      type: DataTypes.STRING,
      allowNull: false,
      unique: true,
      validate: {
        isEmail: true
      }
    },
    password_hash: {
      type: DataTypes.STRING,
      allowNull: false
    },
    password: {
      type: DataTypes.VIRTUAL,
      validate: {
        len: [6, 100]
      }
    },
    role: {
      type: DataTypes.ENUM('admin', 'manager', 'technician'),
      defaultValue: 'technician'
    },
    department: {
      type: DataTypes.STRING
    },
    active: {
      type: DataTypes.BOOLEAN,
      defaultValue: true
    }
  }, {
    tableName: 'users',
    timestamps: true,
    underscored: true,
    hooks: {
      beforeSave: async (user) => {
        if (user.password) {
          user.password_hash = await bcrypt.hash(user.password, 8);
        }
      }
    }
  });

  User.prototype.checkPassword = function(password) {
    return bcrypt.compare(password, this.password_hash);
  };

  User.associate = function(models) {
    User.hasMany(models.ServiceOrder, { 
      foreignKey: 'created_by', 
      as: 'createdOrders' 
    });
    User.hasMany(models.MaintenanceHistory, { 
      foreignKey: 'performed_by', 
      as: 'performedMaintenance' 
    });
  };

  return User;
};

================
File: src/routes/index.js
================
const express = require('express');
const router = express.Router();
const multer = require('multer');
const multerConfig = require('../config/multer');

// Controllers
const AuthController = require('../controllers/AuthController');
const EquipmentController = require('../controllers/EquipmentController');
const ServiceOrderController = require('../controllers/ServiceOrderController');
const UserController = require('../controllers/UserController');
const MaintenanceController = require('../controllers/MaintenanceController');
const NotificationController = require('../controllers/NotificationController');
const ReportController = require('../controllers/ReportController');
const DashboardController = require('../controllers/DashboardController');

// Middlewares
const auth = require('../middlewares/auth');
const validate = require('../middlewares/validate');
const schemas = require('../validations/schemas');

const upload = multer(multerConfig);

// Rotas públicas
router.post('/auth/login', validate(schemas.loginSchema), AuthController.login);
router.post('/auth/forgot-password', AuthController.forgotPassword);
router.post('/auth/reset-password', AuthController.resetPassword);

// Middleware de autenticação para rotas protegidas
router.use(auth.authenticate);

// Equipamentos
router.get('/equipment', auth.hasDepartmentAccess, EquipmentController.index);
router.post('/equipment', 
  auth.hasRole(['admin', 'manager']),
  validate(schemas.equipmentSchema),
  upload.single('image'),
  EquipmentController.store
);
router.get('/equipment/:id', auth.hasDepartmentAccess, EquipmentController.show);
router.put('/equipment/:id',
  auth.hasRole(['admin', 'manager']),
  validate(schemas.equipmentSchema),
  upload.single('image'),
  EquipmentController.update
);
router.delete('/equipment/:id', auth.hasRole(['admin']), EquipmentController.destroy);

// Ordens de Serviço
router.get('/service-orders', auth.hasDepartmentAccess, ServiceOrderController.index);
router.post('/service-orders',
  validate(schemas.serviceOrderSchema),
  upload.array('attachments', 5),
  ServiceOrderController.store
);
router.get('/service-orders/:id', ServiceOrderController.show);
router.put('/service-orders/:id',
  auth.hasRole(['admin', 'technician']),
  validate(schemas.serviceOrderUpdateSchema),
  ServiceOrderController.update
);

// Usuários
router.get('/users', auth.hasRole(['admin']), UserController.index);
router.post('/users',
  auth.hasRole(['admin']),
  validate(schemas.userSchema),
  UserController.store
);
router.put('/users/:id',
  auth.hasRole(['admin']),
  validate(schemas.userUpdateSchema),
  UserController.update
);
router.delete('/users/:id', auth.hasRole(['admin']), UserController.delete);

// Manutenções
router.post('/maintenance',
  validate(schemas.maintenanceSchema),
  upload.fields([
    { name: 'photos', maxCount: 5 },
    { name: 'documents', maxCount: 3 }
  ]),
  MaintenanceController.store
);
router.get('/maintenance', auth.hasDepartmentAccess, MaintenanceController.index);
router.get('/maintenance/:id', auth.hasDepartmentAccess, MaintenanceController.show);
router.put('/maintenance/:id',
  auth.hasRole(['admin', 'technician']),
  validate(schemas.maintenanceUpdateSchema),
  MaintenanceController.update
);

// Dashboard
router.get('/dashboard/stats', auth.hasDepartmentAccess, DashboardController.getStats);

// Notificações
router.get('/notifications', NotificationController.list);
router.put('/notifications/:id/read', NotificationController.markAsRead);
router.put('/notifications/mark-all-read', NotificationController.markAllAsRead);
router.get('/notifications/preferences', NotificationController.getUserPreferences);
router.put('/notifications/preferences', NotificationController.updateUserPreferences);

// Relatórios
router.get('/reports/generate', auth.hasRole(['admin', 'manager']), ReportController.generate);
router.get('/reports/:id/download', auth.hasRole(['admin', 'manager']), ReportController.download);
router.get('/reports', auth.hasRole(['admin', 'manager']), ReportController.list);
router.delete('/reports/:id', auth.hasRole(['admin']), ReportController.delete);

module.exports = router;

================
File: src/services/AuditService.js
================
const { AuditLog, User } = require('../models');
const logger = require('../utils/logger');

class AuditService {
  constructor() {
    this.ignoredFields = ['updated_at', 'created_at'];
  }

  async logAction(params) {
    try {
      const {
        userId,
        action,
        entityType,
        entityId,
        oldValues,
        newValues,
        metadata = {}
      } = params;

      await AuditLog.create({
        user_id: userId,
        action,
        entity_type: entityType,
        entity_id: entityId,
        old_values: oldValues,
        new_values: newValues,
        metadata: {
          ...metadata,
          ip: metadata.ip,
          userAgent: metadata.userAgent,
          timestamp: new Date()
        }
      });

    } catch (error) {
      logger.error('Erro ao registrar log de auditoria:', error);
    }
  }

  async trackChanges(entity, changes, userId, metadata = {}) {
    const changedFields = Object.keys(changes)
      .filter(field => !this.ignoredFields.includes(field));

    if (changedFields.length === 0) return;

    const oldValues = {};
    const newValues = {};

    changedFields.forEach(field => {
      oldValues[field] = entity[field];
      newValues[field] = changes[field];
    });

    await this.logAction({
      userId,
      action: 'UPDATE',
      entityType: entity.constructor.name,
      entityId: entity.id,
      oldValues,
      newValues,
      metadata
    });
  }

  async getAuditTrail(params) {
    try {
      const {
        entityType,
        entityId,
        startDate,
        endDate,
        userId,
        page = 1,
        limit = 20
      } = params;

      const where = {};
      
      if (entityType) where.entity_type = entityType;
      if (entityId) where.entity_id = entityId;
      if (userId) where.user_id = userId;
      if (startDate || endDate) {
        where.created_at = {};
        if (startDate) where.created_at[Op.gte] = startDate;
        if (endDate) where.created_at[Op.lte] = endDate;
      }

      const logs = await AuditLog.findAndCountAll({
        where,
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'name', 'email']
          }
        ],
        order: [['created_at', 'DESC']],
        limit,
        offset: (page - 1) * limit
      });

      return {
        logs: logs.rows,
        total: logs.count,
        page,
        pages: Math.ceil(logs.count / limit)
      };

    } catch (error) {
      logger.error('Erro ao buscar logs de auditoria:', error);
      throw new Error('Falha ao buscar histórico de auditoria');
    }
  }

  async getEntityHistory(entityType, entityId) {
    try {
      const logs = await AuditLog.findAll({
        where: {
          entity_type: entityType,
          entity_id: entityId
        },
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'name', 'email']
          }
        ],
        order: [['created_at', 'DESC']]
      });

      return this.formatEntityHistory(logs);

    } catch (error) {
      logger.error('Erro ao buscar histórico da entidade:', error);
      throw new Error('Falha ao buscar histórico');
    }
  }

  formatEntityHistory(logs) {
    return logs.map(log => {
      const changes = this.compareValues(log.old_values, log.new_values);
      
      return {
        id: log.id,
        date: log.created_at,
        user: log.user,
        action: log.action,
        changes,
        metadata: log.metadata
      };
    });
  }

  compareValues(oldValues, newValues) {
    const changes = [];
    const allFields = new Set([
      ...Object.keys(oldValues || {}),
      ...Object.keys(newValues || {})
    ]);

    allFields.forEach(field => {
      if (this.ignoredFields.includes(field)) return;

      const oldValue = oldValues?.[field];
      const newValue = newValues?.[field];

      if (oldValue !== newValue) {
        changes.push({
          field,
          from: oldValue,
          to: newValue
        });
      }
    });

    return changes;
  }

  // Migration para a tabela de auditoria
  static get migration() {
    return {
      up: async (queryInterface, Sequelize) => {
        await queryInterface.createTable('audit_logs', {
          id: {
            type: Sequelize.INTEGER,
            primaryKey: true,
            autoIncrement: true
          },
          user_id: {
            type: Sequelize.INTEGER,
            references: { model: 'users', key: 'id' },
            onUpdate: 'CASCADE',
            onDelete: 'SET NULL'
          },
          action: {
            type: Sequelize.STRING,
            allowNull: false
          },
          entity_type: {
            type: Sequelize.STRING,
            allowNull: false
          },
          entity_id: {
            type: Sequelize.INTEGER,
            allowNull: false
          },
          old_values: {
            type: Sequelize.JSONB
          },
          new_values: {
            type: Sequelize.JSONB
          },
          metadata: {
            type: Sequelize.JSONB
          },
          created_at: {
            type: Sequelize.DATE,
            allowNull: false
          },
          // Continuação da migration anterior...
          updated_at: {
            type: Sequelize.DATE,
            allowNull: false
          },
          ip_address: {
            type: Sequelize.STRING
          },
          user_agent: {
            type: Sequelize.STRING
          },
          browser: {
            type: Sequelize.STRING
          },
          platform: {
            type: Sequelize.STRING
          }
        });

        // Índices para melhor performance
        await queryInterface.addIndex('audit_logs', ['entity_type', 'entity_id']);
        await queryInterface.addIndex('audit_logs', ['user_id']);
        await queryInterface.addIndex('audit_logs', ['created_at']);
      },

      down: async (queryInterface) => {
        await queryInterface.dropTable('audit_logs');
      }
    };
  }
}

// Modelo Sequelize para AuditLog
const AuditLogModel = (sequelize, DataTypes) => {
  const AuditLog = sequelize.define('AuditLog', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    user_id: {
      type: DataTypes.INTEGER,
      references: {
        model: 'users',
        key: 'id'
      }
    },
    action: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        isIn: [['CREATE', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT', 'FAILED_LOGIN']]
      }
    },
    entity_type: {
      type: DataTypes.STRING,
      allowNull: false
    },
    entity_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    old_values: {
      type: DataTypes.JSONB
    },
    new_values: {
      type: DataTypes.JSONB
    },
    metadata: {
      type: DataTypes.JSONB
    },
    ip_address: DataTypes.STRING,
    user_agent: DataTypes.STRING,
    browser: DataTypes.STRING,
    platform: DataTypes.STRING
  }, {
    tableName: 'audit_logs',
    timestamps: true
  });

  AuditLog.associate = (models) => {
    AuditLog.belongsTo(models.User, {
      foreignKey: 'user_id',
      as: 'user'
    });
  };

  return AuditLog;
};

// Middleware para capturar automaticamente mudanças nos modelos
const auditMiddleware = (schema) => {
  schema.addHook('beforeUpdate', async (instance, options) => {
    if (!options.userId) return;

    const changes = instance.changed();
    if (!changes) return;

    const oldValues = {};
    const newValues = {};

    changes.forEach(field => {
      oldValues[field] = instance._previousDataValues[field];
      newValues[field] = instance.dataValues[field];
    });

    await AuditLog.create({
      user_id: options.userId,
      action: 'UPDATE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      old_values: oldValues,
      new_values: newValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });

  schema.addHook('afterCreate', async (instance, options) => {
    if (!options.userId) return;

    await AuditLog.create({
      user_id: options.userId,
      action: 'CREATE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      new_values: instance.dataValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });

  schema.addHook('beforeDestroy', async (instance, options) => {
    if (!options.userId) return;

    await AuditLog.create({
      user_id: options.userId,
      action: 'DELETE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      old_values: instance.dataValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });
};

// Middleware Express para incluir informações de auditoria
const auditMiddlewareExpress = (req, res, next) => {
  if (req.user) {
    req.auditInfo = {
      userId: req.user.id,
      ip: req.ip,
      userAgent: req.get('user-agent'),
      browser: req.get('sec-ch-ua'),
      platform: req.get('sec-ch-ua-platform')
    };
  }
  next();
};

module.exports = {
  AuditService,
  AuditLogModel,
  auditMiddleware,
  auditMiddlewareExpress
};

================
File: src/services/CacheService.js
================
const { getRedisClient, isRedisAvailable } = require('../config/redis');
const logger = require('../utils/logger');

class CacheService {
  constructor() {
    this.prefix = 'oss:';
    this.defaultTTL = 3600; // 1 hora em segundos
  }

  async get(key) {
    try {
      // Verifica se o Redis está disponível
      if (!await isRedisAvailable()) {
        return null;
      }

      const redis = await getRedisClient();
      const value = await redis.get(this.prefix + key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      logger.warn('Erro ao recuperar do cache:', error.message);
      return null;
    }
  }

  async set(key, value, ttl = this.defaultTTL) {
    try {
      // Verifica se o Redis está disponível
      if (!await isRedisAvailable()) {
        return false;
      }

      const redis = await getRedisClient();
      await redis.set(
        this.prefix + key,
        JSON.stringify(value),
        'EX',
        ttl
      );
      return true;
    } catch (error) {
      logger.warn('Erro ao definir cache:', error.message);
      return false;
    }
  }

  async delete(key) {
    try {
      // Verifica se o Redis está disponível
      if (!await isRedisAvailable()) {
        return false;
      }

      const redis = await getRedisClient();
      await redis.del(this.prefix + key);
      return true;
    } catch (error) {
      logger.warn('Erro ao deletar cache:', error.message);
      return false;
    }
  }

  async getOrSet(key, callback, ttl = this.defaultTTL) {
    let data = await this.get(key);
    
    if (!data) {
      data = await callback();
      if (data) {
        await this.set(key, data, ttl);
      }
    }

    return data;
  }
}

module.exports = new CacheService();

================
File: src/services/EmailService.js
================
const nodemailer = require('nodemailer');
const path = require('path');
const ejs = require('ejs');

class EmailService {
  constructor() {
    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    });

    this.templatesPath = path.resolve(__dirname, '..', 'views', 'emails');
  }

  async sendMail({ to, subject, template, context }) {
    const templatePath = path.join(this.templatesPath, `${template}.ejs`);
    
    const html = await ejs.renderFile(templatePath, context);

    return this.transporter.sendMail({
      from: process.env.SMTP_FROM,
      to,
      subject,
      html,
    });
  }

  async sendMaintenanceNotification({ user, equipment, serviceOrder }) {
    return this.sendMail({
      to: user.email,
      subject: `Manutenção Agendada - ${equipment.name}`,
      template: 'maintenance-notification',
      context: {
        userName: user.name,
        equipmentName: equipment.name,
        equipmentCode: equipment.code,
        maintenanceDate: serviceOrder.scheduled_for,
        maintenanceType: serviceOrder.type,
        description: serviceOrder.description,
      },
    });
  }

  async sendMaintenanceComplete({ user, equipment, serviceOrder }) {
    return this.sendMail({
      to: user.email,
      subject: `Manutenção Concluída - ${equipment.name}`,
      template: 'maintenance-complete',
      context: {
        userName: user.name,
        equipmentName: equipment.name,
        equipmentCode: equipment.code,
        completedDate: serviceOrder.completed_at,
        maintenanceType: serviceOrder.type,
        description: serviceOrder.description,
      },
    });
  }
}

module.exports = new EmailService();

================
File: src/services/ExcelService.js
================
const ExcelJS = require('exceljs');
const logger = require('../utils/logger');

class ExcelService {
  async generateWorkbook() {
    return new ExcelJS.Workbook();
  }

  async generateMaintenanceReport(data) {
    try {
      const workbook = await this.generateWorkbook();
      const worksheet = workbook.addWorksheet('Manutenções');

      // Configuração das colunas
      worksheet.columns = [
        { header: 'Equipamento', key: 'equipment', width: 20 },
        { header: 'Código', key: 'code', width: 15 },
        { header: 'Tipo', key: 'type', width: 15 },
        { header: 'Data', key: 'date', width: 15 },
        { header: 'Status', key: 'status', width: 15 },
        { header: 'Custo', key: 'cost', width: 15 },
        { header: 'Técnico', key: 'technician', width: 20 }
      ];

      // Estilização do cabeçalho
      worksheet.getRow(1).font = { bold: true };
      worksheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE0E0E0' }
      };

      // Adiciona os dados
      data.forEach(item => {
        worksheet.addRow({
          equipment: item.equipment?.name,
          code: item.equipment?.code,
          type: item.type,
          date: item.maintenance_date,
          status: item.status,
          cost: item.cost,
          technician: item.technician?.name
        });
      });

      // Formatação da coluna de custo
      worksheet.getColumn('cost').numFmt = '"R$ "#,##0.00';

      return await workbook.xlsx.writeBuffer();
    } catch (error) {
      logger.error('Erro ao gerar relatório Excel:', error);
      throw new Error('Falha ao gerar relatório Excel');
    }
  }

  async generateEquipmentReport(data) {
    try {
      const workbook = await this.generateWorkbook();
      const worksheet = workbook.addWorksheet('Equipamentos');

      worksheet.columns = [
        { header: 'Nome', key: 'name', width: 20 },
        { header: 'Código', key: 'code', width: 15 },
        { header: 'Departamento', key: 'department', width: 20 },
        { header: 'Status', key: 'status', width: 15 },
        { header: 'Última Manutenção', key: 'lastMaintenance', width: 20 },
        { header: 'Frequência (dias)', key: 'frequency', width: 15 }
      ];

      // Estilização do cabeçalho
      worksheet.getRow(1).font = { bold: true };
      worksheet.getRow(1).fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: 'FFE0E0E0' }
      };

      // Adiciona os dados
      data.forEach(item => {
        worksheet.addRow({
          name: item.name,
          code: item.code,
          department: item.department,
          status: item.status,
          lastMaintenance: item.last_maintenance,
          frequency: item.maintenance_frequency
        });
      });

      return await workbook.xlsx.writeBuffer();
    } catch (error) {
      logger.error('Erro ao gerar relatório Excel:', error);
      throw new Error('Falha ao gerar relatório Excel');
    }
  }
}

module.exports = new ExcelService();

================
File: src/services/FileService.js
================
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class FileService {
  constructor() {
    this.uploadPath = path.resolve(__dirname, '..', '..', 'uploads');
    this.ensureUploadDirectory();
  }

  ensureUploadDirectory() {
    if (!fs.existsSync(this.uploadPath)) {
      fs.mkdirSync(this.uploadPath, { recursive: true });
    }
  }

  async saveFile(file) {
    const hash = crypto.randomBytes(10).toString('hex');
    const fileName = `${hash}-${file.originalname}`;
    const filePath = path.join(this.uploadPath, fileName);

    return new Promise((resolve, reject) => {
      fs.writeFile(filePath, file.buffer, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve({
          name: fileName,
          path: filePath,
          url: `/uploads/${fileName}`,
        });
      });
    });
  }

  async deleteFile(fileName) {
    const filePath = path.join(this.uploadPath, fileName);
    return new Promise((resolve, reject) => {
      fs.unlink(filePath, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
}

module.exports = new FileService();

================
File: src/services/MediaService.js
================
const AWS = require('aws-sdk');
const path = require('path');
const sharp = require('sharp');
const { v4: uuid } = require('uuid');

class MediaService {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });
    this.bucketName = process.env.AWS_BUCKET_NAME;
  }

  async uploadPhoto(file, folder = 'photos') {
    try {
      // Processa a imagem com sharp
      const processedImage = await sharp(file.buffer)
        .resize(1200, 1200, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({ quality: 80 })
        .toBuffer();

      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;

      const uploadParams = {
        Bucket: this.bucketName,
        Key: fileName,
        Body: processedImage,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(uploadParams).promise();

      return {
        url: result.Location,
        key: fileName
      };
    } catch (error) {
      console.error('Erro no upload da foto:', error);
      throw new Error('Falha no upload da foto');
    }
  }

  async uploadFile(file, folder = 'attachments') {
    try {
      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;

      const uploadParams = {
        Bucket: this.bucketName,
        Key: fileName,
        Body: file.buffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(uploadParams).promise();

      return {
        url: result.Location,
        key: fileName,
        name: file.originalname,
        type: file.mimetype
      };
    } catch (error) {
      console.error('Erro no upload do arquivo:', error);
      throw new Error('Falha no upload do arquivo');
    }
  }

  async deleteFile(key) {
    try {
      const deleteParams = {
        Bucket: this.bucketName,
        Key: key
      };

      await this.s3.deleteObject(deleteParams).promise();
    } catch (error) {
      console.error('Erro ao deletar arquivo:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async getSignedUrl(key, expirationInSeconds = 3600) {
    try {
      const params = {
        Bucket: this.bucketName,
        Key: key,
        Expires: expirationInSeconds
      };

      return await this.s3.getSignedUrlPromise('getObject', params);
    } catch (error) {
      console.error('Erro ao gerar URL assinada:', error);
      throw new Error('Falha ao gerar URL de acesso');
    }
  }
}

module.exports = new MediaService();

================
File: src/services/NotificationService.js
================
const AWS = require('aws-sdk');
const nodemailer = require('nodemailer');
const cron = require('node-cron');
const {Equipment} = require('../models/Equipment');
const {MaintenanceHistory} = require('../models/MaintenanceHistory')
const {User} = require('../models/User');
const { Op } = require('sequelize');
const logger = require('../utils/logger');

class NotificationService {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });

    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });

    // Inicia os jobs de verificação
    this.initializeJobs();
  }

  initializeJobs() {
    // Verifica manutenções pendentes diariamente às 8h
    cron.schedule('0 8 * * *', () => {
      this.checkPendingMaintenances();
    });

    // Verifica equipamentos com manutenções frequentes semanalmente
    cron.schedule('0 9 * * 1', () => {
      this.checkFrequentMaintenances();
    });
  }

  async uploadFile(file, folder = 'general') {
    try {
      const fileName = `${folder}/${Date.now()}-${file.originalname}`;
      
      const params = {
        Bucket: process.env.AWS_BUCKET_NAME,
        Key: fileName,
        Body: file.buffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(params).promise();
      return result.Location;
    } catch (error) {
      logger.error('Erro no upload para S3:', error);
      throw new Error('Falha no upload do arquivo');
    }
  }

  async deleteFile(fileUrl) {
    try {
      const key = fileUrl.split(`${process.env.AWS_BUCKET_NAME}/`)[1];
      
      await this.s3.deleteObject({
        Bucket: process.env.AWS_BUCKET_NAME,
        Key: key
      }).promise();
      
      return true;
    } catch (error) {
      logger.error('Erro ao deletar arquivo do S3:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async checkPendingMaintenances() {
    try {
      const today = new Date();
      const maintenances = await MaintenanceHistory.findAll({
        where: {
          status: 'pending',
          scheduled_for: {
            [Op.lte]: today
          }
        },
        include: [
          {
            model: Equipment,
            attributes: ['name', 'code', 'department']
          }
        ]
      });

      if (maintenances.length > 0) {
        // Busca administradores
        const admins = await User.findAll({
          where: { role: 'admin' }
        });

        // Envia notificações
        for (const admin of admins) {
          await this.sendPendingMaintenanceEmail(admin, maintenances);
        }
      }
    } catch (error) {
      logger.error('Erro ao verificar manutenções pendentes:', error);
    }
  }

  async checkFrequentMaintenances() {
    try {
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      // Busca equipamentos com mais de 3 manutenções nos últimos 30 dias
      const equipments = await Equipment.findAll({
        include: [{
          model: MaintenanceHistory,
          where: {
            created_at: {
              [Op.gte]: thirtyDaysAgo
            }
          }
        }],
        having: sequelize.literal('COUNT(Maintenances.id) > 3'),
        group: ['Equipment.id']
      });

      if (equipments.length > 0) {
        const admins = await User.findAll({ where: { role: 'admin' } });
        for (const admin of admins) {
          await this.sendFrequentMaintenanceAlert(admin, equipments);
        }
      }
    } catch (error) {
      logger.error('Erro ao verificar manutenções frequentes:', error);
    }
  }

  async sendPendingMaintenanceEmail(user, maintenances) {
    const mailOptions = {
      from: process.env.SMTP_FROM,
      to: user.email,
      subject: 'Manutenções Pendentes - Atenção Necessária',
      html: `
        <h2>Manutenções Pendentes</h2>
        <p>As seguintes manutenções estão pendentes e requerem atenção:</p>
        <ul>
          ${maintenances.map(m => `
            <li>
              <strong>${m.Equipment.name}</strong> (${m.Equipment.code})<br>
              Departamento: ${m.Equipment.department}<br>
              Agendado para: ${m.scheduled_for.toLocaleDateString()}
            </li>
          `).join('')}
        </ul>
      `
    };

    await this.transporter.sendMail(mailOptions);
  }

  async sendFrequentMaintenanceAlert(user, equipments) {
    const mailOptions = {
      from: process.env.SMTP_FROM,
      to: user.email,
      subject: 'Alerta - Equipamentos com Manutenções Frequentes',
      html: `
        <h2>Equipamentos com Manutenções Frequentes</h2>
        <p>Os seguintes equipamentos apresentaram mais de 3 manutenções nos últimos 30 dias:</p>
        <ul>
          ${equipments.map(e => `
            <li>
              <strong>${e.name}</strong> (${e.code})<br>
              Departamento: ${e.department}<br>
              Total de manutenções: ${e.Maintenances.length}
            </li>
          `).join('')}
        </ul>
      `
    };

    await this.transporter.sendMail(mailOptions);
  }
}

module.exports = new NotificationService();

================
File: src/services/PDFService.js
================
const PDFDocument = require('pdfkit');
const { format } = require('date-fns');
const ptBR = require('date-fns/locale/pt-BR');

class PDFService {
  createMaintenanceReport(equipment, maintenances) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Cabeçalho
        doc.fontSize(20).text('Relatório de Manutenções', { align: 'center' });
        doc.moveDown();

        // Informações do Equipamento
        doc.fontSize(16).text('Dados do Equipamento');
        doc.fontSize(12)
           .text(`Nome: ${equipment.name}`)
           .text(`Código: ${equipment.code}`)
           .text(`Departamento: ${equipment.department}`)
           .text(`Status: ${equipment.status}`);
        
        doc.moveDown();

        // Resumo
        const totalCost = maintenances.reduce((sum, m) => sum + (m.cost || 0), 0);
        doc.fontSize(16).text('Resumo');
        doc.fontSize(12)
           .text(`Total de Manutenções: ${maintenances.length}`)
           .text(`Custo Total: R$ ${totalCost.toFixed(2)}`);
        
        doc.moveDown();

        // Lista de Manutenções
        doc.fontSize(16).text('Histórico de Manutenções');
        doc.moveDown();

        maintenances.forEach(maintenance => {
          doc.fontSize(12)
             .text(`Data: ${format(new Date(maintenance.maintenance_date), 'dd/MM/yyyy')}`)
             .text(`Tipo: ${maintenance.type}`)
             .text(`Descrição: ${maintenance.description}`)
             .text(`Custo: R$ ${maintenance.cost?.toFixed(2) || '0,00'}`)
             .text(`Técnico: ${maintenance.technician?.name || 'Não informado'}`);
          
          if (maintenance.parts_replaced?.length > 0) {
            doc.text('Peças Substituídas:');
            maintenance.parts_replaced.forEach(part => {
              doc.text(`  - ${part.name}: ${part.quantity} unidade(s)`);
            });
          }

          doc.moveDown();
        });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  createEquipmentReport(equipments) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Cabeçalho
        doc.fontSize(20).text('Relatório de Equipamentos', { align: 'center' });
        doc.moveDown();

        // Resumo por Departamento
        const departmentSummary = equipments.reduce((acc, eq) => {
          acc[eq.department] = (acc[eq.department] || 0) + 1;
          return acc;
        }, {});

        doc.fontSize(16).text('Resumo por Departamento');
        Object.entries(departmentSummary).forEach(([dept, count]) => {
          doc.fontSize(12).text(`${dept}: ${count} equipamento(s)`);
        });
        
        doc.moveDown();

        // Lista de Equipamentos
        doc.fontSize(16).text('Lista de Equipamentos');
        doc.moveDown();

        equipments.forEach(equipment => {
          doc.fontSize(12)
             .text(`Nome: ${equipment.name}`)
             .text(`Código: ${equipment.code}`)
             .text(`Departamento: ${equipment.department}`)
             .text(`Status: ${equipment.status}`)
             .text(`Última Manutenção: ${equipment.last_maintenance ? 
               format(new Date(equipment.last_maintenance), 'dd/MM/yyyy') : 
               'Nunca realizada'}`);
          
          doc.moveDown();
        });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }
}

module.exports = new PDFService();

================
File: src/services/PushNotificationService.js
================
import * as Notifications from 'expo-notifications';
import * as Device from 'expo-device';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Platform } from 'react-native';

class PushNotificationService {
  constructor() {
    this.configure();
  }

  async configure() {
    if (Device.isDevice) {
      const { status: existingStatus } = await Notifications.getPermissionsAsync();
      let finalStatus = existingStatus;
      
      if (existingStatus !== 'granted') {
        const { status } = await Notifications.requestPermissionsAsync();
        finalStatus = status;
      }

      if (finalStatus !== 'granted') {
        console.log('Permissão para notificações não concedida!');
        return;
      }

      const token = await this.getDevicePushToken();
      if (token) {
        await this.registerDeviceToken(token);
      }
    }

    // Configuração das notificações
    Notifications.setNotificationHandler({
      handleNotification: async () => ({
        shouldShowAlert: true,
        shouldPlaySound: true,
        shouldSetBadge: true,
      }),
    });
  }

  async getDevicePushToken() {
    try {
      const token = await Notifications.getExpoPushTokenAsync({
        experienceId: '@your-org/your-app'
      });
      return token.data;
    } catch (error) {
      console.error('Erro ao obter token:', error);
      return null;
    }
  }

  async registerDeviceToken(token) {
    try {
      const userId = await AsyncStorage.getItem('userId');
      if (!userId) return;

      await fetch(`${process.env.API_URL}/users/push-token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${await AsyncStorage.getItem('token')}`
        },
        body: JSON.stringify({
          token,
          device: Platform.OS,
          userId
        })
      });
    } catch (error) {
      console.error('Erro ao registrar token:', error);
    }
  }

  async scheduleLocalNotification(title, body, data = {}, trigger = null) {
    try {
      const notificationId = await Notifications.scheduleNotificationAsync({
        content: {
          title,
          body,
          data,
          sound: true,
          priority: 'high',
        },
        trigger: trigger || null,
      });
      return notificationId;
    } catch (error) {
      console.error('Erro ao agendar notificação:', error);
    }
  }

  async cancelNotification(notificationId) {
    try {
      await Notifications.cancelScheduledNotificationAsync(notificationId);
    } catch (error) {
      console.error('Erro ao cancelar notificação:', error);
    }
  }

  async setBadgeCount(count) {
    try {
      await Notifications.setBadgeCountAsync(count);
    } catch (error) {
      console.error('Erro ao definir badge:', error);
    }
  }

  addNotificationReceivedListener(callback) {
    return Notifications.addNotificationReceivedListener(callback);
  }

  addNotificationResponseReceivedListener(callback) {
    return Notifications.addNotificationResponseReceivedListener(callback);
  }

  removeNotificationSubscription(subscription) {
    subscription.remove();
  }

  // Helpers para tipos específicos de notificações
  async scheduleMaintenance(maintenance) {
    const scheduledDate = new Date(maintenance.scheduled_for);
    
    // Notificação 24h antes
    await this.scheduleLocalNotification(
      'Manutenção Agendada',
      `Manutenção do equipamento ${maintenance.equipment.name} amanhã`,
      { maintenanceId: maintenance.id },
      {
        date: new Date(scheduledDate.getTime() - 24 * 60 * 60 * 1000)
      }
    );

    // Notificação 1h antes
    await this.scheduleLocalNotification(
      'Manutenção em Breve',
      `Manutenção do equipamento ${maintenance.equipment.name} em 1 hora`,
      { maintenanceId: maintenance.id },
      {
        date: new Date(scheduledDate.getTime() - 60 * 60 * 1000)
      }
    );
  }

  async notifyMaintenanceComplete(maintenance) {
    await this.scheduleLocalNotification(
      'Manutenção Concluída',
      `A manutenção do equipamento ${maintenance.equipment.name} foi finalizada`,
      { maintenanceId: maintenance.id }
    );
  }

  async notifyMaintenanceOverdue(maintenance) {
    await this.scheduleLocalNotification(
      'Manutenção Atrasada',
      `A manutenção do equipamento ${maintenance.equipment.name} está atrasada`,
      { maintenanceId: maintenance.id }
    );
  }
}

export default new PushNotificationService();

================
File: src/services/QRCodeService.js
================
const QRCode = require('qrcode');
const { v4: uuid } = require('uuid');
const S3Service = require('./S3Service');
const logger = require('../utils/logger');

class QRCodeService {
  constructor() {
    this.baseUrl = process.env.APP_URL;
    this.defaultOptions = {
      errorCorrectionLevel: 'H',
      type: 'svg',
      margin: 1,
      color: {
        dark: '#000000',
        light: '#ffffff'
      }
    };
  }

  async generateForEquipment(equipment) {
    try {
      const data = {
        id: equipment.id,
        code: equipment.code,
        type: 'equipment',
        timestamp: new Date().toISOString()
      };

      const qrUrl = `${this.baseUrl}/equipment/scan/${equipment.id}`;
      
      // Gera o QR Code como SVG
      const qrSvg = await QRCode.toString(qrUrl, {
        ...this.defaultOptions,
        width: 300
      });

      // Converte SVG para Buffer para upload
      const qrBuffer = Buffer.from(qrSvg);

      // Upload para S3
      const fileName = `qrcodes/equipment/${equipment.id}-${uuid()}.svg`;
      const uploaded = await S3Service.uploadFile({
        buffer: qrBuffer,
        originalname: fileName,
        mimetype: 'image/svg+xml'
      }, 'qrcodes');

      return {
        url: uploaded.url,
        key: uploaded.key,
        data: qrUrl
      };

    } catch (error) {
      logger.error('Erro ao gerar QR Code:', error);
      throw new Error('Falha ao gerar QR Code');
    }
  }

  async generateBatch(equipments) {
    try {
      const results = await Promise.all(
        equipments.map(equipment => this.generateForEquipment(equipment))
      );

      return results;
    } catch (error) {
      logger.error('Erro ao gerar lote de QR Codes:', error);
      throw new Error('Falha ao gerar QR Codes em lote');
    }
  }

  async generatePrintableSheet(equipments) {
    try {
      const qrCodes = await this.generateBatch(equipments);

      // Gera HTML para impressão
      const html = this.generatePrintTemplate(equipments, qrCodes);

      // Converte HTML para PDF
      const pdf = await this.convertToPDF(html);

      // Upload do PDF para S3
      const fileName = `qrcodes/sheets/batch-${uuid()}.pdf`;
      const uploaded = await S3Service.uploadFile({
        buffer: pdf,
        originalname: fileName,
        mimetype: 'application/pdf'
      }, 'qrcodes');

      return uploaded.url;

    } catch (error) {
      logger.error('Erro ao gerar folha de QR Codes:', error);
      throw new Error('Falha ao gerar folha de QR Codes');
    }
  }

  generatePrintTemplate(equipments, qrCodes) {
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <style>
            .qr-container {
              display: inline-block;
              margin: 10px;
              padding: 15px;
              border: 1px solid #ccc;
              text-align: center;
            }
            .qr-code {
              width: 200px;
              height: 200px;
            }
            .qr-info {
              margin-top: 10px;
              font-family: Arial, sans-serif;
            }
          </style>
        </head>
        <body>
          ${qrCodes.map((qr, index) => `
            <div class="qr-container">
              <img src="${qr.url}" class="qr-code"/>
              <div class="qr-info">
                <strong>${equipments[index].name}</strong><br/>
                Código: ${equipments[index].code}
              </div>
            </div>
          `).join('')}
        </body>
      </html>
    `;
  }

  validateQRCode(qrData) {
    try {
      // Verifica se o QR Code é válido e pertence ao sistema
      const url = new URL(qrData);
      return url.origin === this.baseUrl && url.pathname.includes('/equipment/scan/');
    } catch (error) {
      return false;
    }
  }
}

module.exports = new QRCodeService();

================
File: src/services/ReportService.js
================
const ExcelJS = require('exceljs');
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const { Op } = require('sequelize');

class ReportService {
  async generateMaintenanceReport(startDate, endDate, department = null) {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Manutenções');

    // Define cabeçalhos
    worksheet.columns = [
      { header: 'Equipamento', key: 'equipment', width: 20 },
      { header: 'Código', key: 'code', width: 15 },
      { header: 'Departamento', key: 'department', width: 15 },
      { header: 'Tipo', key: 'type', width: 15 },
      { header: 'Data', key: 'date', width: 15 },
      { header: 'Status', key: 'status', width: 15 },
      { header: 'Técnico', key: 'technician', width: 20 },
      { header: 'Custo', key: 'cost', width: 15 }
    ];

    // Aplica estilo aos cabeçalhos
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' }
    };

    // Busca dados
    const query = {
      where: {
        created_at: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: Equipment,
          ...(department && {
            where: { department }
          })
        },
        {
          model: User,
          as: 'technician',
          attributes: ['name']
        }
      ]
    };

    const maintenances = await Maintenance.findAll(query);

    // Adiciona dados
    maintenances.forEach(maintenance => {
      worksheet.addRow({
        equipment: maintenance.Equipment.name,
        code: maintenance.Equipment.code,
        department: maintenance.Equipment.department,
        type: maintenance.type,
        date: maintenance.maintenance_date.toLocaleDateString(),
        status: maintenance.status,
        technician: maintenance.technician?.name || 'N/A',
        cost: maintenance.cost || 0
      });
    });

    // Aplica formatação condicional para status
    worksheet.addConditionalFormatting({
      ref: 'F2:F1000',
      rules: [
        {
          type: 'cellIs',
          operator: 'equal',
          formulae: ['"completed"'],
          style: { fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FF90EE90' } } }
        },
        {
          type: 'cellIs',
          operator: 'equal',
          formulae: ['"pending"'],
          style: { fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FFFFCCCB' } } }
        }
      ]
    });

    // Formata coluna de custo
    worksheet.getColumn('cost').numFmt = '"R$ "#,##0.00';

    // Adiciona totais
    const lastRow = worksheet.rowCount + 2;
    worksheet.addRow(['Total de Manutenções:', maintenances.length]);
    worksheet.addRow([
      'Custo Total:',
      {
        formula: `SUM(H2:H${worksheet.rowCount-2})`,
        numFmt: '"R$ "#,##0.00'
      }
    ]);

    // Retorna o buffer
    return await workbook.xlsx.writeBuffer();
  }

  async generateEquipmentReport() {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Equipamentos');

    worksheet.columns = [
      { header: 'Nome', key: 'name', width: 20 },
      { header: 'Código', key: 'code', width: 15 },
      { header: 'Departamento', key: 'department', width: 15 },
      { header: 'Status', key: 'status', width: 15 },
      { header: 'Total Manutenções', key: 'maintenances', width: 18 },
      { header: 'Última Manutenção', key: 'lastMaintenance', width: 18 },
      { header: 'Custo Total', key: 'totalCost', width: 15 }
    ];

    const equipments = await Equipment.findAll({
      include: [{
        model: Maintenance,
        attributes: ['maintenance_date', 'cost']
      }]
    });

    equipments.forEach(equipment => {
      worksheet.addRow({
        name: equipment.name,
        code: equipment.code,
        department: equipment.department,
        status: equipment.status,
        maintenances: equipment.Maintenances.length,
        lastMaintenance: equipment.Maintenances.length ? 
          new Date(Math.max(...equipment.Maintenances.map(m => m.maintenance_date))).toLocaleDateString() : 
          'N/A',
        totalCost: equipment.Maintenances.reduce((sum, m) => sum + (m.cost || 0), 0)
      });
    });

    // Estilização e formatação
    worksheet.getRow(1).font = { bold: true };
    worksheet.getColumn('totalCost').numFmt = '"R$ "#,##0.00';

    return await workbook.xlsx.writeBuffer();
  }
}

module.exports = new ReportService();

================
File: src/services/S3Service.js
================
const AWS = require('aws-sdk');
const sharp = require('sharp');
const mime = require('mime-types');
const path = require('path');
const { v4: uuid } = require('uuid');
const logger = require('../utils/logger');

class S3Service {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });
    this.bucket = process.env.AWS_BUCKET_NAME;
    this.allowedMimes = [
      'image/jpeg',
      'image/png',
      'image/webp',
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
  }

  // para upload
  async uploadFile(file, folder = 'general') {
    try {
      if (!this.allowedMimes.includes(file.mimetype)) {
        throw new Error('Tipo de arquivo não permitido');
      }

      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;
      let processedBuffer = file.buffer;

      // Processa imagens antes do upload
      if (file.mimetype.startsWith('image/')) {
        processedBuffer = await this.processImage(file.buffer);
      }

      const params = {
        Bucket: this.bucket,
        Key: fileName,
        Body: processedBuffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(params).promise();

      return {
        url: result.Location,
        key: fileName,
        type: file.mimetype,
        size: processedBuffer.length
      };

    } catch (error) {
      logger.error('Erro no upload para S3:', error);
      throw new Error('Falha ao fazer upload do arquivo');
    }
  }

  async processImage(buffer) {
    try {
      return await sharp(buffer)
        .resize(1200, 1200, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({
          quality: 80,
          progressive: true
        })
        .toBuffer();
    } catch (error) {
      logger.error('Erro ao processar imagem:', error);
      throw new Error('Falha ao processar imagem');
    }
  }

  async deleteFile(key) {
    try {
      await this.s3.deleteObject({
        Bucket: this.bucket,
        Key: key
      }).promise();

      return true;
    } catch (error) {
      logger.error('Erro ao deletar arquivo do S3:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async generateSignedUrl(key, expiresIn = 3600) {
    try {
      return await this.s3.getSignedUrlPromise('getObject', {
        Bucket: this.bucket,
        Key: key,
        Expires: expiresIn
      });
    } catch (error) {
      logger.error('Erro ao gerar URL assinada:', error);
      throw new Error('Falha ao gerar URL de acesso');
    }
  }

  async moveFile(oldKey, newKey) {
    try {
      // Copia o arquivo para novo local
      await this.s3.copyObject({
        Bucket: this.bucket,
        CopySource: `${this.bucket}/${oldKey}`,
        Key: newKey,
        ACL: 'public-read'
      }).promise();

      // Remove arquivo original
      await this.deleteFile(oldKey);

      return true;
    } catch (error) {
      logger.error('Erro ao mover arquivo:', error);
      throw new Error('Falha ao mover arquivo');
    }
  }
}

module.exports = new S3Service();

================
File: src/services/WebSocketService.js
================
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');
const http = require('http');

class WebSocketService {
  constructor(server) {
    this.wss = new WebSocket.Server({ server });
    this.clients = new Map(); // Map para armazenar conexões de clientes
    this.initialize();
  }

  initialize() {
    this.wss.on('connection', async (ws, req) => {
      try {
        // Autenticação do WebSocket
        const token = this.extractToken(req);
        if (!token) {
          ws.close(4001, 'Unauthorized');
          return;
        }

        const user = await this.authenticateToken(token);
        if (!user) {
          ws.close(4001, 'Invalid token');
          return;
        }

        // Armazena a conexão do cliente
        this.clients.set(user.id, {
          ws,
          user
        });

        // Setup de heartbeat
        ws.isAlive = true;
        ws.on('pong', () => {
          ws.isAlive = true;
        });

        // Listener de mensagens
        ws.on('message', async (message) => {
          try {
            await this.handleMessage(user.id, JSON.parse(message));
          } catch (error) {
            console.error('Erro ao processar mensagem:', error);
            this.sendError(ws, error.message);
          }
        });

        // Listener de fechamento
        ws.on('close', () => {
          this.clients.delete(user.id);
        });

        // Envia confirmação de conexão
        this.sendToClient(user.id, {
          type: 'CONNECTION_ESTABLISHED',
          data: {
            userId: user.id,
            timestamp: new Date()
          }
        });

      } catch (error) {
        console.error('Erro na conexão WebSocket:', error);
        ws.close(4000, 'Internal server error');
      }
    });

    // Configuração do heartbeat
    setInterval(() => {
      this.wss.clients.forEach((ws) => {
        if (!ws.isAlive) {
          return ws.terminate();
        }
        ws.isAlive = false;
        ws.ping(() => {});
      });
    }, 30000);
  }

  async handleMessage(userId, message) {
    const { type, data } = message;

    switch (type) {
      case 'MAINTENANCE_UPDATE':
        await this.handleMaintenanceUpdate(userId, data);
        break;

      case 'EQUIPMENT_STATUS_CHANGE':
        await this.handleEquipmentStatusChange(userId, data);
        break;

      case 'JOIN_EQUIPMENT_ROOM':
        await this.handleJoinEquipmentRoom(userId, data);
        break;

      default:
        throw new Error('Tipo de mensagem não suportado');
    }
  }

  async handleMaintenanceUpdate(userId, data) {
    // Notifica todos os admins e o técnico responsável
    const notification = {
      type: 'MAINTENANCE_UPDATED',
      data: {
        maintenanceId: data.maintenanceId,
        status: data.status,
        updatedBy: userId,
        timestamp: new Date()
      }
    };

    await this.notifyAdmins(notification);
    if (data.technicianId) {
      this.sendToClient(data.technicianId, notification);
    }
  }

  async handleEquipmentStatusChange(userId, data) {
    const notification = {
      type: 'EQUIPMENT_STATUS_CHANGED',
      data: {
        equipmentId: data.equipmentId,
        status: data.status,
        changedBy: userId,
        timestamp: new Date()
      }
    };

    await this.notifyDepartment(data.departmentId, notification);
  }

  async handleJoinEquipmentRoom(userId, data) {
    const client = this.clients.get(userId);
    if (client) {
      client.equipmentRooms = client.equipmentRooms || new Set();
      client.equipmentRooms.add(data.equipmentId);
    }
  }

  // Envia mensagem para um cliente específico
  sendToClient(userId, message) {
    const client = this.clients.get(userId);
    if (client && client.ws.readyState === WebSocket.OPEN) {
      client.ws.send(JSON.stringify(message));
    }
  }

  // Envia mensagem para todos os admins
  async notifyAdmins(message) {
    this.clients.forEach((client) => {
      if (client.user.role === 'admin' && client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(JSON.stringify(message));
      }
    });
  }

  // Envia mensagem para todos os usuários de um departamento
  async notifyDepartment(departmentId, message) {
    this.clients.forEach((client) => {
      if (client.user.departmentId === departmentId && client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(JSON.stringify(message));
      }
    });
  }

  // Envia mensagem de erro para um cliente
  sendError(ws, message) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'ERROR',
        data: { message }
      }));
    }
  }

  // Extrai token do request
  extractToken(req) {
    const auth = req.headers.authorization;
    if (!auth) return null;
    return auth.replace('Bearer ', '');
  }

  // Autentica o token
  async authenticateToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findByPk(decoded.id);
      return user;
    } catch (error) {
      return null;
    }
  }

  // Broadcast para todos os clientes conectados
  broadcast(message) {
    this.wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(message));
      }
    });
  }
}

module.exports = WebSocketService;

================
File: src/utils/auth.js
================
const jwt = require('jsonwebtoken');

const generateToken = (payload) => {
  return jwt.sign(payload, process.env.JWT_SECRET, {
    expiresIn: '7d', // Token expira em 7 dias
  });
};

const verifyToken = (token) => {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch (error) {
    return null;
  }
};

const generateRefreshToken = (payload) => {
  return jwt.sign(payload, process.env.REFRESH_TOKEN_SECRET, {
    expiresIn: '30d', // Refresh token expira em 30 dias
  });
};

module.exports = {
  generateToken,
  verifyToken,
  generateRefreshToken
};

================
File: src/utils/logger.js
================
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');
const path = require('path');

const logDir = 'logs';
const { combine, timestamp, printf, colorize, errors } = winston.format;

const customFormat = printf(({ level, message, timestamp, ...metadata }) => {
  let msg = `${timestamp} [${level}] : ${message}`;
  
  if (Object.keys(metadata).length > 0) {
    msg += ` ${JSON.stringify(metadata)}`;
  }
  
  return msg;
});

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: combine(
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    errors({ stack: true }),
    customFormat
  ),
  transports: [
    // Logs de erro
    new DailyRotateFile({
      filename: path.join(logDir, 'error-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      level: 'error',
      maxSize: '20m',
      maxFiles: '14d',
      zippedArchive: true
    }),

    // Logs gerais
    new DailyRotateFile({
      filename: path.join(logDir, 'combined-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d',
      zippedArchive: true
    })
  ]
});

// Adiciona logs no console em desenvolvimento
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: combine(
      colorize(),
      customFormat
    )
  }));
}

module.exports = logger;

================
File: src/validations/schemas.js
================
const yup = require('yup');

const schemas = {
  loginSchema: yup.object().shape({
    email: yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    password: yup.string()
      .required('Senha é obrigatória')
      .min(6, 'Senha deve ter no mínimo 6 caracteres')
  }),

  equipmentSchema: yup.object().shape({
    name: yup.string()
      .required('Nome é obrigatório')
      .min(3, 'Nome deve ter no mínimo 3 caracteres'),
    code: yup.string()
      .required('Código é obrigatório')
      .matches(/^[A-Za-z0-9-]+$/, 'Código deve conter apenas letras, números e hífen'),
    serial_number: yup.string(),
    department: yup.string()
      .required('Departamento é obrigatório'),
    description: yup.string()
      .max(500, 'Descrição deve ter no máximo 500 caracteres'),
    maintenance_frequency: yup.number()
      .min(1, 'Frequência deve ser maior que 0')
  }),

  serviceOrderSchema: yup.object().shape({
    equipment_id: yup.number()
      .required('Equipamento é obrigatório'),
    description: yup.string()
      .required('Descrição é obrigatória')
      .min(10, 'Descrição deve ter no mínimo 10 caracteres'),
    type: yup.string()
      .oneOf(['preventive', 'corrective', 'predictive'], 'Tipo inválido')
      .required('Tipo é obrigatório'),
    priority: yup.string()
      .oneOf(['low', 'medium', 'high', 'critical'], 'Prioridade inválida')
      .required('Prioridade é obrigatória'),
    scheduled_for: yup.date()
      .required('Data de agendamento é obrigatória')
  }),

  serviceOrderUpdateSchema: yup.object().shape({
    status: yup.string()
      .oneOf(['pending', 'in_progress', 'completed', 'cancelled'], 'Status inválido')
      .required('Status é obrigatório'),
    notes: yup.string(),
    completion_notes: yup.string()
      .when('status', {
        is: 'completed',
        then: yup.string().required('Notas de conclusão são obrigatórias')
      })
  }),

  maintenanceSchema: yup.object().shape({
    equipment_id: yup.number()
      .required('Equipamento é obrigatório'),
    description: yup.string()
      .required('Descrição é obrigatória')
      .min(10, 'Descrição deve ter no mínimo 10 caracteres'),
    type: yup.string()
      .oneOf(['preventive', 'corrective', 'predictive'], 'Tipo inválido')
      .required('Tipo é obrigatório'),
    cost: yup.number()
      .min(0, 'Custo não pode ser negativo'),
    notes: yup.string()
      .max(1000, 'Observações devem ter no máximo 1000 caracteres')
  }),

  maintenanceUpdateSchema: yup.object().shape({
    status: yup.string()
      .oneOf(['pending', 'in_progress', 'completed'], 'Status inválido')
      .required('Status é obrigatório'),
    notes: yup.string(),
    cost: yup.number()
      .min(0, 'Custo não pode ser negativo'),
    completion_notes: yup.string()
      .when('status', {
        is: 'completed',
        then: yup.string().required('Notas de conclusão são obrigatórias')
      })
  }),

  userSchema: yup.object().shape({
    name: yup.string()
      .required('Nome é obrigatório')
      .min(3, 'Nome deve ter no mínimo 3 caracteres'),
    email: yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    password: yup.string()
      .required('Senha é obrigatória')
      .min(6, 'Senha deve ter no mínimo 6 caracteres'),
    role: yup.string()
      .oneOf(['admin', 'manager', 'technician'], 'Função inválida')
      .required('Função é obrigatória'),
    department: yup.string()
      .required('Departamento é obrigatório')
  }),

  userUpdateSchema: yup.object().shape({
    name: yup.string()
      .min(3, 'Nome deve ter no mínimo 3 caracteres'),
    email: yup.string()
      .email('Email inválido'),
    password: yup.string()
      .min(6, 'Senha deve ter no mínimo 6 caracteres'),
    role: yup.string()
      .oneOf(['admin', 'manager', 'technician'], 'Função inválida'),
    department: yup.string()
  })
};

module.exports = schemas;

================
File: src/views/emails/maintenance-complete.ejs
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      background-color: #f8f9fa;
      padding: 20px;
      text-align: center;
      border-bottom: 3px solid #007bff;
    }
    .content {
      padding: 20px;
    }
    .footer {
      text-align: center;
      padding: 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>Manutenção Concluída</h2>
    </div>
    <div class="content">
      <p>Olá <%= userName %>,</p>
      
      <p>A manutenção do equipamento foi concluída:</p>
      
      <ul>
        <li><strong>Equipamento:</strong> <%= equipmentName %></li>
        <li><strong>Código:</strong> <%= equipmentCode %></li>
        <li><strong>Data Conclusão:</strong> <%= completedDate.toLocaleDateString() %></li>
        <li><strong>Tipo:</strong> <%= maintenanceType %></li>
      </ul>

      <p><strong>Detalhes da Manutenção:</strong></p>
      <p><%= description %></p>
    </div>
    <div class="footer">
      <p>Esta é uma mensagem automática, não responda este email.</p>
    </div>
  </div>
</body>
</html>

================
File: src/views/emails/maintenance-notification.ejs
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      background-color: #f8f9fa;
      padding: 20px;
      text-align: center;
      border-bottom: 3px solid #007bff;
    }
    .content {
      padding: 20px;
    }
    .footer {
      text-align: center;
      padding: 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>Manutenção Agendada</h2>
    </div>
    <div class="content">
      <p>Olá <%= userName %>,</p>
      
      <p>Uma nova manutenção foi agendada para o equipamento:</p>
      
      <ul>
        <li><strong>Equipamento:</strong> <%= equipmentName %></li>
        <li><strong>Código:</strong> <%= equipmentCode %></li>
        <li><strong>Data Agendada:</strong> <%= maintenanceDate.toLocaleDateString() %></li>
        <li><strong>Tipo:</strong> <%= maintenanceType %></li>
      </ul>

      <p><strong>Descrição:</strong></p>
      <p><%= description %></p>
    </div>
    <div class="footer">
      <p>Esta é uma mensagem automática, não responda este email.</p>
    </div>
  </div>
</body>
</html>

================
File: src/websocket/WebSocketManager.js
================
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');
const logger = require('../utils/logger');

class WebSocketManager {
  constructor(server) {
    this.wss = new WebSocket.Server({ server });
    this.clients = new Map();
    this.rooms = new Map();
    
    this.initialize();
  }

  initialize() {
    this.wss.on('connection', async (ws, req) => {
      try {
        // Autenticação
        const token = this.extractToken(req);
        if (!token) {
          ws.close(4001, 'Token não fornecido');
          return;
        }

        const user = await this.verifyToken(token);
        if (!user) {
          ws.close(4001, 'Token inválido');
          return;
        }

        // Registra o cliente
        const clientId = user.id;
        this.clients.set(clientId, { ws, user });

        // Setup de heartbeat
        ws.isAlive = true;
        ws.on('pong', () => { ws.isAlive = true; });

        // Manipuladores de eventos
        ws.on('message', async (message) => {
          try {
            const data = JSON.parse(message);
            await this.handleMessage(clientId, data);
          } catch (error) {
            logger.error('Erro ao processar mensagem:', error);
            this.sendError(ws, error.message);
          }
        });

        ws.on('close', () => {
          this.handleDisconnect(clientId);
        });

        // Notifica conexão bem-sucedida
        this.sendToClient(clientId, {
          type: 'CONNECTED',
          data: { userId: clientId }
        });

      } catch (error) {
        logger.error('Erro na conexão WebSocket:', error);
        ws.close(4000, 'Erro interno');
      }
    });

    // Heartbeat interval
    setInterval(() => {
      this.wss.clients.forEach((ws) => {
        if (!ws.isAlive) return ws.terminate();
        ws.isAlive = false;
        ws.ping();
      });
    }, 30000);
  }

  async handleMessage(clientId, message) {
    const { type, data } = message;

    switch (type) {
      case 'JOIN_ROOM':
        await this.handleJoinRoom(clientId, data.roomId);
        break;

      case 'LEAVE_ROOM':
        await this.handleLeaveRoom(clientId, data.roomId);
        break;

      case 'EQUIPMENT_UPDATE':
        await this.handleEquipmentUpdate(clientId, data);
        break;

      case 'MAINTENANCE_STATUS':
        await this.handleMaintenanceStatus(clientId, data);
        break;

      default:
        logger.warn('Tipo de mensagem desconhecido:', type);
        break;
    }
  }

  async handleJoinRoom(clientId, roomId) {
    if (!this.rooms.has(roomId)) {
      this.rooms.set(roomId, new Set());
    }
    this.rooms.get(roomId).add(clientId);
  }

  async handleLeaveRoom(clientId, roomId) {
    if (this.rooms.has(roomId)) {
      this.rooms.get(roomId).delete(clientId);
    }
  }

  async handleEquipmentUpdate(clientId, data) {
    const { equipmentId, status, changes } = data;
    
    // Notifica todos na sala do equipamento
    this.broadcastToRoom(`equipment_${equipmentId}`, {
      type: 'EQUIPMENT_UPDATED',
      data: {
        equipmentId,
        status,
        changes,
        updatedBy: clientId,
        timestamp: new Date()
      }
    });
  }

  async handleMaintenanceStatus(clientId, data) {
    const { maintenanceId, status, notes } = data;

    // Notifica interessados sobre atualização da manutenção
    this.broadcastToRoom(`maintenance_${maintenanceId}`, {
      type: 'MAINTENANCE_UPDATED',
      data: {
        maintenanceId,
        status,
        notes,
        updatedBy: clientId,
        timestamp: new Date()
      }
    });
  }

  handleDisconnect(clientId) {
    // Remove cliente de todas as salas
    this.rooms.forEach((clients, roomId) => {
      clients.delete(clientId);
    });

    // Remove cliente da lista
    this.clients.delete(clientId);
  }

  sendToClient(clientId, message) {
    const client = this.clients.get(clientId);
    if (client && client.ws.readyState === WebSocket.OPEN) {
      client.ws.send(JSON.stringify(message));
    }
  }

  broadcastToRoom(roomId, message) {
    const clients = this.rooms.get(roomId);
    if (clients) {
      clients.forEach(clientId => {
        this.sendToClient(clientId, message);
      });
    }
  }

  broadcastToAll(message) {
    this.clients.forEach((client, clientId) => {
      this.sendToClient(clientId, message);
    });
  }

  sendError(ws, message) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'ERROR',
        data: { message }
      }));
    }
  }

  extractToken(req) {
    const auth = req.headers.authorization;
    return auth ? auth.replace('Bearer ', '') : null;
  }

  async verifyToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      return await User.findByPk(decoded.id);
    } catch (error) {
      return null;
    }
  }
}

module.exports = WebSocketManager;

================
File: src/app.js
================
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const routes = require('./routes');
const errorHandler = require('./middlewares/errorHandler');
const db = require('./models');

const app = express();

// Middlewares essenciais
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cors());
app.use(helmet());
app.use(morgan('dev'));

// Rotas
app.use('/api', routes);

// Tratamento de erros (deve ser o último middleware)
app.use(errorHandler);

// Sincronização com o banco de dados
const syncDatabase = async () => {
  try {
    await db.sequelize.authenticate();
    console.log('Conexão com o banco estabelecida com sucesso.');

    if (process.env.NODE_ENV === 'development') {
      await db.sequelize.sync({ alter: true });
      console.log('Modelos sincronizados com o banco de dados.');
    }
  } catch (error) {
    console.error('Erro ao conectar com o banco:', error);
    process.exit(1);
  }
};

// Inicialização
const initializeApp = async () => {
  await syncDatabase();
  
  const PORT = process.env.PORT || 3000;
  app.listen(PORT, () => {
    console.log(`Servidor rodando na porta ${PORT}`);
    console.log(`Ambiente: ${process.env.NODE_ENV}`);
  });
};

if (require.main === module) {
  initializeApp();
}

module.exports = app;

================
File: src/index.js
================
require('dotenv').config();
const http = require('http');
const app = require('./app');
const WebSocket = require('ws');
const WebSocketManager = require('./websocket/WebSocketManager');
const logger = require('./utils/logger');
const { sequelize } = require('./models');

const server = http.createServer(app);
const wsManager = new WebSocketManager(server);

const startServer = async () => {
  try {
    // Testa conexão com banco
    await sequelize.authenticate();
    logger.info('Conexão com banco de dados estabelecida com sucesso.');

    // Sincroniza modelos com banco (em desenvolvimento)
    if (process.env.NODE_ENV === 'development') {
      await sequelize.sync({ alter: true });
      logger.info('Modelos sincronizados com o banco de dados.');
    }

    const port = process.env.PORT || 3000;
    
    server.listen(port, () => {
      logger.info(`Servidor rodando na porta ${port}`);
      logger.info(`Ambiente: ${process.env.NODE_ENV}`);
    });

  } catch (error) {
    logger.error('Erro ao iniciar servidor:', error);
    process.exit(1);
  }
};

// Tratamento de erros não capturados
process.on('uncaughtException', (error) => {
  logger.error('Erro não capturado:', error);
  process.exit(1);
});

process.on('unhandledRejection', (error) => {
  logger.error('Promise rejeitada não tratada:', error);
  process.exit(1);
});

startServer();

================
File: .sequelizerc
================
const path = require('path');

module.exports = {
  config: path.resolve('src', 'config', 'database.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'database', 'seeders'),
  'migrations-path': path.resolve('src', 'database', 'migrations'),
};

================
File: package.json
================
{
  "name": "equipment-management-backend",
  "version": "1.0.0",
  "description": "Sistema de Gerenciamento de Equipamentos - Backend",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "migrate": "sequelize db:migrate",
    "migrate:undo": "sequelize db:migrate:undo",
    "seed": "sequelize db:seed:all",
    "test": "jest"
  },
  "dependencies": {
    "@sendgrid/mail": "^7.7.0",
    "aws-sdk": "^2.1338.0",
    "bcryptjs": "^2.4.3",
    "bull": "^4.10.4",
    "cors": "^2.8.5",
    "date-fns": "^2.30.0",
    "dotenv": "^16.0.3",
    "ejs": "^3.1.9",
    "exceljs": "^4.4.0",
    "express": "^4.21.2",
    "express-async-errors": "^3.1.1",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^6.7.0",
    "express-validator": "^7.0.1",
    "helmet": "^6.2.0",
    "hpp": "^0.2.3",
    "ioredis": "^5.3.1",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "multer": "^1.4.5-lts.1",
    "node-cron": "^3.0.3",
    "nodemailer": "^6.9.7",
    "pdfkit": "^0.14.0",
    "pg": "^8.13.1",
    "pg-hstore": "^2.3.4",
    "qrcode": "^1.5.1",
    "sequelize": "^6.37.5",
    "sharp": "^0.32.0",
    "socket.io": "^4.6.1",
    "uuid": "^9.0.1",
    "winston": "^3.17.0",
    "winston-daily-rotate-file": "^4.7.1",
    "ws": "^8.14.2",
    "yup": "^1.0.2"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.10.0",
    "eslint": "^8.36.0",
    "jest": "^29.5.0",
    "nodemon": "^2.0.22",
    "sequelize-cli": "^6.6.0",
    "supertest": "^6.3.3"
  }
}

================
File: tree.js
================
const fs = require('fs');
const path = require('path');

// Função recursiva para gerar o mapa de pastas/arquivos
function generateFileStructure(dir, depth = 0) {
    let structure = '';
    const files = fs.readdirSync(dir);

    files.forEach((file) => {
        const filePath = path.join(dir, file);
        const isDirectory = fs.statSync(filePath).isDirectory();

        structure += `${'  '.repeat(depth)}- ${file}\n`;

        if (isDirectory) {
            structure += generateFileStructure(filePath, depth + 1);
        }
    });

    return structure;
}

// Caminhos do backend e frontend
const backendDir = path.join(__dirname, '/src');
const frontendDir = path.join(__dirname, '../frontend/src');
const mobileDir = path.join(__dirname, "../mobile");

// Gerar mapas de ambos os diretórios
let output = 'Estrutura de Arquivos do Projeto\n\n';
output += 'Backend:\n';
output += generateFileStructure(backendDir);
output += '\nFrontend:\n';
output += generateFileStructure(frontendDir);
output += '\nMobile:\n';
output += generateFileStructure(mobileDir);

// Exibir no console
console.log(output);

// Opcional: salvar em um arquivo
const outputPath = path.join(__dirname, 'estrutura_projeto.txt');
fs.writeFileSync(outputPath, output);
console.log(`Estrutura salva em: ${outputPath}`);

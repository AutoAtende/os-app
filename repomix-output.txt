This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-02T13:11:29.830Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
backend/
  src/
    config/
      database.js
      multer.js
      redis.js
    controllers/
      AuthController.js
      DashboardController.js
      EquipmentController.js
      MaintenanceController.js
      NotificationController.js
      ReportController.js
      ServiceOrderController.js
      UserController.js
    database/
      migrations/
        01-create-users.js
        02-create-equipment.js
        03-create-maintenance.js
        04-create-notifications.js
        05-create-reports.js
      index.js
    jobs/
      processors/
        index.js
      jobProcessor.js
    middlewares/
      auth.js
      errorHandler.js
      security.js
      validate.js
    models/
      Equipment.js
      File.js
      index.js
      MaintenanceHistory.js
      Notification.js
      ServiceOrder.js
      User.js
    routes/
      index.js
    services/
      AuditService.js
      CacheService.js
      EmailService.js
      FileService.js
      MediaService.js
      NotificationService.js
      PDFService.js
      PushNotificationService.js
      QRCodeService.js
      ReportService.js
      S3Service.js
      WebSocketService.js
    utils/
      logger.js
    validations/
      schemas.js
    views/
      emails/
        maintenance-complete.ejs
        maintenance-notification.ejs
    websocket/
      webSocketMananger.js
    app.js
    index.js
  .env
  .sequelizerc
  estrutura_projeto.txt
  package.json
  tree.js
frontend/
  src/
    components/
      Layout/
        Layout.jsx
    contexts/
      AuthContext.js
    pages/
      Dashboard/
        Dashboard.jsx
      Equipment/
        EquipmentForm.jsx
        EquipmentList.jsx
        EquipmentQRCode.jsx
      Login/
        Login.jsx
      Maintenance/
        MaintenanceForm.jsx
        MaintenanceList.jsx
      Profile/
        Profile.jsx
      ServiceOrder/
        ServiceOrderForm.jsx
        ServiceOrderList.jsx
      Settings/
        Settings.jsx
      User/
        UserForm.jsx
        UserList.jsx
    routes/
      index.jsx
    services/
      api.js
      cacheService.jsx
      dashboardService.jsx
      i18nService.jsx
      notificationService.jsx
      qrcodeService.jsx
      reportService.jsx
      storageService.jsx
      themeService.jsx
      uploadService.jsx
      validationService.jsx
      websocketService.js
    utils/
      formatters.jsx
    App.jsx
    main.jsx
  .env
  componentes.sh
  package.json
  tailwind.config.js
  vite.config.js
mobile/
  DashboardScreen.jsx
  MainScreen.jsx
  MaintenanceForm.jsx
  MaintenanceHistory.jsx
.gitattributes
.gitignore
API_DOCS.txt
dev.sh
docker-compose.yml
nsetup.sh
setup.sh

================================================================
Files
================================================================

================
File: backend/src/config/database.js
================
require('dotenv').config();

module.exports = {
  development: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    define: {
      timestamps: true,
      underscored: true,
    },
    logging: false,
  },
  test: {
    dialect: 'sqlite',
    storage: './__tests__/database.sqlite',
    logging: false,
  },
  production: {
    username: process.env.DB_USER,
    password: process.env.DB_PASS,
    database: process.env.DB_NAME,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    dialect: 'postgres',
    define: {
      timestamps: true,
      underscored: true,
    },
    logging: false,
    pool: {
      max: 5,
      min: 0,
      acquire: 30000,
      idle: 10000,
    },
  },
};

================
File: backend/src/config/multer.js
================
const multer = require('multer');
const path = require('path');
const crypto = require('crypto');

module.exports = {
  storage: multer.diskStorage({
    destination: path.resolve(__dirname, '..', '..', 'tmp', 'uploads'),
    filename: (req, file, cb) => {
      crypto.randomBytes(16, (err, hash) => {
        if (err) cb(err);
        const fileName = `${hash.toString('hex')}-${file.originalname}`;
        cb(null, fileName);
      });
    },
  }),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = [
      'image/jpeg',
      'image/pjpeg',
      'image/png',
      'application/pdf',
    ];

    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Tipo de arquivo inválido.'));
    }
  },
};

================
File: backend/src/config/redis.js
================
const Redis = require('ioredis');

const redisConfig = {
  host: process.env.REDIS_HOST || 'localhost',
  port: process.env.REDIS_PORT || 6379,
  password: process.env.REDIS_PASSWORD,
  maxRetriesPerRequest: 3,
  retryStrategy(times) {
    const delay = Math.min(times * 50, 2000);
    return delay;
  },
  reconnectOnError(err) {
    const targetError = 'READONLY';
    if (err.message.includes(targetError)) {
      return true;
    }
    return false;
  }
};

let redisClient = null;

const getRedisClient = () => {
  if (!redisClient) {
    redisClient = new Redis(redisConfig);

    redisClient.on('error', (error) => {
      console.error('Erro na conexão com Redis:', error);
    });

    redisClient.on('connect', () => {
      console.log('Conectado ao Redis');
    });
  }

  return redisClient;
};

module.exports = {
  getRedisClient,
  redisConfig
};

================
File: backend/src/controllers/AuthController.js
================
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const crypto = require('crypto');
const { User } = require('../models/User');
const { Op } = require('sequelize');
const EmailService = require('../services/EmailService');
const logger = require('../utils/logger');

class AuthController {
  async login(req, res) {
    try {
      const { email, password } = req.body;

      const user = await User.findOne({
        where: { 
          email,
          active: true
        }
      });

      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      if (!(await bcrypt.compare(password, user.password_hash))) {
        return res.status(401).json({ error: 'Senha incorreta' });
      }

      const token = jwt.sign(
        { id: user.id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      );

      // Remove senha do retorno
      const { password_hash, ...userData } = user.toJSON();

      return res.json({
        user: userData,
        token
      });

    } catch (error) {
      logger.error('Erro no login:', error);
      return res.status(500).json({ error: 'Erro interno do servidor' });
    }
  }

  async forgotPassword(req, res) {
    try {
      const { email } = req.body;

      const user = await User.findOne({ where: { email } });

      if (!user) {
        return res.status(404).json({ error: 'Usuário não encontrado' });
      }

      // Gera token de reset
      const resetToken = crypto.randomBytes(20).toString('hex');
      const resetTokenExpires = new Date();
      resetTokenExpires.setHours(resetTokenExpires.getHours() + 1); // Token válido por 1 hora

      await user.update({
        password_reset_token: resetToken,
        password_reset_expires: resetTokenExpires
      });

      // Envia email
      await EmailService.sendPasswordReset({
        name: user.name,
        email: user.email,
        token: resetToken,
        resetUrl: `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`
      });

      return res.json({ message: 'Email de recuperação enviado com sucesso' });

    } catch (error) {
      logger.error('Erro no forgot password:', error);
      return res.status(500).json({ error: 'Erro ao recuperar senha' });
    }
  }

  async resetPassword(req, res) {
    try {
      const { email, token, password } = req.body;

      const user = await User.findOne({
        where: {
          email,
          password_reset_token: token,
          password_reset_expires: {
            [Op.gt]: new Date()
          }
        }
      });

      if (!user) {
        return res.status(400).json({ error: 'Token inválido ou expirado' });
      }

      // Atualiza senha
      const password_hash = await bcrypt.hash(password, 8);

      await user.update({
        password_hash,
        password_reset_token: null,
        password_reset_expires: null
      });

      // Envia email de confirmação
      await EmailService.sendPasswordResetConfirmation({
        name: user.name,
        email: user.email
      });

      return res.json({ message: 'Senha alterada com sucesso' });

    } catch (error) {
      logger.error('Erro no reset password:', error);
      return res.status(500).json({ error: 'Erro ao resetar senha' });
    }
  }

  async refreshToken(req, res) {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        return res.status(401).json({ error: 'Refresh token não fornecido' });
      }

      // Verifica refresh token
      const decoded = jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET);

      const user = await User.findByPk(decoded.id);
      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      // Gera novo token
      const token = jwt.sign(
        { id: user.id, role: user.role },
        process.env.JWT_SECRET,
        { expiresIn: '7d' }
      );

      // Gera novo refresh token
      const newRefreshToken = jwt.sign(
        { id: user.id },
        process.env.REFRESH_TOKEN_SECRET,
        { expiresIn: '30d' }
      );

      return res.json({
        token,
        refreshToken: newRefreshToken
      });

    } catch (error) {
      logger.error('Erro no refresh token:', error);
      return res.status(401).json({ error: 'Refresh token inválido' });
    }
  }

  async validateToken(req, res) {
    try {
      const { token } = req.body;

      if (!token) {
        return res.status(401).json({ error: 'Token não fornecido' });
      }

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findByPk(decoded.id);

      if (!user) {
        return res.status(401).json({ error: 'Usuário não encontrado' });
      }

      return res.json({ valid: true });

    } catch (error) {
      return res.json({ valid: false });
    }
  }

  async changePassword(req, res) {
    try {
      const { currentPassword, newPassword } = req.body;
      const user = await User.findByPk(req.userId);

      if (!(await bcrypt.compare(currentPassword, user.password_hash))) {
        return res.status(401).json({ error: 'Senha atual incorreta' });
      }

      const password_hash = await bcrypt.hash(newPassword, 8);
      await user.update({ password_hash });

      // Envia email de notificação
      await EmailService.sendPasswordChangeNotification({
        name: user.name,
        email: user.email
      });

      return res.json({ message: 'Senha alterada com sucesso' });

    } catch (error) {
      logger.error('Erro na mudança de senha:', error);
      return res.status(500).json({ error: 'Erro ao alterar senha' });
    }
  }

  async logout(req, res) {
    try {
      // Aqui você pode implementar lógica adicional de logout
      // como invalidar refresh tokens, etc.
      
      return res.json({ message: 'Logout realizado com sucesso' });
    } catch (error) {
      logger.error('Erro no logout:', error);
      return res.status(500).json({ error: 'Erro ao realizar logout' });
    }
  }
}

module.exports = new AuthController();

================
File: backend/src/controllers/DashboardController.js
================
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const { Op, Sequelize } = require('sequelize');
const CacheService = require('../services/CacheService');
const logger = require('../utils/logger');

class DashboardController {
  async getStats(req, res) {
    try {
      const { period = 'month' } = req.query;
      
      // Tenta buscar do cache
      const cacheKey = `dashboard:${period}:${req.userId}`;
      const cachedData = await CacheService.get(cacheKey);
      
      if (cachedData) {
        return res.json(cachedData);
      }

      // Calcula datas
      const endDate = new Date();
      const startDate = this.getStartDate(period);

      // Busca dados
      const [
        equipmentStats,
        maintenanceStats,
        performanceMetrics,
        upcomingMaintenances
      ] = await Promise.all([
        this.getEquipmentStats(),
        this.getMaintenanceStats(startDate, endDate),
        this.getPerformanceMetrics(startDate, endDate),
        this.getUpcomingMaintenances()
      ]);

      const dashboardData = {
        equipmentStats,
        maintenanceStats,
        performanceMetrics,
        upcomingMaintenances,
        lastUpdate: new Date()
      };

      // Salva no cache por 5 minutos
      await CacheService.set(cacheKey, dashboardData, 300);

      return res.json(dashboardData);

    } catch (error) {
      logger.error('Erro ao buscar estatísticas do dashboard:', error);
      return res.status(500).json({ error: 'Erro ao buscar estatísticas' });
    }
  }

  async getEquipmentStats() {
    const totalEquipments = await Equipment.count();
    const activeEquipments = await Equipment.count({ where: { status: 'active' } });
    const maintenanceEquipments = await Equipment.count({ where: { status: 'maintenance' } });
    
    return {
      total: totalEquipments,
      active: activeEquipments,
      inMaintenance: maintenanceEquipments,
      inactive: totalEquipments - activeEquipments - maintenanceEquipments
    };
  }

  async getMaintenanceStats(startDate, endDate) {
    const maintenances = await Maintenance.findAll({
      where: {
        created_at: {
          [Op.between]: [startDate, endDate]
        }
      },
      attributes: [
        'type',
        'status',
        [Sequelize.fn('COUNT', '*'), 'count'],
        [Sequelize.fn('SUM', Sequelize.col('cost')), 'totalCost']
      ],
      group: ['type', 'status']
    });

    const byType = {};
    const byStatus = {};

    maintenances.forEach(m => {
      byType[m.type] = (byType[m.type] || 0) + m.get('count');
      byStatus[m.status] = (byStatus[m.status] || 0) + m.get('count');
    });

    return {
      byType,
      byStatus,
      totalCost: maintenances.reduce((sum, m) => sum + (m.get('totalCost') || 0), 0)
    };
  }

  async getPerformanceMetrics(startDate, endDate) {
    const completedMaintenances = await Maintenance.findAll({
      where: {
        status: 'completed',
        completion_date: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ]
    });

    // Calcula métricas
    const totalTime = completedMaintenances.reduce((sum, m) => {
      const duration = new Date(m.completion_date) - new Date(m.created_at);
      return sum + duration;
    }, 0);

    const avgTime = completedMaintenances.length > 0 
      ? totalTime / completedMaintenances.length
      : 0;

    return {
      avgResolutionTime: Math.round(avgTime / (1000 * 60 * 60)), // em horas
      completionRate: await this.calculateCompletionRate(startDate, endDate),
      technicianPerformance: await this.calculateTechnicianPerformance(startDate, endDate)
    };
  }

  async getUpcomingMaintenances() {
    const nextWeek = new Date();
    nextWeek.setDate(nextWeek.getDate() + 7);

    return await Maintenance.findAll({
      where: {
        status: 'pending',
        scheduled_date: {
          [Op.lte]: nextWeek
        }
      },
      include: [
        {
          model: Equipment,
          attributes: ['id', 'name', 'code']
        },
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ],
      order: [['scheduled_date', 'ASC']],
      limit: 5
    });
  }

  async calculateCompletionRate(startDate, endDate) {
    const [completed, total] = await Promise.all([
      Maintenance.count({
        where: {
          status: 'completed',
          completion_date: {
            [Op.between]: [startDate, endDate]
          }
        }
      }),
      Maintenance.count({
        where: {
          created_at: {
            [Op.between]: [startDate, endDate]
          }
        }
      })
    ]);

    return total > 0 ? Math.round((completed / total) * 100) : 0;
  }

  async calculateTechnicianPerformance(startDate, endDate) {
    const performances = await Maintenance.findAll({
      attributes: [
        [Sequelize.fn('COUNT', '*'), 'total'],
        [Sequelize.fn('AVG', 
          Sequelize.literal('EXTRACT(EPOCH FROM (completion_date - created_at))/3600')
        ), 'avgTime']
      ],
      where: {
        status: 'completed',
        completion_date: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name']
        }
      ],
      group: ['technician.id', 'technician.name']
    });

    return performances.map(p => ({
      technician: p.technician,
      completedMaintenances: p.get('total'),
      averageResolutionTime: Math.round(p.get('avgTime'))
    }));
  }

  getStartDate(period) {
    const date = new Date();
    switch (period) {
      case 'week':
        date.setDate(date.getDate() - 7);
        break;
      case 'month':
        date.setMonth(date.getMonth() - 1);
        break;
      case 'year':
        date.setFullYear(date.getFullYear() - 1);
        break;
      default:
        date.setMonth(date.getMonth() - 1); // Padrão: último mês
    }
    return date;
  }
}

module.exports = new DashboardController();

================
File: backend/src/controllers/EquipmentController.js
================
const {Equipment} = require('../models/Equipment');
const {MaintenanceHistory} = require('../models/MaintenanceHistory');
const {User} = require('../models/User');
const QRCode = require('qrcode');

class EquipmentController {
  async store(req, res) {
    const equipment = await Equipment.create(req.body);

    // Gera QR Code
    const qrcodeData = `${process.env.APP_URL}/equipment/${equipment.id}`;
    const qrcodeUrl = await QRCode.toDataURL(qrcodeData);
    
    await equipment.update({ qrcode_url: qrcodeUrl });

    return res.status(201).json(equipment);
  }

  async index(req, res) {
    const { department, status, search } = req.query;
    const where = {};

    if (department) where.department = department;
    if (status) where.status = status;
    if (search) {
      where[Op.or] = [
        { name: { [Op.iLike]: `%${search}%` } },
        { code: { [Op.iLike]: `%${search}%` } },
        { serial_number: { [Op.iLike]: `%${search}%` } },
      ];
    }

    const equipment = await Equipment.findAll({
      where,
      include: [
        {
          model: MaintenanceHistory,
          as: 'maintenance_history',
          limit: 1,
          order: [['maintenance_date', 'DESC']],
        },
      ],
      order: [['created_at', 'DESC']],
    });

    return res.json(equipment);
  }

  async show(req, res) {
    const equipment = await Equipment.findByPk(req.params.id, {
      include: [
        {
          model: MaintenanceHistory,
          as: 'maintenance_history',
          include: [
            {
              model: User,
              as: 'technician',
              attributes: ['id', 'name'],
            },
          ],
        },
        {
          model: ServiceOrder,
          as: 'service_orders',
          include: [
            {
              model: User,
              as: 'creator',
              attributes: ['id', 'name'],
            },
          ],
        },
      ],
    });

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    return res.json(equipment);
  }

  async update(req, res) {
    const equipment = await Equipment.findByPk(req.params.id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    await equipment.update(req.body);

    return res.json(equipment);
  }

  async destroy(req, res) {
    const equipment = await Equipment.findByPk(req.params.id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    await equipment.destroy();

    return res.status(204).send();
  }
}

module.exports = new EquipmentController();

================
File: backend/src/controllers/MaintenanceController.js
================
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const NotificationService = require('../services/NotificationService');
const S3Service = require('../services/S3Service');
const { maintenanceHistorySchema } = require('../validations/schemas');
const logger = require('../utils/logger');

class MaintenanceController {
  async store(req, res) {
    try {
      const {
        equipment_id,
        description,
        type,
        notes,
        cost
      } = req.body;

      // Valida equipamento
      const equipment = await Equipment.findByPk(equipment_id);
      if (!equipment) {
        return res.status(404).json({ error: 'Equipamento não encontrado' });
      }

      // Processa fotos
      let photoUrls = [];
      if (req.files?.photos) {
        const uploadPromises = req.files.photos.map(photo => 
          S3Service.uploadFile(photo, 'maintenance-photos')
        );
        photoUrls = await Promise.all(uploadPromises);
      }

      // Processa documentos
      let documentUrls = [];
      if (req.files?.documents) {
        const uploadPromises = req.files.documents.map(doc => 
          S3Service.uploadFile(doc, 'maintenance-documents')
        );
        documentUrls = await Promise.all(uploadPromises);
      }

      // Cria registro de manutenção
      const maintenance = await Maintenance.create({
        equipment_id,
        description,
        type,
        status: 'pending',
        notes,
        cost: cost || 0,
        photos: photoUrls,
        documents: documentUrls,
        created_by: req.userId
      });

      // Atualiza status do equipamento
      await equipment.update({ 
        status: 'maintenance',
        last_maintenance: new Date()
      });

      // Notifica responsáveis
      await NotificationService.notifyMaintenanceCreated(maintenance);

      return res.status(201).json(maintenance);

    } catch (error) {
      logger.error('Erro ao criar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao registrar manutenção' });
    }
  }

  async index(req, res) {
    try {
      const { 
        status,
        equipment_id,
        start_date,
        end_date,
        type
      } = req.query;

      const where = {};

      if (status) where.status = status;
      if (equipment_id) where.equipment_id = equipment_id;
      if (type) where.type = type;
      
      if (start_date && end_date) {
        where.created_at = {
          [Op.between]: [start_date, end_date]
        };
      }

      // Se não for admin, filtra por departamento
      if (req.userRole !== 'admin') {
        const user = await User.findByPk(req.userId);
        where['$Equipment.department$'] = user.department;
      }

      const maintenances = await Maintenance.findAll({
        where,
        include: [
          {
            model: Equipment,
            attributes: ['id', 'name', 'code', 'department']
          },
          {
            model: User,
            as: 'technician',
            attributes: ['id', 'name']
          }
        ],
        order: [['created_at', 'DESC']]
      });

      return res.json(maintenances);

    } catch (error) {
      logger.error('Erro ao listar manutenções:', error);
      return res.status(500).json({ error: 'Erro ao listar manutenções' });
    }
  }

  async update(req, res) {
    try {
      const { id } = req.params;
      const {
        status,
        notes,
        cost,
        completion_notes
      } = req.body;

      const maintenance = await Maintenance.findByPk(id, {
        include: [{ model: Equipment }]
      });

      if (!maintenance) {
        return res.status(404).json({ error: 'Manutenção não encontrada' });
      }

      // Se estiver completando a manutenção
      if (status === 'completed' && maintenance.status !== 'completed') {
        // Atualiza status do equipamento
        await maintenance.Equipment.update({ status: 'active' });
        
        // Notifica sobre conclusão
        await NotificationService.notifyMaintenanceCompleted(maintenance);
      }

      await maintenance.update({
        status,
        notes,
        cost,
        completion_notes,
        completed_at: status === 'completed' ? new Date() : null,
        completed_by: status === 'completed' ? req.userId : null
      });

      return res.json(maintenance);

    } catch (error) {
      logger.error('Erro ao atualizar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao atualizar manutenção' });
    }
  }

  async show(req, res) {
    try {
      const { id } = req.params;

      const maintenance = await Maintenance.findByPk(id, {
        include: [
          {
            model: Equipment,
            attributes: ['id', 'name', 'code', 'department']
          },
          {
            model: User,
            as: 'technician',
            attributes: ['id', 'name']
          },
          {
            model: User,
            as: 'creator',
            attributes: ['id', 'name']
          }
        ]
      });

      if (!maintenance) {
        return res.status(404).json({ error: 'Manutenção não encontrada' });
      }

      return res.json(maintenance);

    } catch (error) {
      logger.error('Erro ao buscar manutenção:', error);
      return res.status(500).json({ error: 'Erro ao buscar manutenção' });
    }
  }
}

module.exports = new MaintenanceController();

================
File: backend/src/controllers/NotificationController.js
================
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const {Notification} = require('../models/Notification');
const NotificationService = require('../services/NotificationService');
const WebSocketManager = require('../websocket/WebSocketManager');
const JobProcessor = require('../jobs/JobProcessor');
const logger = require('../utils/logger');

class NotificationController {
  async store(req, res) {
    try {
      const {
        type,
        title,
        message,
        recipient_id,
        reference_type,
        reference_id,
        priority = 'normal'
      } = req.body;

      // Cria notificação
      const notification = await Notification.create({
        type,
        title,
        message,
        recipient_id,
        reference_type,
        reference_id,
        priority,
        sender_id: req.userId
      });

      // Envia notificação em tempo real
      await NotificationService.send({
        notification,
        recipient_id
      });

      return res.status(201).json(notification);
    } catch (error) {
      logger.error('Erro ao criar notificação:', error);
      return res.status(500).json({ error: 'Erro ao criar notificação' });
    }
  }

  async list(req, res) {
    try {
      const { 
        page = 1, 
        limit = 20, 
        read, 
        type,
        priority 
      } = req.query;

      const where = { recipient_id: req.userId };
      if (read !== undefined) where.read = read === 'true';
      if (type) where.type = type;
      if (priority) where.priority = priority;

      const notifications = await Notification.findAndCountAll({
        where,
        include: [
          {
            model: User,
            as: 'sender',
            attributes: ['id', 'name']
          }
        ],
        order: [['created_at', 'DESC']],
        limit: parseInt(limit),
        offset: (page - 1) * limit
      });

      return res.json({
        items: notifications.rows,
        total: notifications.count,
        unread: await this.getUnreadCount(req.userId)
      });
    } catch (error) {
        logger.error('Erro ao listar notificações:', error);
        return res.status(500).json({ error: 'Erro ao listar notificações' });
      }
    }
  
    async markAsRead(req, res) {
      try {
        const { id } = req.params;
        const notification = await Notification.findOne({
          where: { 
            id,
            recipient_id: req.userId
          }
        });
  
        if (!notification) {
          return res.status(404).json({ error: 'Notificação não encontrada' });
        }
  
        await notification.update({ read: true });
  
        // Atualiza contadores em tempo real
        WebSocketManager.sendToClient(req.userId, {
          type: 'NOTIFICATION_READ',
          data: {
            notificationId: id,
            unreadCount: await this.getUnreadCount(req.userId)
          }
        });
  
        return res.json(notification);
      } catch (error) {
        logger.error('Erro ao marcar notificação como lida:', error);
        return res.status(500).json({ error: 'Erro ao atualizar notificação' });
      }
    }
  
    async markAllAsRead(req, res) {
      try {
        await Notification.update(
          { read: true },
          { 
            where: { 
              recipient_id: req.userId,
              read: false
            }
          }
        );
  
        // Atualiza contadores em tempo real
        WebSocketManager.sendToClient(req.userId, {
          type: 'ALL_NOTIFICATIONS_READ',
          data: { unreadCount: 0 }
        });
  
        return res.status(204).send();
      } catch (error) {
        logger.error('Erro ao marcar todas notificações como lidas:', error);
        return res.status(500).json({ error: 'Erro ao atualizar notificações' });
      }
    }
  
    async delete(req, res) {
      try {
        const { id } = req.params;
        const notification = await Notification.findOne({
          where: { 
            id,
            recipient_id: req.userId
          }
        });
  
        if (!notification) {
          return res.status(404).json({ error: 'Notificação não encontrada' });
        }
  
        await notification.destroy();
        return res.status(204).send();
      } catch (error) {
        logger.error('Erro ao deletar notificação:', error);
        return res.status(500).json({ error: 'Erro ao deletar notificação' });
      }
    }
  
    async getUnreadCount(userId) {
      return await Notification.count({
        where: {
          recipient_id: userId,
          read: false
        }
      });
    }
  
    async getUserPreferences(req, res) {
      try {
        const preferences = await NotificationPreference.findOne({
          where: { user_id: req.userId }
        });
  
        return res.json(preferences || {
          email: true,
          push: true,
          in_app: true,
          maintenance_reminders: true,
          equipment_alerts: true
        });
      } catch (error) {
        logger.error('Erro ao buscar preferências:', error);
        return res.status(500).json({ error: 'Erro ao buscar preferências' });
      }
    }
  
    async updateUserPreferences(req, res) {
      try {
        const {
          email,
          push,
          in_app,
          maintenance_reminders,
          equipment_alerts
        } = req.body;
  
        const [preferences] = await NotificationPreference.upsert({
          user_id: req.userId,
          email,
          push,
          in_app,
          maintenance_reminders,
          equipment_alerts
        });
  
        return res.json(preferences);
      } catch (error) {
        logger.error('Erro ao atualizar preferências:', error);
        return res.status(500).json({ error: 'Erro ao atualizar preferências' });
      }
    }
  
    // Métodos para envio de notificações específicas
    async notifyMaintenanceDue(equipment) {
      try {
        const users = await User.findAll({
          where: {
            [Op.or]: [
              { role: 'admin' },
              { role: 'technician', department: equipment.department }
            ]
          }
        });
  
        const notifications = users.map(user => ({
          type: 'MAINTENANCE_DUE',
          title: 'Manutenção Preventiva Necessária',
          message: `O equipamento ${equipment.name} (${equipment.code}) precisa de manutenção preventiva.`,
          recipient_id: user.id,
          reference_type: 'equipment',
          reference_id: equipment.id,
          priority: 'high'
        }));
  
        await Notification.bulkCreate(notifications);
  
        // Notifica em tempo real
        users.forEach(user => {
          WebSocketManager.sendToClient(user.id, {
            type: 'MAINTENANCE_DUE',
            data: { equipment }
          });
        });
  
        // Agenda envio de emails
        await JobProcessor.addNotificationJob('send_maintenance_due_emails', {
          equipment,
          users
        });
  
      } catch (error) {
        logger.error('Erro ao notificar manutenção necessária:', error);
      }
    }
  }
  
  module.exports = new NotificationController();

================
File: backend/src/controllers/ReportController.js
================
const PDFService = require('../services/PDFService');
const ExcelService = require('../services/ExcelService');
const JobProcessor = require('../jobs/JobProcessor');
const CacheService = require('../services/CacheService');
const logger = require('../utils/logger');

class ReportController {
  async generate(req, res) {
    try {
      const {
        type,
        format = 'pdf',
        start_date,
        end_date,
        department,
        equipment_id
      } = req.query;

      // Valida parâmetros
      if (!type) {
        return res.status(400).json({ error: 'Tipo de relatório é obrigatório' });
      }

      // Gera chave de cache
      const cacheKey = `report:${type}:${format}:${start_date}:${end_date}:${department}:${equipment_id}`;
      
      // Verifica cache
      const cachedReport = await CacheService.get(cacheKey);
      if (cachedReport) {
        return res.json(cachedReport);
      }

      // Inicia job de geração
      const job = await JobProcessor.addReportJob({
        type,
        format,
        filters: {
          start_date,
          end_date,
          department,
          equipment_id
        },
        userId: req.userId
      });

      return res.json({
        message: 'Relatório está sendo gerado',
        jobId: job.id,
        estimatedTime: '1-2 minutos'
      });

    } catch (error) {
      logger.error('Erro ao gerar relatório:', error);
      return res.status(500).json({ error: 'Erro ao gerar relatório' });
    }
  }

  async getStatus(req, res) {
    try {
      const { jobId } = req.params;
      const status = await JobProcessor.getJobStatus(jobId);

      if (!status) {
        return res.status(404).json({ error: 'Job não encontrado' });
      }

      return res.json(status);
    } catch (error) {
      logger.error('Erro ao buscar status do relatório:', error);
      return res.status(500).json({ error: 'Erro ao buscar status' });
    }
  }

  async download(req, res) {
    try {
      const { reportId } = req.params;
      const { format = 'pdf' } = req.query;

      const report = await Report.findByPk(reportId);
      if (!report) {
        return res.status(404).json({ error: 'Relatório não encontrado' });
      }

      // Define headers baseado no formato
      if (format === 'pdf') {
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader('Content-Disposition', `attachment; filename=report-${reportId}.pdf`);
      } else {
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.setHeader('Content-Disposition', `attachment; filename=report-${reportId}.xlsx`);
      }

      const fileStream = await report.getFileStream();
      fileStream.pipe(res);

    } catch (error) {
      logger.error('Erro ao baixar relatório:', error);
      return res.status(500).json({ error: 'Erro ao baixar relatório' });
    }
  }

  async list(req, res) {
    try {
      const { page = 1, limit = 10, type } = req.query;

      const where = {};
      if (type) where.type = type;

      const reports = await Report.findAndCountAll({
        where,
        order: [['created_at', 'DESC']],
        limit: parseInt(limit),
        offset: (page - 1) * limit
      });

      return res.json({
        items: reports.rows,
        total: reports.count,
        page: parseInt(page),
        pages: Math.ceil(reports.count / limit)
      });

    } catch (error) {
      logger.error('Erro ao listar relatórios:', error);
      return res.status(500).json({ error: 'Erro ao listar relatórios' });
    }
  }

  async delete(req, res) {
    try {
      const report = await Report.findByPk(req.params.id);
      if (!report) {
        return res.status(404).json({ error: 'Relatório não encontrado' });
      }

      await report.deleteFile(); // Remove arquivo do S3
      await report.destroy();

      return res.status(204).send();
    } catch (error) {
      logger.error('Erro ao deletar relatório:', error);
      return res.status(500).json({ error: 'Erro ao deletar relatório' });
    }
  }
}

module.exports = new ReportController();

================
File: backend/src/controllers/ServiceOrderController.js
================
const {ServiceOrder} = require('../models/ServiceOrder');
const {File} = require('../models/File');
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');

const { uploadToS3 } = require('../services/S3Service');

class ServiceOrderController {
  async store(req, res) {
    const {
      equipment_id,
      description,
      type,
      priority,
      scheduled_for,
    } = req.body;

    const equipment = await Equipment.findByPk(equipment_id);

    if (!equipment) {
      return res.status(404).json({ error: 'Equipamento não encontrado' });
    }

    const serviceOrder = await ServiceOrder.create({
      equipment_id,
      description,
      type,
      priority,
      scheduled_for,
      created_by: req.userId,
    });

    if (req.files) {
      const filesPromises = req.files.map(file => 
        uploadToS3(file).then(url => 
          File.create({
            name: file.originalname,
            path: url,
            service_order_id: serviceOrder.id,
          })
        )
      );

      await Promise.all(filesPromises);
    }

    return res.status(201).json(serviceOrder);
  }

  async index(req, res) {
    const { status, equipment_id, date_start, date_end } = req.query;
    const where = {};

    if (status) where.status = status;
    if (equipment_id) where.equipment_id = equipment_id;
    if (date_start && date_end) {
      where.scheduled_for = {
        [Op.between]: [date_start, date_end],
      };
    }

    const serviceOrders = await ServiceOrder.findAll({
      where,
      include: [
        {
          model: Equipment,
          as: 'equipment',
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name'],
        },
        {
          model: User,
          as: 'technician',
          attributes: ['id', 'name'],
        },
        {
          model: File,
          as: 'files',
        },
      ],
      order: [['scheduled_for', 'ASC']],
    });

    return res.json(serviceOrders);
  }

  async update(req, res) {
    const serviceOrder = await ServiceOrder.findByPk(req.params.id);

    if (!serviceOrder) {
      return res.status(404).json({ error: 'Ordem de serviço não encontrada' });
    }

    if (req.body.status === 'completed') {
      req.body.completed_at = new Date();

      await MaintenanceHistory.create({
        equipment_id: serviceOrder.equipment_id,
        maintenance_date: req.body.completed_at,
        type: serviceOrder.type,
        description: serviceOrder.description,
        performed_by: req.userId,
      });
    }

    await serviceOrder.update(req.body);

    return res.json(serviceOrder);
  }
}

module.exports = new ServiceOrderController();

================
File: backend/src/controllers/UserController.js
================
const { User } = require('../models');
const { generateToken } = require('../utils/auth');

class UserController {
  async store(req, res) {
    const { email } = req.body;

    const userExists = await User.findOne({ where: { email } });

    if (userExists) {
      return res.status(400).json({ error: 'Usuário já existe' });
    }

    const user = await User.create(req.body);

    user.password = undefined;

    return res.status(201).json({
      user,
      token: generateToken({ id: user.id }),
    });
  }

  async update(req, res) {
    const { email, oldPassword } = req.body;
    const user = await User.findByPk(req.userId);

    if (email && email !== user.email) {
      const userExists = await User.findOne({ where: { email } });
      if (userExists) {
        return res.status(400).json({ error: 'Email já está em uso' });
      }
    }

    if (oldPassword && !(await user.checkPassword(oldPassword))) {
      return res.status(401).json({ error: 'Senha incorreta' });
    }

    await user.update(req.body);

    user.password = undefined;

    return res.json(user);
  }

  async index(req, res) {
    const users = await User.findAll({
      attributes: { exclude: ['password'] },
    });

    return res.json(users);
  }
}

module.exports = new UserController();

================
File: backend/src/database/migrations/01-create-users.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('users', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false
        },
        email: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true
        },
        password_hash: {
          type: Sequelize.STRING,
          allowNull: false
        },
        role: {
          type: Sequelize.ENUM('admin', 'manager', 'technician'),
          defaultValue: 'technician'
        },
        department: {
          type: Sequelize.STRING
        },
        active: {
          type: Sequelize.BOOLEAN,
          defaultValue: true
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('users');
    }
  };

================
File: backend/src/database/migrations/02-create-equipment.js
================
// Migration: 02-create-equipment.js
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('equipment', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        name: {
          type: Sequelize.STRING,
          allowNull: false
        },
        code: {
          type: Sequelize.STRING,
          allowNull: false,
          unique: true
        },
        serial_number: {
          type: Sequelize.STRING
        },
        department: {
          type: Sequelize.STRING,
          allowNull: false
        },
        description: {
          type: Sequelize.TEXT
        },
        status: {
          type: Sequelize.ENUM('active', 'maintenance', 'inactive'),
          defaultValue: 'active'
        },
        maintenance_frequency: {
          type: Sequelize.INTEGER, // em dias
          defaultValue: 30
        },
        last_maintenance: {
          type: Sequelize.DATE
        },
        qrcode_url: {
          type: Sequelize.STRING
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('equipment');
    }
  };

================
File: backend/src/database/migrations/03-create-maintenance.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('maintenance', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        equipment_id: {
          type: Sequelize.INTEGER,
          references: { model: 'equipment', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        technician_id: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        type: {
          type: Sequelize.ENUM('preventive', 'corrective', 'predictive'),
          allowNull: false
        },
        status: {
          type: Sequelize.ENUM('pending', 'in_progress', 'completed', 'cancelled'),
          defaultValue: 'pending'
        },
        description: {
          type: Sequelize.TEXT,
          allowNull: false
        },
        scheduled_date: {
          type: Sequelize.DATE,
          allowNull: false
        },
        completed_date: {
          type: Sequelize.DATE
        },
        cost: {
          type: Sequelize.DECIMAL(10, 2)
        },
        notes: {
          type: Sequelize.TEXT
        },
        created_by: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('maintenance');
    }
  };

================
File: backend/src/database/migrations/04-create-notifications.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('notifications', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        recipient_id: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'CASCADE'
        },
        type: {
          type: Sequelize.STRING,
          allowNull: false
        },
        title: {
          type: Sequelize.STRING,
          allowNull: false
        },
        message: {
          type: Sequelize.TEXT,
          allowNull: false
        },
        read: {
          type: Sequelize.BOOLEAN,
          defaultValue: false
        },
        reference_type: {
          type: Sequelize.STRING
        },
        reference_id: {
          type: Sequelize.INTEGER
        },
        priority: {
          type: Sequelize.ENUM('low', 'normal', 'high'),
          defaultValue: 'normal'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('notifications');
    }
  };

================
File: backend/src/database/migrations/05-create-reports.js
================
module.exports = {
    up: async (queryInterface, Sequelize) => {
      await queryInterface.createTable('reports', {
        id: {
          type: Sequelize.INTEGER,
          primaryKey: true,
          autoIncrement: true
        },
        type: {
          type: Sequelize.STRING,
          allowNull: false
        },
        title: {
          type: Sequelize.STRING,
          allowNull: false
        },
        filters: {
          type: Sequelize.JSONB
        },
        file_url: {
          type: Sequelize.STRING
        },
        status: {
          type: Sequelize.ENUM('processing', 'completed', 'error'),
          defaultValue: 'processing'
        },
        error_message: {
          type: Sequelize.TEXT
        },
        created_by: {
          type: Sequelize.INTEGER,
          references: { model: 'users', key: 'id' },
          onUpdate: 'CASCADE',
          onDelete: 'SET NULL'
        },
        created_at: {
          type: Sequelize.DATE,
          allowNull: false
        },
        updated_at: {
          type: Sequelize.DATE,
          allowNull: false
        }
      });
    },
    down: async (queryInterface) => {
      await queryInterface.dropTable('reports');
    }
  };

================
File: backend/src/database/index.js
================
const Sequelize = require('sequelize');
const config = require('../config/database');
const models = require('../models');

const env = process.env.NODE_ENV || 'development';
const dbConfig = config[env];

const sequelize = new Sequelize(dbConfig);

// Inicializa os models
Object.values(models).forEach(model => model.init(sequelize));

// Associações entre os models
Object.values(models).forEach(model => {
  if (model.associate) {
    model.associate(models);
  }
});

module.exports = sequelize;

================
File: backend/src/jobs/processors/index.js
================
const reportProcessor = require('./reportProcessor');
const notificationProcessor = require('./notificationProcessor');
const fileProcessor = require('./fileProcessor');
const equipmentProcessor = require('./equipmentProcessor');

module.exports = {
  reportProcessor,
  notificationProcessor,
  fileProcessor,
  equipmentProcessor
};

// Processadores específicos
const processors = {
  // Processador de Relatórios
  reportProcessor: {
    async generate(type, filters) {
      // Implementação específica para cada tipo de relatório
      switch (type) {
        case 'maintenance':
          return await generateMaintenanceReport(filters);
        case 'equipment':
          return await generateEquipmentReport(filters);
        case 'cost':
          return await generateCostReport(filters);
        default:
          throw new Error(`Tipo de relatório não suportado: ${type}`);
      }
    }
  },

  // Processador de Notificações
  notificationProcessor: {
    async send(type, data) {
      switch (type) {
        case 'maintenance_due':
          return await sendMaintenanceNotification(data);
        case 'equipment_status':
          return await sendStatusNotification(data);
        case 'report_ready':
          return await sendReportNotification(data);
        default:
          throw new Error(`Tipo de notificação não suportado: ${type}`);
      }
    }
  },

  // Processador de Arquivos
  fileProcessor: {
    async process(file, type) {
      switch (type) {
        case 'image':
          return await processImage(file);
        case 'document':
          return await processDocument(file);
        case 'qrcode':
          return await generateQRCode(file);
        default:
          throw new Error(`Tipo de arquivo não suportado: ${type}`);
      }
    }
  },

  // Processador de Equipamentos
  equipmentProcessor: {
    async sync(equipmentId, changes) {
      try {
        // Sincroniza mudanças no equipamento
        const equipment = await Equipment.findByPk(equipmentId);
        if (!equipment) {
          throw new Error('Equipamento não encontrado');
        }

        // Atualiza dados
        await equipment.update(changes);

        // Gera novo QR Code se necessário
        if (changes.needsNewQRCode) {
          await generateAndUpdateQRCode(equipment);
        }

        // Atualiza cache
        await cacheService.invalidateEquipmentCache(equipmentId);

        return equipment;
      } catch (error) {
        console.error('Erro na sincronização:', error);
        throw error;
      }
    }
  }
};

module.exports = processors;

================
File: backend/src/jobs/jobProcessor.js
================
const Queue = require('bull');
const path = require('path');
const processors = require('./processors');

class JobProcessor {
  constructor() {
    this.queues = {
      reportGeneration: new Queue('reportGeneration', {
        redis: {
          host: process.env.REDIS_HOST,
          port: process.env.REDIS_PORT,
          password: process.env.REDIS_PASSWORD
        },
        defaultJobOptions: {
          attempts: 3,
          backoff: {
            type: 'exponential',
            delay: 1000
          },
          removeOnComplete: true
        }
      }),
      maintenanceNotification: new Queue('maintenanceNotification'),
      fileProcessing: new Queue('fileProcessing'),
      equipmentSync: new Queue('equipmentSync')
    };

    this.initializeProcessors();
  }

  initializeProcessors() {
    // Report Generation Queue
    this.queues.reportGeneration.process(async (job) => {
      try {
        const { type, filters, userId } = job.data;
        const report = await processors.reportProcessor.generate(type, filters);
        
        // Notifica o usuário que o relatório está pronto
        await this.queues.maintenanceNotification.add({
          type: 'REPORT_READY',
          userId,
          reportUrl: report.url
        });

        return report;
      } catch (error) {
        console.error('Erro ao gerar relatório:', error);
        throw error;
      }
    });

    // File Processing Queue
    this.queues.fileProcessing.process(async (job) => {
      const { file, type } = job.data;
      return await processors.fileProcessor.process(file, type);
    });

    // Equipment Sync Queue
    this.queues.equipmentSync.process(async (job) => {
      const { equipmentId, changes } = job.data;
      return await processors.equipmentProcessor.sync(equipmentId, changes);
    });

    // Maintenance Notification Queue
    this.queues.maintenanceNotification.process(async (job) => {
      const { type, data } = job.data;
      return await processors.notificationProcessor.send(type, data);
    });
  }

  // Adiciona job na fila de geração de relatórios
  async addReportJob(type, filters, userId) {
    return await this.queues.reportGeneration.add({
      type,
      filters,
      userId
    });
  }

  // Adiciona job na fila de processamento de arquivos
  async addFileProcessingJob(file, type) {
    return await this.queues.fileProcessing.add({
      file,
      type
    });
  }

  // Adiciona job na fila de sincronização de equipamentos
  async addEquipmentSyncJob(equipmentId, changes) {
    return await this.queues.equipmentSync.add({
      equipmentId,
      changes
    });
  }

  // Adiciona job na fila de notificações
  async addNotificationJob(type, data) {
    return await this.queues.maintenanceNotification.add({
      type,
      data
    });
  }

  // Retorna o status de todos os jobs
  async getJobsStatus() {
    const status = {};
    
    for (const [queueName, queue] of Object.entries(this.queues)) {
      status[queueName] = {
        waiting: await queue.getWaitingCount(),
        active: await queue.getActiveCount(),
        completed: await queue.getCompletedCount(),
        failed: await queue.getFailedCount()
      };
    }

    return status;
  }

  // Limpa jobs completados
  async cleanCompletedJobs() {
    for (const queue of Object.values(this.queues)) {
      await queue.clean(1000 * 60 * 60 * 24, 'completed'); // Remove jobs completados há mais de 24h
    }
  }
}

module.exports = new JobProcessor();

================
File: backend/src/middlewares/auth.js
================
const jwt = require('jsonwebtoken');
const { User } = require('../models/User');

class AuthMiddleware {
  async authenticate(req, res, next) {
    try {
      const authHeader = req.headers.authorization;

      if (!authHeader) {
        return res.status(401).json({ error: 'Token não fornecido' });
      }

      const [, token] = authHeader.split(' ');

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      
      const user = await User.findByPk(decoded.id);
      
      if (!user || !user.active) {
        return res.status(401).json({ error: 'Usuário inválido ou inativo' });
      }

      req.userId = user.id;
      req.userRole = user.role;
      
      next();
    } catch (error) {
      return res.status(401).json({ error: 'Token inválido' });
    }
  }

  hasRole(roles) {
    return (req, res, next) => {
      if (!roles.includes(req.userRole)) {
        return res.status(403).json({ error: 'Acesso não autorizado' });
      }
      next();
    };
  }

  isAdmin(req, res, next) {
    if (req.userRole !== 'admin') {
      return res.status(403).json({ error: 'Acesso restrito a administradores' });
    }
    next();
  }

  // Middleware para verificar se o usuário tem acesso ao departamento
  async hasDepartmentAccess(req, res, next) {
    try {
      if (req.userRole === 'admin') {
        return next();
      }

      const user = await User.findByPk(req.userId);
      const requestedDepartment = req.body.department || req.query.department;

      if (!requestedDepartment || user.department === requestedDepartment) {
        return next();
      }

      return res.status(403).json({ error: 'Acesso não autorizado ao departamento' });
    } catch (error) {
      next(error);
    }
  }
}

module.exports = new AuthMiddleware();

================
File: backend/src/middlewares/errorHandler.js
================
const { ValidationError } = require('sequelize');

module.exports = (err, req, res, next) => {
  if (err instanceof ValidationError) {
    return res.status(400).json({
      error: 'Erro de validação',
      messages: err.errors.map(error => error.message),
    });
  }

  console.error(err);

  return res.status(500).json({
    error: 'Erro interno do servidor',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined,
  });
};

================
File: backend/src/middlewares/security.js
================
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const xss = require('xss-clean');
const cors = require('cors');
const hpp = require('hpp');
const mongoSanitize = require('express-mongo-sanitize');

// Rate limiter
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, // limite por IP
  message: 'Muitas requisições deste IP, tente novamente em 15 minutos'
});

// Limiter específico para autenticação
const authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hora
  max: 5, // 5 tentativas
  message: 'Muitas tentativas de login, tente novamente em 1 hora'
});

const security = {
  // Configurações básicas de segurança
  basic: [
    helmet(), // Segurança básica de headers
    xss(), // Prevenção XSS
    hpp(), // Proteção contra poluição de parâmetros
    mongoSanitize(), // Sanitização de dados
    cors({
      origin: process.env.CORS_ORIGIN || '*',
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
      allowedHeaders: ['Content-Type', 'Authorization']
    })
  ],

  // Rate limiting
  rateLimit: {
    all: limiter,
    auth: authLimiter
  },

  // Validação de uploads
  validateUpload: (req, res, next) => {
    const file = req.file;
    
    if (!file) {
      return next();
    }

    // Verifica tamanho máximo (5MB)
    const maxSize = 5 * 1024 * 1024;
    if (file.size > maxSize) {
      return res.status(400).json({
        error: 'Arquivo muito grande. Tamanho máximo: 5MB'
      });
    }

    // Verifica tipos permitidos
    const allowedTypes = [
      'image/jpeg',
      'image/png',
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];

    if (!allowedTypes.includes(file.mimetype)) {
      return res.status(400).json({
        error: 'Tipo de arquivo não permitido'
      });
    }

    next();
  },

  // Sanitização de dados
  sanitizeData: (req, res, next) => {
    if (req.body) {
      Object.keys(req.body).forEach(key => {
        if (typeof req.body[key] === 'string') {
          req.body[key] = req.body[key].trim();
        }
      });
    }
    next();
  },

  // Validação de tokens JWT
  validateJWT: (req, res, next) => {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ error: 'Token não fornecido' });
    }

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.userId = decoded.id;
      next();
    } catch (error) {
      return res.status(401).json({ error: 'Token inválido' });
    }
  },

  // Controle de acesso baseado em roles
  checkRole: (roles) => {
    return async (req, res, next) => {
      try {
        const user = await User.findByPk(req.userId);
        
        if (!user) {
          return res.status(404).json({ error: 'Usuário não encontrado' });
        }

        if (!roles.includes(user.role)) {
          return res.status(403).json({ error: 'Acesso não autorizado' });
        }

        next();
      } catch (error) {
        next(error);
      }
    };
  }
};

module.exports = security;

================
File: backend/src/middlewares/validate.js
================
const yup = require('yup');

module.exports = schema => async (req, res, next) => {
  try {
    await schema.validate(req.body, { abortEarly: false });
    return next();
  } catch (err) {
    return res.status(400).json({
      error: 'Erro de validação',
      messages: err.inner.map(error => ({
        field: error.path,
        message: error.message,
      })),
    });
  }
};

================
File: backend/src/models/Equipment.js
================
class Equipment extends Model {
    static init(sequelize) {
      super.init({
        name: {
          type: DataTypes.STRING,
          allowNull: false,
          validate: {
            notEmpty: true,
          },
        },
        code: {
          type: DataTypes.STRING,
          allowNull: false,
          unique: true,
        },
        serial_number: DataTypes.STRING,
        department: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        description: DataTypes.TEXT,
        status: {
          type: DataTypes.ENUM('active', 'maintenance', 'inactive'),
          defaultValue: 'active',
        },
        qrcode_url: DataTypes.STRING,
        last_maintenance: DataTypes.DATE,
        maintenance_frequency: {
          type: DataTypes.INTEGER, // em dias
          defaultValue: 30,
        },
      }, {
        sequelize,
        tableName: 'equipment',
      });
    }
  
    static associate(models) {
      this.hasMany(models.ServiceOrder, { as: 'service_orders' });
      this.hasMany(models.MaintenanceHistory, { as: 'maintenance_history' });
    }
  }

  module.exports = {
    Equipment
  };

================
File: backend/src/models/File.js
================
class File extends Model {
    static init(sequelize) {
      super.init({
        name: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        path: {
          type: DataTypes.STRING,
          allowNull: false,
        },
        url: {
          type: DataTypes.VIRTUAL,
          get() {
            return `${process.env.APP_URL}/files/${this.path}`;
          },
        },
      }, {
        sequelize,
        tableName: 'files',
      });
    }
  
    static associate(models) {
      this.belongsTo(models.ServiceOrder, { foreignKey: 'service_order_id' });
    }
  }

  module.exports = {
    File
  };

================
File: backend/src/models/index.js
================
const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require('../config/database')[env];

const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;

================
File: backend/src/models/MaintenanceHistory.js
================
class MaintenanceHistory extends Model {
    static init(sequelize) {
      super.init({
        maintenance_date: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        type: {
          type: DataTypes.ENUM('preventive', 'corrective', 'predictive'),
          allowNull: false,
        },
        description: DataTypes.TEXT,
        cost: DataTypes.DECIMAL(10, 2),
        parts_replaced: DataTypes.JSON,
      }, {
        sequelize,
        tableName: 'maintenance_history',
      });
    }
  
    static associate(models) {
      this.belongsTo(models.Equipment, { foreignKey: 'equipment_id' });
      this.belongsTo(models.User, { foreignKey: 'performed_by' });
    }
  }

  module.exports = {
    User,
    Equipment,
    ServiceOrder,
    File,
    MaintenanceHistory,
  };

================
File: backend/src/models/Notification.js
================
module.exports = (sequelize, DataTypes) => {
    const Notification = sequelize.define('Notification', {
      recipient_id: {
        type: DataTypes.INTEGER,
        allowNull: false,
        references: { 
          model: 'users', 
          key: 'id' 
        }
      },
      type: {
        type: DataTypes.STRING,
        allowNull: false
      },
      title: {
        type: DataTypes.STRING,
        allowNull: false
      },
      message: {
        type: DataTypes.TEXT,
        allowNull: false
      },
      read: {
        type: DataTypes.BOOLEAN,
        defaultValue: false
      },
      reference_type: {
        type: DataTypes.STRING
      },
      reference_id: {
        type: DataTypes.INTEGER
      },
      priority: {
        type: DataTypes.ENUM('low', 'normal', 'high'),
        defaultValue: 'normal'
      }
    }, {
      tableName: 'notifications',
      timestamps: true,
      underscored: true
    });
  
    Notification.associate = function(models) {
      Notification.belongsTo(models.User, {
        foreignKey: 'recipient_id',
        as: 'recipient'
      });
      
      Notification.belongsTo(models.User, {
        foreignKey: 'sender_id',
        as: 'sender'
      });
    };
  
    return Notification;
  };

================
File: backend/src/models/ServiceOrder.js
================
class ServiceOrder extends Model {
    static init(sequelize) {
      super.init({
        description: {
          type: DataTypes.TEXT,
          allowNull: false,
        },
        type: {
          type: DataTypes.ENUM('preventive', 'corrective', 'predictive'),
          allowNull: false,
        },
        priority: {
          type: DataTypes.ENUM('low', 'medium', 'high', 'critical'),
          defaultValue: 'medium',
        },
        status: {
          type: DataTypes.ENUM('pending', 'in_progress', 'completed', 'cancelled'),
          defaultValue: 'pending',
        },
        scheduled_for: {
          type: DataTypes.DATE,
          allowNull: false,
        },
        completed_at: DataTypes.DATE,
        cost: DataTypes.DECIMAL(10, 2),
        notes: DataTypes.TEXT,
      }, {
        sequelize,
        tableName: 'service_orders',
      });
    }
  
    static associate(models) {
      this.belongsTo(models.Equipment, { foreignKey: 'equipment_id', as: 'equipment' });
      this.belongsTo(models.User, { foreignKey: 'created_by', as: 'creator' });
      this.belongsTo(models.User, { foreignKey: 'assigned_to', as: 'technician' });
      this.hasMany(models.File, { as: 'files' });
    }
  }

  module.exports = {
    ServiceOrder
  };

================
File: backend/src/models/User.js
================
const { Model, DataTypes } = require('sequelize');
const bcrypt = require('bcryptjs');

class User extends Model {
  static init(sequelize) {
    super.init({
      name: {
        type: DataTypes.STRING,
        allowNull: false,
        validate: {
          notEmpty: true,
        },
      },
      email: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
        validate: {
          isEmail: true,
        },
      },
      password: {
        type: DataTypes.STRING,
        allowNull: false,
      },
      role: {
        type: DataTypes.ENUM('admin', 'manager', 'technician'),
        defaultValue: 'technician',
      },
      active: {
        type: DataTypes.BOOLEAN,
        defaultValue: true,
      },
    }, {
      sequelize,
      tableName: 'users',
      hooks: {
        beforeSave: async (user) => {
          if (user.password && user.changed('password')) {
            user.password = await bcrypt.hash(user.password, 8);
          }
        },
      },
    });
  }

  static associate(models) {
    this.hasMany(models.ServiceOrder, { foreignKey: 'created_by', as: 'service_orders' });
  }

  checkPassword(password) {
    return bcrypt.compare(password, this.password);
  }
}

module.exports = {
    User
  };

================
File: backend/src/routes/index.js
================
const express = require('express');
const router = express.Router();
const multer = require('multer');
const multerConfig = require('../config/multer');

// Middlewares
const AuthMiddleware = require('../middlewares/auth');
const validate = require('../middlewares/validate');
const schemas = require('../validations/schemas');

// Controllers
const authController = require('../controllers/AuthController');
const equipmentController = require('../controllers/EquipmentController');
const serviceOrderController = require('../controllers/ServiceOrderController');
const userController = require('../controllers/UserController');
const maintenanceController = require('../controllers/MaintenanceController');
const notificationController = require('../controllers/NotificationController');
const reportController = require('../controllers/ReportController');
const dashboardController = require('../controllers/DashboardController');

const upload = multer(multerConfig);

// Rotas públicas
router.post('/auth/login', validate(schemas.loginSchema), authController.login);
router.post('/auth/forgot-password', authController.forgotPassword);
router.post('/auth/reset-password', authController.resetPassword);

// Middleware de autenticação para rotas protegidas
router.use(AuthMiddleware.authenticate);

// Equipamentos
router.get('/equipment', 
  AuthMiddleware.hasDepartmentAccess,
  equipmentController.index
);

router.post('/equipment',
  AuthMiddleware.hasRole(['admin', 'manager']),
  validate(schemas.equipmentSchema),
  upload.single('image'),
  equipmentController.store
);

router.get('/equipment/:id',
  AuthMiddleware.hasDepartmentAccess,
  equipmentController.show
);

router.put('/equipment/:id',
  AuthMiddleware.hasRole(['admin', 'manager']),
  validate(schemas.equipmentSchema),
  upload.single('image'),
  equipmentController.update
);

router.delete('/equipment/:id',
  AuthMiddleware.hasRole(['admin']),
  equipmentController.delete
);

router.get('/equipment/:id/qrcode',
  AuthMiddleware.hasDepartmentAccess,
  equipmentController.generateQRCode
);

// Manutenções
router.post('/maintenance',
  validate(schemas.maintenanceSchema),
  upload.fields([
    { name: 'photos', maxCount: 5 },
    { name: 'documents', maxCount: 3 }
  ]),
  maintenanceController.store
);

router.get('/maintenance',
  AuthMiddleware.hasDepartmentAccess,
  maintenanceController.index
);

router.get('/maintenance/:id',
  AuthMiddleware.hasDepartmentAccess,
  maintenanceController.show
);

router.put('/maintenance/:id',
  AuthMiddleware.hasRole(['admin', 'technician']),
  validate(schemas.maintenanceUpdateSchema),
  maintenanceController.update
);

// Ordens de Serviço
router.get('/service-orders',
  AuthMiddleware.hasDepartmentAccess,
  serviceOrderController.index
);

router.post('/service-orders',
  validate(schemas.serviceOrderSchema),
  upload.array('attachments', 5),
  serviceOrderController.store
);

router.get('/service-orders/:id',
  AuthMiddleware.hasDepartmentAccess,
  serviceOrderController.show
);

router.put('/service-orders/:id',
  AuthMiddleware.hasRole(['admin', 'technician']),
  validate(schemas.serviceOrderUpdateSchema),
  serviceOrderController.update
);

// Usuários
router.get('/users',
  AuthMiddleware.hasRole(['admin']),
  userController.index
);

router.post('/users',
  AuthMiddleware.hasRole(['admin']),
  validate(schemas.userSchema),
  userController.store
);

router.put('/users/:id',
  AuthMiddleware.hasRole(['admin']),
  validate(schemas.userUpdateSchema),
  userController.update
);

// Relatórios
router.get('/reports/maintenance',
  AuthMiddleware.hasRole(['admin', 'manager']),
  reportController.generateMaintenanceReport
);

router.get('/reports/equipment',
  AuthMiddleware.hasRole(['admin', 'manager']),
  reportController.generateEquipmentReport
);

router.get('/reports/performance',
  AuthMiddleware.hasRole(['admin', 'manager']),
  reportController.generatePerformanceReport
);

// Dashboard
router.get('/dashboard/stats',
  AuthMiddleware.hasDepartmentAccess,
  dashboardController.getStats
);

// Notificações
router.get('/notifications',
  notificationController.list
);

router.put('/notifications/preferences',
  notificationController.updatePreferences
);

router.put('/notifications/:id/read',
  notificationController.markAsRead
);

module.exports = router;

================
File: backend/src/services/AuditService.js
================
const { AuditLog, User } = require('../models');
const logger = require('../utils/logger');

class AuditService {
  constructor() {
    this.ignoredFields = ['updated_at', 'created_at'];
  }

  async logAction(params) {
    try {
      const {
        userId,
        action,
        entityType,
        entityId,
        oldValues,
        newValues,
        metadata = {}
      } = params;

      await AuditLog.create({
        user_id: userId,
        action,
        entity_type: entityType,
        entity_id: entityId,
        old_values: oldValues,
        new_values: newValues,
        metadata: {
          ...metadata,
          ip: metadata.ip,
          userAgent: metadata.userAgent,
          timestamp: new Date()
        }
      });

    } catch (error) {
      logger.error('Erro ao registrar log de auditoria:', error);
    }
  }

  async trackChanges(entity, changes, userId, metadata = {}) {
    const changedFields = Object.keys(changes)
      .filter(field => !this.ignoredFields.includes(field));

    if (changedFields.length === 0) return;

    const oldValues = {};
    const newValues = {};

    changedFields.forEach(field => {
      oldValues[field] = entity[field];
      newValues[field] = changes[field];
    });

    await this.logAction({
      userId,
      action: 'UPDATE',
      entityType: entity.constructor.name,
      entityId: entity.id,
      oldValues,
      newValues,
      metadata
    });
  }

  async getAuditTrail(params) {
    try {
      const {
        entityType,
        entityId,
        startDate,
        endDate,
        userId,
        page = 1,
        limit = 20
      } = params;

      const where = {};
      
      if (entityType) where.entity_type = entityType;
      if (entityId) where.entity_id = entityId;
      if (userId) where.user_id = userId;
      if (startDate || endDate) {
        where.created_at = {};
        if (startDate) where.created_at[Op.gte] = startDate;
        if (endDate) where.created_at[Op.lte] = endDate;
      }

      const logs = await AuditLog.findAndCountAll({
        where,
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'name', 'email']
          }
        ],
        order: [['created_at', 'DESC']],
        limit,
        offset: (page - 1) * limit
      });

      return {
        logs: logs.rows,
        total: logs.count,
        page,
        pages: Math.ceil(logs.count / limit)
      };

    } catch (error) {
      logger.error('Erro ao buscar logs de auditoria:', error);
      throw new Error('Falha ao buscar histórico de auditoria');
    }
  }

  async getEntityHistory(entityType, entityId) {
    try {
      const logs = await AuditLog.findAll({
        where: {
          entity_type: entityType,
          entity_id: entityId
        },
        include: [
          {
            model: User,
            as: 'user',
            attributes: ['id', 'name', 'email']
          }
        ],
        order: [['created_at', 'DESC']]
      });

      return this.formatEntityHistory(logs);

    } catch (error) {
      logger.error('Erro ao buscar histórico da entidade:', error);
      throw new Error('Falha ao buscar histórico');
    }
  }

  formatEntityHistory(logs) {
    return logs.map(log => {
      const changes = this.compareValues(log.old_values, log.new_values);
      
      return {
        id: log.id,
        date: log.created_at,
        user: log.user,
        action: log.action,
        changes,
        metadata: log.metadata
      };
    });
  }

  compareValues(oldValues, newValues) {
    const changes = [];
    const allFields = new Set([
      ...Object.keys(oldValues || {}),
      ...Object.keys(newValues || {})
    ]);

    allFields.forEach(field => {
      if (this.ignoredFields.includes(field)) return;

      const oldValue = oldValues?.[field];
      const newValue = newValues?.[field];

      if (oldValue !== newValue) {
        changes.push({
          field,
          from: oldValue,
          to: newValue
        });
      }
    });

    return changes;
  }

  // Migration para a tabela de auditoria
  static get migration() {
    return {
      up: async (queryInterface, Sequelize) => {
        await queryInterface.createTable('audit_logs', {
          id: {
            type: Sequelize.INTEGER,
            primaryKey: true,
            autoIncrement: true
          },
          user_id: {
            type: Sequelize.INTEGER,
            references: { model: 'users', key: 'id' },
            onUpdate: 'CASCADE',
            onDelete: 'SET NULL'
          },
          action: {
            type: Sequelize.STRING,
            allowNull: false
          },
          entity_type: {
            type: Sequelize.STRING,
            allowNull: false
          },
          entity_id: {
            type: Sequelize.INTEGER,
            allowNull: false
          },
          old_values: {
            type: Sequelize.JSONB
          },
          new_values: {
            type: Sequelize.JSONB
          },
          metadata: {
            type: Sequelize.JSONB
          },
          created_at: {
            type: Sequelize.DATE,
            allowNull: false
          },
          // Continuação da migration anterior...
          updated_at: {
            type: Sequelize.DATE,
            allowNull: false
          },
          ip_address: {
            type: Sequelize.STRING
          },
          user_agent: {
            type: Sequelize.STRING
          },
          browser: {
            type: Sequelize.STRING
          },
          platform: {
            type: Sequelize.STRING
          }
        });

        // Índices para melhor performance
        await queryInterface.addIndex('audit_logs', ['entity_type', 'entity_id']);
        await queryInterface.addIndex('audit_logs', ['user_id']);
        await queryInterface.addIndex('audit_logs', ['created_at']);
      },

      down: async (queryInterface) => {
        await queryInterface.dropTable('audit_logs');
      }
    };
  }
}

// Modelo Sequelize para AuditLog
const AuditLogModel = (sequelize, DataTypes) => {
  const AuditLog = sequelize.define('AuditLog', {
    id: {
      type: DataTypes.INTEGER,
      primaryKey: true,
      autoIncrement: true
    },
    user_id: {
      type: DataTypes.INTEGER,
      references: {
        model: 'users',
        key: 'id'
      }
    },
    action: {
      type: DataTypes.STRING,
      allowNull: false,
      validate: {
        isIn: [['CREATE', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT', 'FAILED_LOGIN']]
      }
    },
    entity_type: {
      type: DataTypes.STRING,
      allowNull: false
    },
    entity_id: {
      type: DataTypes.INTEGER,
      allowNull: false
    },
    old_values: {
      type: DataTypes.JSONB
    },
    new_values: {
      type: DataTypes.JSONB
    },
    metadata: {
      type: DataTypes.JSONB
    },
    ip_address: DataTypes.STRING,
    user_agent: DataTypes.STRING,
    browser: DataTypes.STRING,
    platform: DataTypes.STRING
  }, {
    tableName: 'audit_logs',
    timestamps: true
  });

  AuditLog.associate = (models) => {
    AuditLog.belongsTo(models.User, {
      foreignKey: 'user_id',
      as: 'user'
    });
  };

  return AuditLog;
};

// Middleware para capturar automaticamente mudanças nos modelos
const auditMiddleware = (schema) => {
  schema.addHook('beforeUpdate', async (instance, options) => {
    if (!options.userId) return;

    const changes = instance.changed();
    if (!changes) return;

    const oldValues = {};
    const newValues = {};

    changes.forEach(field => {
      oldValues[field] = instance._previousDataValues[field];
      newValues[field] = instance.dataValues[field];
    });

    await AuditLog.create({
      user_id: options.userId,
      action: 'UPDATE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      old_values: oldValues,
      new_values: newValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });

  schema.addHook('afterCreate', async (instance, options) => {
    if (!options.userId) return;

    await AuditLog.create({
      user_id: options.userId,
      action: 'CREATE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      new_values: instance.dataValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });

  schema.addHook('beforeDestroy', async (instance, options) => {
    if (!options.userId) return;

    await AuditLog.create({
      user_id: options.userId,
      action: 'DELETE',
      entity_type: instance.constructor.name,
      entity_id: instance.id,
      old_values: instance.dataValues,
      metadata: {
        ip: options.ip,
        userAgent: options.userAgent
      }
    });
  });
};

// Middleware Express para incluir informações de auditoria
const auditMiddlewareExpress = (req, res, next) => {
  if (req.user) {
    req.auditInfo = {
      userId: req.user.id,
      ip: req.ip,
      userAgent: req.get('user-agent'),
      browser: req.get('sec-ch-ua'),
      platform: req.get('sec-ch-ua-platform')
    };
  }
  next();
};

module.exports = {
  AuditService,
  AuditLogModel,
  auditMiddleware,
  auditMiddlewareExpress
};

================
File: backend/src/services/CacheService.js
================
const { getRedisClient } = require('../config/redis');
const logger = require('../utils/logger');

class CacheService {
  constructor() {
    this.redis = getRedisClient();
    this.defaultTTL = 3600; // 1 hora em segundos
  }

  async get(key) {
    try {
      const value = await this.redis.get(key);
      return value ? JSON.parse(value) : null;
    } catch (error) {
      logger.error('Erro ao recuperar do cache:', { key, error: error.message });
      return null;
    }
  }

  async set(key, value, ttl = this.defaultTTL) {
    try {
      await this.redis.set(
        key,
        JSON.stringify(value),
        'EX',
        ttl
      );
      return true;
    } catch (error) {
      logger.error('Erro ao definir cache:', { key, error: error.message });
      return false;
    }
  }

  async delete(key) {
    try {
      await this.redis.del(key);
      return true;
    } catch (error) {
      logger.error('Erro ao deletar cache:', { key, error: error.message });
      return false;
    }
  }

  async getOrSet(key, callback, ttl = this.defaultTTL) {
    let data = await this.get(key);
    
    if (!data) {
      data = await callback();
      if (data) {
        await this.set(key, data, ttl);
      }
    }

    return data;
  }

  async invalidatePattern(pattern) {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(keys);
      }
      return true;
    } catch (error) {
      logger.error('Erro ao invalidar padrão de cache:', { pattern, error: error.message });
      return false;
    }
  }

  generateKey(...args) {
    return args.join(':');
  }

  // Cache específico para equipamentos
  async getEquipmentCache(id) {
    return this.get(`equipment:${id}`);
  }

  async setEquipmentCache(id, data) {
    return this.set(`equipment:${id}`, data);
  }

  async invalidateEquipmentCache(id) {
    return this.delete(`equipment:${id}`);
  }

  // Cache para listagens com paginação
  async getListCache(entity, page, limit, filters = {}) {
    const filterString = JSON.stringify(filters);
    const key = this.generateKey(entity, 'list', page, limit, filterString);
    return this.get(key);
  }

  async setListCache(entity, page, limit, filters = {}, data) {
    const filterString = JSON.stringify(filters);
    const key = this.generateKey(entity, 'list', page, limit, filterString);
    return this.set(key, data, 300); // 5 minutos para listas
  }

  // Cache para dashboards
  async getDashboardCache(userId) {
    return this.get(`dashboard:${userId}`);
  }

  async setDashboardCache(userId, data) {
    return this.set(`dashboard:${userId}`, data, 900); // 15 minutos para dashboard
  }

  async clearAllCache() {
    try {
      await this.redis.flushall();
      return true;
    } catch (error) {
      logger.error('Erro ao limpar todo o cache:', error.message);
      return false;
    }
  }
}

module.exports = new CacheService();

================
File: backend/src/services/EmailService.js
================
const nodemailer = require('nodemailer');
const path = require('path');
const ejs = require('ejs');

class EmailService {
  constructor() {
    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      },
    });

    this.templatesPath = path.resolve(__dirname, '..', 'views', 'emails');
  }

  async sendMail({ to, subject, template, context }) {
    const templatePath = path.join(this.templatesPath, `${template}.ejs`);
    
    const html = await ejs.renderFile(templatePath, context);

    return this.transporter.sendMail({
      from: process.env.SMTP_FROM,
      to,
      subject,
      html,
    });
  }

  async sendMaintenanceNotification({ user, equipment, serviceOrder }) {
    return this.sendMail({
      to: user.email,
      subject: `Manutenção Agendada - ${equipment.name}`,
      template: 'maintenance-notification',
      context: {
        userName: user.name,
        equipmentName: equipment.name,
        equipmentCode: equipment.code,
        maintenanceDate: serviceOrder.scheduled_for,
        maintenanceType: serviceOrder.type,
        description: serviceOrder.description,
      },
    });
  }

  async sendMaintenanceComplete({ user, equipment, serviceOrder }) {
    return this.sendMail({
      to: user.email,
      subject: `Manutenção Concluída - ${equipment.name}`,
      template: 'maintenance-complete',
      context: {
        userName: user.name,
        equipmentName: equipment.name,
        equipmentCode: equipment.code,
        completedDate: serviceOrder.completed_at,
        maintenanceType: serviceOrder.type,
        description: serviceOrder.description,
      },
    });
  }
}

module.exports = new EmailService();

================
File: backend/src/services/FileService.js
================
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

class FileService {
  constructor() {
    this.uploadPath = path.resolve(__dirname, '..', '..', 'uploads');
    this.ensureUploadDirectory();
  }

  ensureUploadDirectory() {
    if (!fs.existsSync(this.uploadPath)) {
      fs.mkdirSync(this.uploadPath, { recursive: true });
    }
  }

  async saveFile(file) {
    const hash = crypto.randomBytes(10).toString('hex');
    const fileName = `${hash}-${file.originalname}`;
    const filePath = path.join(this.uploadPath, fileName);

    return new Promise((resolve, reject) => {
      fs.writeFile(filePath, file.buffer, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve({
          name: fileName,
          path: filePath,
          url: `/uploads/${fileName}`,
        });
      });
    });
  }

  async deleteFile(fileName) {
    const filePath = path.join(this.uploadPath, fileName);
    return new Promise((resolve, reject) => {
      fs.unlink(filePath, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
  }
}

module.exports = new FileService();

================
File: backend/src/services/MediaService.js
================
const AWS = require('aws-sdk');
const path = require('path');
const sharp = require('sharp');
const { v4: uuid } = require('uuid');

class MediaService {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });
    this.bucketName = process.env.AWS_BUCKET_NAME;
  }

  async uploadPhoto(file, folder = 'photos') {
    try {
      // Processa a imagem com sharp
      const processedImage = await sharp(file.buffer)
        .resize(1200, 1200, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({ quality: 80 })
        .toBuffer();

      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;

      const uploadParams = {
        Bucket: this.bucketName,
        Key: fileName,
        Body: processedImage,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(uploadParams).promise();

      return {
        url: result.Location,
        key: fileName
      };
    } catch (error) {
      console.error('Erro no upload da foto:', error);
      throw new Error('Falha no upload da foto');
    }
  }

  async uploadFile(file, folder = 'attachments') {
    try {
      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;

      const uploadParams = {
        Bucket: this.bucketName,
        Key: fileName,
        Body: file.buffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(uploadParams).promise();

      return {
        url: result.Location,
        key: fileName,
        name: file.originalname,
        type: file.mimetype
      };
    } catch (error) {
      console.error('Erro no upload do arquivo:', error);
      throw new Error('Falha no upload do arquivo');
    }
  }

  async deleteFile(key) {
    try {
      const deleteParams = {
        Bucket: this.bucketName,
        Key: key
      };

      await this.s3.deleteObject(deleteParams).promise();
    } catch (error) {
      console.error('Erro ao deletar arquivo:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async getSignedUrl(key, expirationInSeconds = 3600) {
    try {
      const params = {
        Bucket: this.bucketName,
        Key: key,
        Expires: expirationInSeconds
      };

      return await this.s3.getSignedUrlPromise('getObject', params);
    } catch (error) {
      console.error('Erro ao gerar URL assinada:', error);
      throw new Error('Falha ao gerar URL de acesso');
    }
  }
}

module.exports = new MediaService();

================
File: backend/src/services/NotificationService.js
================
const AWS = require('aws-sdk');
const nodemailer = require('nodemailer');
const cron = require('node-cron');
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const { Op } = require('sequelize');
const logger = require('../utils/logger');

class NotificationService {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });

    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });

    // Inicia os jobs de verificação
    this.initializeJobs();
  }

  initializeJobs() {
    // Verifica manutenções pendentes diariamente às 8h
    cron.schedule('0 8 * * *', () => {
      this.checkPendingMaintenances();
    });

    // Verifica equipamentos com manutenções frequentes semanalmente
    cron.schedule('0 9 * * 1', () => {
      this.checkFrequentMaintenances();
    });
  }

  async uploadFile(file, folder = 'general') {
    try {
      const fileName = `${folder}/${Date.now()}-${file.originalname}`;
      
      const params = {
        Bucket: process.env.AWS_BUCKET_NAME,
        Key: fileName,
        Body: file.buffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(params).promise();
      return result.Location;
    } catch (error) {
      logger.error('Erro no upload para S3:', error);
      throw new Error('Falha no upload do arquivo');
    }
  }

  async deleteFile(fileUrl) {
    try {
      const key = fileUrl.split(`${process.env.AWS_BUCKET_NAME}/`)[1];
      
      await this.s3.deleteObject({
        Bucket: process.env.AWS_BUCKET_NAME,
        Key: key
      }).promise();
      
      return true;
    } catch (error) {
      logger.error('Erro ao deletar arquivo do S3:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async checkPendingMaintenances() {
    try {
      const today = new Date();
      const maintenances = await Maintenance.findAll({
        where: {
          status: 'pending',
          scheduled_for: {
            [Op.lte]: today
          }
        },
        include: [
          {
            model: Equipment,
            attributes: ['name', 'code', 'department']
          }
        ]
      });

      if (maintenances.length > 0) {
        // Busca administradores
        const admins = await User.findAll({
          where: { role: 'admin' }
        });

        // Envia notificações
        for (const admin of admins) {
          await this.sendPendingMaintenanceEmail(admin, maintenances);
        }
      }
    } catch (error) {
      logger.error('Erro ao verificar manutenções pendentes:', error);
    }
  }

  async checkFrequentMaintenances() {
    try {
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      // Busca equipamentos com mais de 3 manutenções nos últimos 30 dias
      const equipments = await Equipment.findAll({
        include: [{
          model: Maintenance,
          where: {
            created_at: {
              [Op.gte]: thirtyDaysAgo
            }
          }
        }],
        having: sequelize.literal('COUNT(Maintenances.id) > 3'),
        group: ['Equipment.id']
      });

      if (equipments.length > 0) {
        const admins = await User.findAll({ where: { role: 'admin' } });
        for (const admin of admins) {
          await this.sendFrequentMaintenanceAlert(admin, equipments);
        }
      }
    } catch (error) {
      logger.error('Erro ao verificar manutenções frequentes:', error);
    }
  }

  async sendPendingMaintenanceEmail(user, maintenances) {
    const mailOptions = {
      from: process.env.SMTP_FROM,
      to: user.email,
      subject: 'Manutenções Pendentes - Atenção Necessária',
      html: `
        <h2>Manutenções Pendentes</h2>
        <p>As seguintes manutenções estão pendentes e requerem atenção:</p>
        <ul>
          ${maintenances.map(m => `
            <li>
              <strong>${m.Equipment.name}</strong> (${m.Equipment.code})<br>
              Departamento: ${m.Equipment.department}<br>
              Agendado para: ${m.scheduled_for.toLocaleDateString()}
            </li>
          `).join('')}
        </ul>
      `
    };

    await this.transporter.sendMail(mailOptions);
  }

  async sendFrequentMaintenanceAlert(user, equipments) {
    const mailOptions = {
      from: process.env.SMTP_FROM,
      to: user.email,
      subject: 'Alerta - Equipamentos com Manutenções Frequentes',
      html: `
        <h2>Equipamentos com Manutenções Frequentes</h2>
        <p>Os seguintes equipamentos apresentaram mais de 3 manutenções nos últimos 30 dias:</p>
        <ul>
          ${equipments.map(e => `
            <li>
              <strong>${e.name}</strong> (${e.code})<br>
              Departamento: ${e.department}<br>
              Total de manutenções: ${e.Maintenances.length}
            </li>
          `).join('')}
        </ul>
      `
    };

    await this.transporter.sendMail(mailOptions);
  }
}

module.exports = new NotificationService();

================
File: backend/src/services/PDFService.js
================
const PDFDocument = require('pdfkit');
const { format } = require('date-fns');
const ptBR = require('date-fns/locale/pt-BR');

class PDFService {
  createMaintenanceReport(equipment, maintenances) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Cabeçalho
        doc.fontSize(20).text('Relatório de Manutenções', { align: 'center' });
        doc.moveDown();

        // Informações do Equipamento
        doc.fontSize(16).text('Dados do Equipamento');
        doc.fontSize(12)
           .text(`Nome: ${equipment.name}`)
           .text(`Código: ${equipment.code}`)
           .text(`Departamento: ${equipment.department}`)
           .text(`Status: ${equipment.status}`);
        
        doc.moveDown();

        // Resumo
        const totalCost = maintenances.reduce((sum, m) => sum + (m.cost || 0), 0);
        doc.fontSize(16).text('Resumo');
        doc.fontSize(12)
           .text(`Total de Manutenções: ${maintenances.length}`)
           .text(`Custo Total: R$ ${totalCost.toFixed(2)}`);
        
        doc.moveDown();

        // Lista de Manutenções
        doc.fontSize(16).text('Histórico de Manutenções');
        doc.moveDown();

        maintenances.forEach(maintenance => {
          doc.fontSize(12)
             .text(`Data: ${format(new Date(maintenance.maintenance_date), 'dd/MM/yyyy')}`)
             .text(`Tipo: ${maintenance.type}`)
             .text(`Descrição: ${maintenance.description}`)
             .text(`Custo: R$ ${maintenance.cost?.toFixed(2) || '0,00'}`)
             .text(`Técnico: ${maintenance.technician?.name || 'Não informado'}`);
          
          if (maintenance.parts_replaced?.length > 0) {
            doc.text('Peças Substituídas:');
            maintenance.parts_replaced.forEach(part => {
              doc.text(`  - ${part.name}: ${part.quantity} unidade(s)`);
            });
          }

          doc.moveDown();
        });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }

  createEquipmentReport(equipments) {
    return new Promise((resolve, reject) => {
      try {
        const doc = new PDFDocument();
        const chunks = [];

        doc.on('data', chunk => chunks.push(chunk));
        doc.on('end', () => resolve(Buffer.concat(chunks)));

        // Cabeçalho
        doc.fontSize(20).text('Relatório de Equipamentos', { align: 'center' });
        doc.moveDown();

        // Resumo por Departamento
        const departmentSummary = equipments.reduce((acc, eq) => {
          acc[eq.department] = (acc[eq.department] || 0) + 1;
          return acc;
        }, {});

        doc.fontSize(16).text('Resumo por Departamento');
        Object.entries(departmentSummary).forEach(([dept, count]) => {
          doc.fontSize(12).text(`${dept}: ${count} equipamento(s)`);
        });
        
        doc.moveDown();

        // Lista de Equipamentos
        doc.fontSize(16).text('Lista de Equipamentos');
        doc.moveDown();

        equipments.forEach(equipment => {
          doc.fontSize(12)
             .text(`Nome: ${equipment.name}`)
             .text(`Código: ${equipment.code}`)
             .text(`Departamento: ${equipment.department}`)
             .text(`Status: ${equipment.status}`)
             .text(`Última Manutenção: ${equipment.last_maintenance ? 
               format(new Date(equipment.last_maintenance), 'dd/MM/yyyy') : 
               'Nunca realizada'}`);
          
          doc.moveDown();
        });

        doc.end();
      } catch (error) {
        reject(error);
      }
    });
  }
}

module.exports = new PDFService();

================
File: backend/src/services/PushNotificationService.js
================
import * as Notifications from 'expo-notifications';
import * as Device from 'expo-device';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Platform } from 'react-native';

class PushNotificationService {
  constructor() {
    this.configure();
  }

  async configure() {
    if (Device.isDevice) {
      const { status: existingStatus } = await Notifications.getPermissionsAsync();
      let finalStatus = existingStatus;
      
      if (existingStatus !== 'granted') {
        const { status } = await Notifications.requestPermissionsAsync();
        finalStatus = status;
      }

      if (finalStatus !== 'granted') {
        console.log('Permissão para notificações não concedida!');
        return;
      }

      const token = await this.getDevicePushToken();
      if (token) {
        await this.registerDeviceToken(token);
      }
    }

    // Configuração das notificações
    Notifications.setNotificationHandler({
      handleNotification: async () => ({
        shouldShowAlert: true,
        shouldPlaySound: true,
        shouldSetBadge: true,
      }),
    });
  }

  async getDevicePushToken() {
    try {
      const token = await Notifications.getExpoPushTokenAsync({
        experienceId: '@your-org/your-app'
      });
      return token.data;
    } catch (error) {
      console.error('Erro ao obter token:', error);
      return null;
    }
  }

  async registerDeviceToken(token) {
    try {
      const userId = await AsyncStorage.getItem('userId');
      if (!userId) return;

      await fetch(`${process.env.API_URL}/users/push-token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${await AsyncStorage.getItem('token')}`
        },
        body: JSON.stringify({
          token,
          device: Platform.OS,
          userId
        })
      });
    } catch (error) {
      console.error('Erro ao registrar token:', error);
    }
  }

  async scheduleLocalNotification(title, body, data = {}, trigger = null) {
    try {
      const notificationId = await Notifications.scheduleNotificationAsync({
        content: {
          title,
          body,
          data,
          sound: true,
          priority: 'high',
        },
        trigger: trigger || null,
      });
      return notificationId;
    } catch (error) {
      console.error('Erro ao agendar notificação:', error);
    }
  }

  async cancelNotification(notificationId) {
    try {
      await Notifications.cancelScheduledNotificationAsync(notificationId);
    } catch (error) {
      console.error('Erro ao cancelar notificação:', error);
    }
  }

  async setBadgeCount(count) {
    try {
      await Notifications.setBadgeCountAsync(count);
    } catch (error) {
      console.error('Erro ao definir badge:', error);
    }
  }

  addNotificationReceivedListener(callback) {
    return Notifications.addNotificationReceivedListener(callback);
  }

  addNotificationResponseReceivedListener(callback) {
    return Notifications.addNotificationResponseReceivedListener(callback);
  }

  removeNotificationSubscription(subscription) {
    subscription.remove();
  }

  // Helpers para tipos específicos de notificações
  async scheduleMaintenance(maintenance) {
    const scheduledDate = new Date(maintenance.scheduled_for);
    
    // Notificação 24h antes
    await this.scheduleLocalNotification(
      'Manutenção Agendada',
      `Manutenção do equipamento ${maintenance.equipment.name} amanhã`,
      { maintenanceId: maintenance.id },
      {
        date: new Date(scheduledDate.getTime() - 24 * 60 * 60 * 1000)
      }
    );

    // Notificação 1h antes
    await this.scheduleLocalNotification(
      'Manutenção em Breve',
      `Manutenção do equipamento ${maintenance.equipment.name} em 1 hora`,
      { maintenanceId: maintenance.id },
      {
        date: new Date(scheduledDate.getTime() - 60 * 60 * 1000)
      }
    );
  }

  async notifyMaintenanceComplete(maintenance) {
    await this.scheduleLocalNotification(
      'Manutenção Concluída',
      `A manutenção do equipamento ${maintenance.equipment.name} foi finalizada`,
      { maintenanceId: maintenance.id }
    );
  }

  async notifyMaintenanceOverdue(maintenance) {
    await this.scheduleLocalNotification(
      'Manutenção Atrasada',
      `A manutenção do equipamento ${maintenance.equipment.name} está atrasada`,
      { maintenanceId: maintenance.id }
    );
  }
}

export default new PushNotificationService();

================
File: backend/src/services/QRCodeService.js
================
const QRCode = require('qrcode');
const { v4: uuid } = require('uuid');
const S3Service = require('./S3Service');
const logger = require('../utils/logger');

class QRCodeService {
  constructor() {
    this.baseUrl = process.env.APP_URL;
    this.defaultOptions = {
      errorCorrectionLevel: 'H',
      type: 'svg',
      margin: 1,
      color: {
        dark: '#000000',
        light: '#ffffff'
      }
    };
  }

  async generateForEquipment(equipment) {
    try {
      const data = {
        id: equipment.id,
        code: equipment.code,
        type: 'equipment',
        timestamp: new Date().toISOString()
      };

      const qrUrl = `${this.baseUrl}/equipment/scan/${equipment.id}`;
      
      // Gera o QR Code como SVG
      const qrSvg = await QRCode.toString(qrUrl, {
        ...this.defaultOptions,
        width: 300
      });

      // Converte SVG para Buffer para upload
      const qrBuffer = Buffer.from(qrSvg);

      // Upload para S3
      const fileName = `qrcodes/equipment/${equipment.id}-${uuid()}.svg`;
      const uploaded = await S3Service.uploadFile({
        buffer: qrBuffer,
        originalname: fileName,
        mimetype: 'image/svg+xml'
      }, 'qrcodes');

      return {
        url: uploaded.url,
        key: uploaded.key,
        data: qrUrl
      };

    } catch (error) {
      logger.error('Erro ao gerar QR Code:', error);
      throw new Error('Falha ao gerar QR Code');
    }
  }

  async generateBatch(equipments) {
    try {
      const results = await Promise.all(
        equipments.map(equipment => this.generateForEquipment(equipment))
      );

      return results;
    } catch (error) {
      logger.error('Erro ao gerar lote de QR Codes:', error);
      throw new Error('Falha ao gerar QR Codes em lote');
    }
  }

  async generatePrintableSheet(equipments) {
    try {
      const qrCodes = await this.generateBatch(equipments);

      // Gera HTML para impressão
      const html = this.generatePrintTemplate(equipments, qrCodes);

      // Converte HTML para PDF
      const pdf = await this.convertToPDF(html);

      // Upload do PDF para S3
      const fileName = `qrcodes/sheets/batch-${uuid()}.pdf`;
      const uploaded = await S3Service.uploadFile({
        buffer: pdf,
        originalname: fileName,
        mimetype: 'application/pdf'
      }, 'qrcodes');

      return uploaded.url;

    } catch (error) {
      logger.error('Erro ao gerar folha de QR Codes:', error);
      throw new Error('Falha ao gerar folha de QR Codes');
    }
  }

  generatePrintTemplate(equipments, qrCodes) {
    return `
      <!DOCTYPE html>
      <html>
        <head>
          <style>
            .qr-container {
              display: inline-block;
              margin: 10px;
              padding: 15px;
              border: 1px solid #ccc;
              text-align: center;
            }
            .qr-code {
              width: 200px;
              height: 200px;
            }
            .qr-info {
              margin-top: 10px;
              font-family: Arial, sans-serif;
            }
          </style>
        </head>
        <body>
          ${qrCodes.map((qr, index) => `
            <div class="qr-container">
              <img src="${qr.url}" class="qr-code"/>
              <div class="qr-info">
                <strong>${equipments[index].name}</strong><br/>
                Código: ${equipments[index].code}
              </div>
            </div>
          `).join('')}
        </body>
      </html>
    `;
  }

  validateQRCode(qrData) {
    try {
      // Verifica se o QR Code é válido e pertence ao sistema
      const url = new URL(qrData);
      return url.origin === this.baseUrl && url.pathname.includes('/equipment/scan/');
    } catch (error) {
      return false;
    }
  }
}

module.exports = new QRCodeService();

================
File: backend/src/services/ReportService.js
================
const ExcelJS = require('exceljs');
const {Equipment} = require('../models/Equipment');
const {Maintenance} = require('../models/Maintenance')
const {User} = require('../models/User');
const { Op } = require('sequelize');

class ReportService {
  async generateMaintenanceReport(startDate, endDate, department = null) {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Manutenções');

    // Define cabeçalhos
    worksheet.columns = [
      { header: 'Equipamento', key: 'equipment', width: 20 },
      { header: 'Código', key: 'code', width: 15 },
      { header: 'Departamento', key: 'department', width: 15 },
      { header: 'Tipo', key: 'type', width: 15 },
      { header: 'Data', key: 'date', width: 15 },
      { header: 'Status', key: 'status', width: 15 },
      { header: 'Técnico', key: 'technician', width: 20 },
      { header: 'Custo', key: 'cost', width: 15 }
    ];

    // Aplica estilo aos cabeçalhos
    worksheet.getRow(1).font = { bold: true };
    worksheet.getRow(1).fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: 'FFE0E0E0' }
    };

    // Busca dados
    const query = {
      where: {
        created_at: {
          [Op.between]: [startDate, endDate]
        }
      },
      include: [
        {
          model: Equipment,
          ...(department && {
            where: { department }
          })
        },
        {
          model: User,
          as: 'technician',
          attributes: ['name']
        }
      ]
    };

    const maintenances = await Maintenance.findAll(query);

    // Adiciona dados
    maintenances.forEach(maintenance => {
      worksheet.addRow({
        equipment: maintenance.Equipment.name,
        code: maintenance.Equipment.code,
        department: maintenance.Equipment.department,
        type: maintenance.type,
        date: maintenance.maintenance_date.toLocaleDateString(),
        status: maintenance.status,
        technician: maintenance.technician?.name || 'N/A',
        cost: maintenance.cost || 0
      });
    });

    // Aplica formatação condicional para status
    worksheet.addConditionalFormatting({
      ref: 'F2:F1000',
      rules: [
        {
          type: 'cellIs',
          operator: 'equal',
          formulae: ['"completed"'],
          style: { fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FF90EE90' } } }
        },
        {
          type: 'cellIs',
          operator: 'equal',
          formulae: ['"pending"'],
          style: { fill: { type: 'pattern', pattern: 'solid', bgColor: { argb: 'FFFFCCCB' } } }
        }
      ]
    });

    // Formata coluna de custo
    worksheet.getColumn('cost').numFmt = '"R$ "#,##0.00';

    // Adiciona totais
    const lastRow = worksheet.rowCount + 2;
    worksheet.addRow(['Total de Manutenções:', maintenances.length]);
    worksheet.addRow([
      'Custo Total:',
      {
        formula: `SUM(H2:H${worksheet.rowCount-2})`,
        numFmt: '"R$ "#,##0.00'
      }
    ]);

    // Retorna o buffer
    return await workbook.xlsx.writeBuffer();
  }

  async generateEquipmentReport() {
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Equipamentos');

    worksheet.columns = [
      { header: 'Nome', key: 'name', width: 20 },
      { header: 'Código', key: 'code', width: 15 },
      { header: 'Departamento', key: 'department', width: 15 },
      { header: 'Status', key: 'status', width: 15 },
      { header: 'Total Manutenções', key: 'maintenances', width: 18 },
      { header: 'Última Manutenção', key: 'lastMaintenance', width: 18 },
      { header: 'Custo Total', key: 'totalCost', width: 15 }
    ];

    const equipments = await Equipment.findAll({
      include: [{
        model: Maintenance,
        attributes: ['maintenance_date', 'cost']
      }]
    });

    equipments.forEach(equipment => {
      worksheet.addRow({
        name: equipment.name,
        code: equipment.code,
        department: equipment.department,
        status: equipment.status,
        maintenances: equipment.Maintenances.length,
        lastMaintenance: equipment.Maintenances.length ? 
          new Date(Math.max(...equipment.Maintenances.map(m => m.maintenance_date))).toLocaleDateString() : 
          'N/A',
        totalCost: equipment.Maintenances.reduce((sum, m) => sum + (m.cost || 0), 0)
      });
    });

    // Estilização e formatação
    worksheet.getRow(1).font = { bold: true };
    worksheet.getColumn('totalCost').numFmt = '"R$ "#,##0.00';

    return await workbook.xlsx.writeBuffer();
  }
}

module.exports = new ReportService();

================
File: backend/src/services/S3Service.js
================
const AWS = require('aws-sdk');
const sharp = require('sharp');
const mime = require('mime-types');
const path = require('path');
const { v4: uuid } = require('uuid');
const logger = require('../utils/logger');

class S3Service {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });
    this.bucket = process.env.AWS_BUCKET_NAME;
    this.allowedMimes = [
      'image/jpeg',
      'image/png',
      'image/webp',
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];
  }

  async uploadFile(file, folder = 'general') {
    try {
      if (!this.allowedMimes.includes(file.mimetype)) {
        throw new Error('Tipo de arquivo não permitido');
      }

      const fileName = `${folder}/${uuid()}${path.extname(file.originalname)}`;
      let processedBuffer = file.buffer;

      // Processa imagens antes do upload
      if (file.mimetype.startsWith('image/')) {
        processedBuffer = await this.processImage(file.buffer);
      }

      const params = {
        Bucket: this.bucket,
        Key: fileName,
        Body: processedBuffer,
        ContentType: file.mimetype,
        ACL: 'public-read'
      };

      const result = await this.s3.upload(params).promise();

      return {
        url: result.Location,
        key: fileName,
        type: file.mimetype,
        size: processedBuffer.length
      };

    } catch (error) {
      logger.error('Erro no upload para S3:', error);
      throw new Error('Falha ao fazer upload do arquivo');
    }
  }

  async processImage(buffer) {
    try {
      return await sharp(buffer)
        .resize(1200, 1200, {
          fit: 'inside',
          withoutEnlargement: true
        })
        .jpeg({
          quality: 80,
          progressive: true
        })
        .toBuffer();
    } catch (error) {
      logger.error('Erro ao processar imagem:', error);
      throw new Error('Falha ao processar imagem');
    }
  }

  async deleteFile(key) {
    try {
      await this.s3.deleteObject({
        Bucket: this.bucket,
        Key: key
      }).promise();

      return true;
    } catch (error) {
      logger.error('Erro ao deletar arquivo do S3:', error);
      throw new Error('Falha ao deletar arquivo');
    }
  }

  async generateSignedUrl(key, expiresIn = 3600) {
    try {
      return await this.s3.getSignedUrlPromise('getObject', {
        Bucket: this.bucket,
        Key: key,
        Expires: expiresIn
      });
    } catch (error) {
      logger.error('Erro ao gerar URL assinada:', error);
      throw new Error('Falha ao gerar URL de acesso');
    }
  }

  async moveFile(oldKey, newKey) {
    try {
      // Copia o arquivo para novo local
      await this.s3.copyObject({
        Bucket: this.bucket,
        CopySource: `${this.bucket}/${oldKey}`,
        Key: newKey,
        ACL: 'public-read'
      }).promise();

      // Remove arquivo original
      await this.deleteFile(oldKey);

      return true;
    } catch (error) {
      logger.error('Erro ao mover arquivo:', error);
      throw new Error('Falha ao mover arquivo');
    }
  }
}

module.exports = new S3Service();

================
File: backend/src/services/WebSocketService.js
================
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');
const http = require('http');

class WebSocketService {
  constructor(server) {
    this.wss = new WebSocket.Server({ server });
    this.clients = new Map(); // Map para armazenar conexões de clientes
    this.initialize();
  }

  initialize() {
    this.wss.on('connection', async (ws, req) => {
      try {
        // Autenticação do WebSocket
        const token = this.extractToken(req);
        if (!token) {
          ws.close(4001, 'Unauthorized');
          return;
        }

        const user = await this.authenticateToken(token);
        if (!user) {
          ws.close(4001, 'Invalid token');
          return;
        }

        // Armazena a conexão do cliente
        this.clients.set(user.id, {
          ws,
          user
        });

        // Setup de heartbeat
        ws.isAlive = true;
        ws.on('pong', () => {
          ws.isAlive = true;
        });

        // Listener de mensagens
        ws.on('message', async (message) => {
          try {
            await this.handleMessage(user.id, JSON.parse(message));
          } catch (error) {
            console.error('Erro ao processar mensagem:', error);
            this.sendError(ws, error.message);
          }
        });

        // Listener de fechamento
        ws.on('close', () => {
          this.clients.delete(user.id);
        });

        // Envia confirmação de conexão
        this.sendToClient(user.id, {
          type: 'CONNECTION_ESTABLISHED',
          data: {
            userId: user.id,
            timestamp: new Date()
          }
        });

      } catch (error) {
        console.error('Erro na conexão WebSocket:', error);
        ws.close(4000, 'Internal server error');
      }
    });

    // Configuração do heartbeat
    setInterval(() => {
      this.wss.clients.forEach((ws) => {
        if (!ws.isAlive) {
          return ws.terminate();
        }
        ws.isAlive = false;
        ws.ping(() => {});
      });
    }, 30000);
  }

  async handleMessage(userId, message) {
    const { type, data } = message;

    switch (type) {
      case 'MAINTENANCE_UPDATE':
        await this.handleMaintenanceUpdate(userId, data);
        break;

      case 'EQUIPMENT_STATUS_CHANGE':
        await this.handleEquipmentStatusChange(userId, data);
        break;

      case 'JOIN_EQUIPMENT_ROOM':
        await this.handleJoinEquipmentRoom(userId, data);
        break;

      default:
        throw new Error('Tipo de mensagem não suportado');
    }
  }

  async handleMaintenanceUpdate(userId, data) {
    // Notifica todos os admins e o técnico responsável
    const notification = {
      type: 'MAINTENANCE_UPDATED',
      data: {
        maintenanceId: data.maintenanceId,
        status: data.status,
        updatedBy: userId,
        timestamp: new Date()
      }
    };

    await this.notifyAdmins(notification);
    if (data.technicianId) {
      this.sendToClient(data.technicianId, notification);
    }
  }

  async handleEquipmentStatusChange(userId, data) {
    const notification = {
      type: 'EQUIPMENT_STATUS_CHANGED',
      data: {
        equipmentId: data.equipmentId,
        status: data.status,
        changedBy: userId,
        timestamp: new Date()
      }
    };

    await this.notifyDepartment(data.departmentId, notification);
  }

  async handleJoinEquipmentRoom(userId, data) {
    const client = this.clients.get(userId);
    if (client) {
      client.equipmentRooms = client.equipmentRooms || new Set();
      client.equipmentRooms.add(data.equipmentId);
    }
  }

  // Envia mensagem para um cliente específico
  sendToClient(userId, message) {
    const client = this.clients.get(userId);
    if (client && client.ws.readyState === WebSocket.OPEN) {
      client.ws.send(JSON.stringify(message));
    }
  }

  // Envia mensagem para todos os admins
  async notifyAdmins(message) {
    this.clients.forEach((client) => {
      if (client.user.role === 'admin' && client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(JSON.stringify(message));
      }
    });
  }

  // Envia mensagem para todos os usuários de um departamento
  async notifyDepartment(departmentId, message) {
    this.clients.forEach((client) => {
      if (client.user.departmentId === departmentId && client.ws.readyState === WebSocket.OPEN) {
        client.ws.send(JSON.stringify(message));
      }
    });
  }

  // Envia mensagem de erro para um cliente
  sendError(ws, message) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'ERROR',
        data: { message }
      }));
    }
  }

  // Extrai token do request
  extractToken(req) {
    const auth = req.headers.authorization;
    if (!auth) return null;
    return auth.replace('Bearer ', '');
  }

  // Autentica o token
  async authenticateToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findByPk(decoded.id);
      return user;
    } catch (error) {
      return null;
    }
  }

  // Broadcast para todos os clientes conectados
  broadcast(message) {
    this.wss.clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(JSON.stringify(message));
      }
    });
  }
}

module.exports = WebSocketService;

================
File: backend/src/utils/logger.js
================
const winston = require('winston');
const DailyRotateFile = require('winston-daily-rotate-file');
const path = require('path');

const logDir = 'logs';
const { combine, timestamp, printf, colorize, errors } = winston.format;

const customFormat = printf(({ level, message, timestamp, ...metadata }) => {
  let msg = `${timestamp} [${level}] : ${message}`;
  
  if (Object.keys(metadata).length > 0) {
    msg += ` ${JSON.stringify(metadata)}`;
  }
  
  return msg;
});

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: combine(
    timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    errors({ stack: true }),
    customFormat
  ),
  transports: [
    // Logs de erro
    new DailyRotateFile({
      filename: path.join(logDir, 'error-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      level: 'error',
      maxSize: '20m',
      maxFiles: '14d',
      zippedArchive: true
    }),

    // Logs gerais
    new DailyRotateFile({
      filename: path.join(logDir, 'combined-%DATE%.log'),
      datePattern: 'YYYY-MM-DD',
      maxSize: '20m',
      maxFiles: '14d',
      zippedArchive: true
    })
  ]
});

// Adiciona logs no console em desenvolvimento
if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: combine(
      colorize(),
      customFormat
    )
  }));
}

module.exports = logger;

================
File: backend/src/validations/schemas.js
================
const yup = require('yup');

const schemas = {
  loginSchema: yup.object().shape({
    email: yup.string()
      .email('Email inválido')
      .required('Email é obrigatório'),
    password: yup.string()
      .required('Senha é obrigatória')
  }),

  equipmentSchema: yup.object().shape({
    name: yup.string()
      .required('Nome é obrigatório')
      .min(3, 'Nome deve ter no mínimo 3 caracteres'),
    code: yup.string()
      .required('Código é obrigatório')
      .matches(/^[A-Za-z0-9-]+$/, 'Código deve conter apenas letras, números e hífen'),
    department: yup.string()
      .required('Departamento é obrigatório'),
    description: yup.string()
      .max(500, 'Descrição deve ter no máximo 500 caracteres'),
    maintenance_frequency: yup.number()
      .min(1, 'Frequência deve ser maior que 0')
  }),

  maintenanceSchema: yup.object().shape({
    equipment_id: yup.number()
      .required('Equipamento é obrigatório'),
    description: yup.string()
      .required('Descrição é obrigatória')
      .min(10, 'Descrição deve ter no mínimo 10 caracteres'),
    type: yup.string()
      .oneOf(['corrective', 'preventive', 'predictive'], 'Tipo inválido')
      .required('Tipo é obrigatório'),
    cost: yup.number()
      .min(0, 'Custo não pode ser negativo'),
    notes: yup.string()
      .max(1000, 'Observações devem ter no máximo 1000 caracteres')
  }),

  maintenanceUpdateSchema: yup.object().shape({
    status: yup.string()
      .oneOf(['pending', 'in_progress', 'completed', 'cancelled'], 'Status inválido')
      .required('Status é obrigatório'),
    completion_notes: yup.string()
      .when('status', {
        is: 'completed',
        then: yup.string().required('Notas de conclusão são obrigatórias')
      }),
    cost: yup.number()
      .min(0, 'Custo não pode ser negativo')
  })
};

module.exports = schemas;

================
File: backend/src/views/emails/maintenance-complete.ejs
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      background-color: #f8f9fa;
      padding: 20px;
      text-align: center;
      border-bottom: 3px solid #007bff;
    }
    .content {
      padding: 20px;
    }
    .footer {
      text-align: center;
      padding: 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>Manutenção Concluída</h2>
    </div>
    <div class="content">
      <p>Olá <%= userName %>,</p>
      
      <p>A manutenção do equipamento foi concluída:</p>
      
      <ul>
        <li><strong>Equipamento:</strong> <%= equipmentName %></li>
        <li><strong>Código:</strong> <%= equipmentCode %></li>
        <li><strong>Data Conclusão:</strong> <%= completedDate.toLocaleDateString() %></li>
        <li><strong>Tipo:</strong> <%= maintenanceType %></li>
      </ul>

      <p><strong>Detalhes da Manutenção:</strong></p>
      <p><%= description %></p>
    </div>
    <div class="footer">
      <p>Esta é uma mensagem automática, não responda este email.</p>
    </div>
  </div>
</body>
</html>

================
File: backend/src/views/emails/maintenance-notification.ejs
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
    }
    .container {
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    .header {
      background-color: #f8f9fa;
      padding: 20px;
      text-align: center;
      border-bottom: 3px solid #007bff;
    }
    .content {
      padding: 20px;
    }
    .footer {
      text-align: center;
      padding: 20px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h2>Manutenção Agendada</h2>
    </div>
    <div class="content">
      <p>Olá <%= userName %>,</p>
      
      <p>Uma nova manutenção foi agendada para o equipamento:</p>
      
      <ul>
        <li><strong>Equipamento:</strong> <%= equipmentName %></li>
        <li><strong>Código:</strong> <%= equipmentCode %></li>
        <li><strong>Data Agendada:</strong> <%= maintenanceDate.toLocaleDateString() %></li>
        <li><strong>Tipo:</strong> <%= maintenanceType %></li>
      </ul>

      <p><strong>Descrição:</strong></p>
      <p><%= description %></p>
    </div>
    <div class="footer">
      <p>Esta é uma mensagem automática, não responda este email.</p>
    </div>
  </div>
</body>
</html>

================
File: backend/src/websocket/webSocketMananger.js
================
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');
const logger = require('../utils/logger');

class WebSocketManager {
  constructor(server) {
    this.wss = new WebSocket.Server({ server });
    this.clients = new Map();
    this.rooms = new Map();
    
    this.initialize();
  }

  initialize() {
    this.wss.on('connection', async (ws, req) => {
      try {
        // Autenticação
        const token = this.extractToken(req);
        if (!token) {
          ws.close(4001, 'Token não fornecido');
          return;
        }

        const user = await this.verifyToken(token);
        if (!user) {
          ws.close(4001, 'Token inválido');
          return;
        }

        // Registra o cliente
        const clientId = user.id;
        this.clients.set(clientId, { ws, user });

        // Setup de heartbeat
        ws.isAlive = true;
        ws.on('pong', () => { ws.isAlive = true; });

        // Manipuladores de eventos
        ws.on('message', async (message) => {
          try {
            const data = JSON.parse(message);
            await this.handleMessage(clientId, data);
          } catch (error) {
            logger.error('Erro ao processar mensagem:', error);
            this.sendError(ws, error.message);
          }
        });

        ws.on('close', () => {
          this.handleDisconnect(clientId);
        });

        // Notifica conexão bem-sucedida
        this.sendToClient(clientId, {
          type: 'CONNECTED',
          data: { userId: clientId }
        });

      } catch (error) {
        logger.error('Erro na conexão WebSocket:', error);
        ws.close(4000, 'Erro interno');
      }
    });

    // Heartbeat interval
    setInterval(() => {
      this.wss.clients.forEach((ws) => {
        if (!ws.isAlive) return ws.terminate();
        ws.isAlive = false;
        ws.ping();
      });
    }, 30000);
  }

  async handleMessage(clientId, message) {
    const { type, data } = message;

    switch (type) {
      case 'JOIN_ROOM':
        await this.handleJoinRoom(clientId, data.roomId);
        break;

      case 'LEAVE_ROOM':
        await this.handleLeaveRoom(clientId, data.roomId);
        break;

      case 'EQUIPMENT_UPDATE':
        await this.handleEquipmentUpdate(clientId, data);
        break;

      case 'MAINTENANCE_STATUS':
        await this.handleMaintenanceStatus(clientId, data);
        break;

      default:
        logger.warn('Tipo de mensagem desconhecido:', type);
        break;
    }
  }

  async handleJoinRoom(clientId, roomId) {
    if (!this.rooms.has(roomId)) {
      this.rooms.set(roomId, new Set());
    }
    this.rooms.get(roomId).add(clientId);
  }

  async handleLeaveRoom(clientId, roomId) {
    if (this.rooms.has(roomId)) {
      this.rooms.get(roomId).delete(clientId);
    }
  }

  async handleEquipmentUpdate(clientId, data) {
    const { equipmentId, status, changes } = data;
    
    // Notifica todos na sala do equipamento
    this.broadcastToRoom(`equipment_${equipmentId}`, {
      type: 'EQUIPMENT_UPDATED',
      data: {
        equipmentId,
        status,
        changes,
        updatedBy: clientId,
        timestamp: new Date()
      }
    });
  }

  async handleMaintenanceStatus(clientId, data) {
    const { maintenanceId, status, notes } = data;

    // Notifica interessados sobre atualização da manutenção
    this.broadcastToRoom(`maintenance_${maintenanceId}`, {
      type: 'MAINTENANCE_UPDATED',
      data: {
        maintenanceId,
        status,
        notes,
        updatedBy: clientId,
        timestamp: new Date()
      }
    });
  }

  handleDisconnect(clientId) {
    // Remove cliente de todas as salas
    this.rooms.forEach((clients, roomId) => {
      clients.delete(clientId);
    });

    // Remove cliente da lista
    this.clients.delete(clientId);
  }

  sendToClient(clientId, message) {
    const client = this.clients.get(clientId);
    if (client && client.ws.readyState === WebSocket.OPEN) {
      client.ws.send(JSON.stringify(message));
    }
  }

  broadcastToRoom(roomId, message) {
    const clients = this.rooms.get(roomId);
    if (clients) {
      clients.forEach(clientId => {
        this.sendToClient(clientId, message);
      });
    }
  }

  broadcastToAll(message) {
    this.clients.forEach((client, clientId) => {
      this.sendToClient(clientId, message);
    });
  }

  sendError(ws, message) {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'ERROR',
        data: { message }
      }));
    }
  }

  extractToken(req) {
    const auth = req.headers.authorization;
    return auth ? auth.replace('Bearer ', '') : null;
  }

  async verifyToken(token) {
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      return await User.findByPk(decoded.id);
    } catch (error) {
      return null;
    }
  }
}

module.exports = WebSocketManager;

================
File: backend/src/app.js
================
require('dotenv').config();
require('express-async-errors');
const express = require('express');
const cors = require('cors');
const routes = require('./routes');
const errorHandler = require('./middlewares/errorHandler');
const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./config/swagger');

const app = express();

app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Documentação da API
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));

// Rotas
app.use('/api', routes);

// Tratamento de erros
app.use(errorHandler);

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

module.exports = app;

================
File: backend/src/index.js
================
require('dotenv').config();
const app = require('./app'); // Importa a aplicação configurada
const logger = require('./utils/logger');
const { sequelize } = require('./models');

const startServer = async () => {
  try {
    // Conecta ao banco de dados
    await sequelize.authenticate();
    logger.info('Conexão com banco de dados estabelecida.');

    const port = process.env.PORT || 3000;
    app.listen(port, () => {
      logger.info(`Servidor rodando na porta ${port}`);
      logger.info(`Ambiente: ${process.env.NODE_ENV}`);
    });

    // Graceful shutdown
    const shutdown = async () => {
      logger.info('Iniciando shutdown graceful...');
      
      // Fecha conexões
      await sequelize.close();
      logger.info('Conexões com banco fechadas');

      process.exit(0);
    };

    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);

  } catch (error) {
    logger.error('Erro fatal ao iniciar aplicação:', error);
    process.exit(1);
  }
};

startServer();

================
File: backend/.env
================
NODE_ENV=development
PORT=3000
API_URL=http://localhost:3000/api
FRONTEND_URL=http://localhost:5173
CORS_ORIGIN=http://localhost:5173

# Banco de Dados
DB_HOST=localhost
DB_PORT=5432
DB_NAME=equipment_management
DB_USER=postgres
DB_PASS=postgres

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# JWT
JWT_SECRET=your-jwt-secret-key
JWT_EXPIRES_IN=7d

# AWS (preencha com suas credenciais)
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_REGION=
AWS_BUCKET_NAME=

# SMTP (preencha com suas credenciais)
SMTP_HOST=
SMTP_PORT=
SMTP_USER=
SMTP_PASS=
SMTP_FROM=

================
File: backend/.sequelizerc
================
const path = require('path');

module.exports = {
  config: path.resolve('src', 'config', 'database.js'),
  'models-path': path.resolve('src', 'models'),
  'seeders-path': path.resolve('src', 'database', 'seeders'),
  'migrations-path': path.resolve('src', 'database', 'migrations'),
};

================
File: backend/estrutura_projeto.txt
================
Estrutura de Arquivos do Projeto

Backend:
- app.js
- config
  - database.js
  - multer.js
  - redis.js
- controllers
  - AuthController.js
  - DashboardController.js
  - EquipmentController.js
  - MaintenanceController.js
  - NotificationController.js
  - ReportController.js
  - ServiceOrderController.js
  - UserController.js
- database
  - index.js
  - migrations
    - 01-create-users.js
    - 02-create-equipment.js
    - 03-create-maintenance.js
    - 04-create-notifications.js
    - 05-create-reports.js
- index.js
- jobs
  - jobProcessor.js
  - processors
    - index.js
- middlewares
  - auth.js
  - errorHandler.js
  - security.js
  - validate.js
- models
  - Equipment.js
  - File.js
  - MaintenanceHistory.js
  - ServiceOrder.js
  - User.js
- routes
  - index.js
- services
  - AuditService.js
  - CacheService.js
  - EmailService.js
  - FileService.js
  - MediaService.js
  - NotificationService.js
  - PDFService.js
  - PushNotificationService.js
  - QRCodeService.js
  - ReportService.js
  - S3Service.js
  - WebSocketService.js
- utils
  - logger.js
- validations
  - schemas.js
- views
  - emails
    - maintenance-complete.ejs
    - maintenance-notification.ejs
- websocket
  - webSocketMananger.js

Frontend:
- App.jsx
- components
  - .DS_Store
  - Layout
    - Layout.jsx
- contexts
  - AuthContext.js
- main.jsx
- pages
  - Dashboard
    - Dashboard.jsx
  - Equipment
    - EquipmentForm.jsx
    - EquipmentList.jsx
    - EquipmentQRCode.jsx
  - Login
    - Login.jsx
  - Maintenance
    - MaintenaceList.jsx
    - MaintenanceForm.jsx
  - Profile
    - Profile.jsx
  - ServiceOrder
    - ServiceOrderForm.jsx
    - ServiceOrderList.jsx
  - Settings
    - Settings.jsx
  - User
    - UserForm.jsx
    - UserList.jsx
- routes
  - index.jsx
- services
  - api.jsx
  - cacheService.jsx
  - dashboardService.jsx
  - i18nService.jsx
  - notificationService.jsx
  - qrcodeService.jsx
  - reportService.jsx
  - storageService.jsx
  - themeService.jsx
  - uploadService.jsx
  - validationService.jsx
- utils
  - formatters.jsx

Mobile:
- DashboardScreen.jsx
- MainScreen.jsx
- MaintenanceForm.jsx
- MaintenanceHistory.jsx

================
File: backend/package.json
================
{
  "name": "equipment-management-backend",
  "version": "1.0.0",
  "description": "Sistema de Gerenciamento de Equipamentos - Backend",
  "scripts": {
    "start": "node src/app.js",
    "dev": "nodemon src/app.js",
    "migrate": "sequelize db:migrate",
    "migrate:undo": "sequelize db:migrate:undo:all",
    "seed": "sequelize db:seed:all",
    "test": "jest"
  },
  "dependencies": {
    "@sendgrid/mail": "^7.7.0",
    "aws-sdk": "^2.1338.0",
    "bcryptjs": "^2.4.3",
    "bull": "^4.10.4",
    "cors": "^2.8.5",
    "date-fns": "^2.30.0",
    "dotenv": "^16.0.3",
    "ejs": "^3.1.9",
    "express": "^4.18.2",
    "express-async-errors": "^3.1.1",
    "express-rate-limit": "^6.7.0",
    "express-validator": "^7.0.1",
    "helmet": "^6.0.1",
    "hpp": "^0.2.3",
    "ioredis": "^5.3.1",
    "jsonwebtoken": "^9.0.0",
    "multer": "^1.4.5-lts.1",
    "node-cron": "^3.0.3",
    "nodemailer": "^6.9.7",
    "pg": "^8.10.0",
    "pg-hstore": "^2.3.4",
    "qrcode": "^1.5.1",
    "sequelize": "^6.30.0",
    "sharp": "^0.32.0",
    "socket.io": "^4.6.1",
    "winston": "^3.8.2",
    "winston-daily-rotate-file": "^4.7.1",
    "yup": "^1.0.2",
    "express-mongo-sanitize": "^2.2.0",
    "exceljs": "^4.4.0",
    "pdfkit": "^0.14.0",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "eslint": "^8.36.0",
    "jest": "^29.5.0",
    "nodemon": "^2.0.22",
    "sequelize-cli": "^6.6.0",
    "supertest": "^6.3.3"
  }
}

================
File: backend/tree.js
================
const fs = require('fs');
const path = require('path');

// Função recursiva para gerar o mapa de pastas/arquivos
function generateFileStructure(dir, depth = 0) {
    let structure = '';
    const files = fs.readdirSync(dir);

    files.forEach((file) => {
        const filePath = path.join(dir, file);
        const isDirectory = fs.statSync(filePath).isDirectory();

        structure += `${'  '.repeat(depth)}- ${file}\n`;

        if (isDirectory) {
            structure += generateFileStructure(filePath, depth + 1);
        }
    });

    return structure;
}

// Caminhos do backend e frontend
const backendDir = path.join(__dirname, '/src');
const frontendDir = path.join(__dirname, '../frontend/src');
const mobileDir = path.join(__dirname, "../mobile");

// Gerar mapas de ambos os diretórios
let output = 'Estrutura de Arquivos do Projeto\n\n';
output += 'Backend:\n';
output += generateFileStructure(backendDir);
output += '\nFrontend:\n';
output += generateFileStructure(frontendDir);
output += '\nMobile:\n';
output += generateFileStructure(mobileDir);

// Exibir no console
console.log(output);

// Opcional: salvar em um arquivo
const outputPath = path.join(__dirname, 'estrutura_projeto.txt');
fs.writeFileSync(outputPath, output);
console.log(`Estrutura salva em: ${outputPath}`);

================
File: frontend/src/components/Layout/Layout.jsx
================
import React from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';

// Importações do shadcn/ui
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
} from "@/components/ui/sheet";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import { Separator } from "@/components/ui/separator";

// Importações do Lucide Icons
import {
  Menu,
  LayoutDashboard,
  Wrench,
  ClipboardList,
  Settings,
  Users,
  LogOut,
  User,
  Bell
} from 'lucide-react';

const Layout = ({ children }) => {
  const { user, signOut } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const [isMobileMenuOpen, setIsMobileMenuOpen] = React.useState(false);

  const menuItems = [
    { text: 'Dashboard', icon: <LayoutDashboard className="w-4 h-4" />, path: '/dashboard' },
    { text: 'Equipamentos', icon: <Wrench className="w-4 h-4" />, path: '/equipamentos' },
    { text: 'Ordens de Serviço', icon: <ClipboardList className="w-4 h-4" />, path: '/ordens-servico' },
    { text: 'Usuários', icon: <Users className="w-4 h-4" />, path: '/usuarios', admin: true },
    { text: 'Configurações', icon: <Settings className="w-4 h-4" />, path: '/configuracoes' },
  ];

  const handleLogout = () => {
    signOut();
    navigate('/login');
  };

  return (
    <div className="min-h-screen bg-background">
      {/* Header */}
      <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="container flex h-14 items-center">
          <Button
            variant="ghost"
            className="mr-2 px-0 text-base hover:bg-transparent focus-visible:bg-transparent focus-visible:ring-0 focus-visible:ring-offset-0 lg:hidden"
            onClick={() => setIsMobileMenuOpen(true)}
          >
            <Menu className="h-6 w-6" />
          </Button>
          
          <div className="flex-1" />

          <div className="flex items-center gap-2">
            <Button
              variant="ghost"
              size="icon"
              className="relative"
              onClick={() => navigate('/notifications')}
            >
              <Bell className="h-4 w-4" />
              {/* Notification badge would go here */}
            </Button>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" className="relative h-8 w-8 rounded-full">
                  <Avatar className="h-8 w-8">
                    <AvatarImage src={user?.avatar} alt={user?.name} />
                    <AvatarFallback>{user?.name?.charAt(0)}</AvatarFallback>
                  </Avatar>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem onClick={() => navigate('/perfil')}>
                  <User className="mr-2 h-4 w-4" />
                  Meu Perfil
                </DropdownMenuItem>
                <DropdownMenuItem onClick={handleLogout}>
                  <LogOut className="mr-2 h-4 w-4" />
                  Sair
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </header>

      {/* Mobile Menu */}
      <Sheet open={isMobileMenuOpen} onOpenChange={setIsMobileMenuOpen}>
        <SheetContent side="left" className="w-[300px] sm:w-[400px]">
          <SheetHeader>
            <SheetTitle>Menu</SheetTitle>
          </SheetHeader>
          <nav className="flex flex-col gap-2 mt-4">
            {menuItems.map((item) => (
              (!item.admin || user?.role === 'admin') && (
                <Button
                  key={item.path}
                  variant={location.pathname === item.path ? "secondary" : "ghost"}
                  className="justify-start"
                  onClick={() => {
                    navigate(item.path);
                    setIsMobileMenuOpen(false);
                  }}
                >
                  {item.icon}
                  <span className="ml-2">{item.text}</span>
                </Button>
              )
            ))}
          </nav>
        </SheetContent>
      </Sheet>

      {/* Desktop Sidebar */}
      <div className="hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col">
        <div className="flex grow flex-col gap-y-5 overflow-y-auto border-r bg-background px-6">
          <nav className="flex flex-1 flex-col">
            <ul role="list" className="flex flex-1 flex-col gap-y-7">
              <li>
                <ul role="list" className="space-y-1">
                  {menuItems.map((item) => (
                    (!item.admin || user?.role === 'admin') && (
                      <li key={item.path}>
                        <Button
                          variant={location.pathname === item.path ? "secondary" : "ghost"}
                          className="w-full justify-start"
                          onClick={() => navigate(item.path)}
                        >
                          {item.icon}
                          <span className="ml-2">{item.text}</span>
                        </Button>
                      </li>
                    )
                  ))}
                </ul>
              </li>
            </ul>
          </nav>
        </div>
      </div>

      {/* Main Content */}
      <main className="lg:pl-72">
        <div className="px-4 sm:px-6 lg:px-8 py-6">
          {children}
        </div>
      </main>
    </div>
  );
};

export default Layout;

================
File: frontend/src/contexts/AuthContext.js
================
import React, { createContext, useState, useContext, useEffect } from 'react';
import { api } from '@/services/api';
import { useToast } from "@/components/ui/use-toast";

const AuthContext = createContext({});

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const { toast } = useToast();

  useEffect(() => {
    async function loadStorageData() {
      try {
        const storedToken = localStorage.getItem('@EquipmentManagement:token');
        const storedUser = localStorage.getItem('@EquipmentManagement:user');

        if (storedToken && storedUser) {
          api.defaults.headers.authorization = `Bearer ${storedToken}`;
          setUser(JSON.parse(storedUser));

          // Validar token
          const response = await api.post('/auth/validate-token', { token: storedToken });
          if (!response.data.valid) {
            throw new Error('Token inválido');
          }
        }
      } catch (error) {
        localStorage.removeItem('@EquipmentManagement:token');
        localStorage.removeItem('@EquipmentManagement:user');
        setUser(null);
        toast({
          variant: "destructive",
          title: "Sessão expirada",
          description: "Por favor, faça login novamente."
        });
      } finally {
        setLoading(false);
      }
    }
    loadStorageData();
  }, [toast]);

  async function signIn({ email, password }) {
    try {
      const response = await api.post('/auth/login', { email, password });
      const { token, user } = response.data;

      localStorage.setItem('@EquipmentManagement:token', token);
      localStorage.setItem('@EquipmentManagement:user', JSON.stringify(user));
      
      api.defaults.headers.authorization = `Bearer ${token}`;
      setUser(user);

      toast({
        title: "Login realizado com sucesso",
        description: `Bem-vindo(a), ${user.name}!`
      });

      return { success: true };
    } catch (error) {
      const message = error.response?.data?.error || 'Erro ao realizar login';
      toast({
        variant: "destructive",
        title: "Erro no login",
        description: message
      });
      return { success: false, error: message };
    }
  }

  function signOut() {
    localStorage.removeItem('@EquipmentManagement:token');
    localStorage.removeItem('@EquipmentManagement:user');
    setUser(null);
    delete api.defaults.headers.authorization;
  }

  async function updateUser(userData) {
    try {
      const response = await api.put('/users/profile', userData);
      const updatedUser = response.data;
      
      localStorage.setItem('@EquipmentManagement:user', JSON.stringify(updatedUser));
      setUser(updatedUser);

      toast({
        title: "Perfil atualizado",
        description: "Suas informações foram atualizadas com sucesso!"
      });

      return { success: true };
    } catch (error) {
      const message = error.response?.data?.error || 'Erro ao atualizar usuário';
      toast({
        variant: "destructive",
        title: "Erro ao atualizar perfil",
        description: message
      });
      return { success: false, error: message };
    }
  }

  async function updatePassword({ currentPassword, newPassword }) {
    try {
      await api.put('/users/password', { currentPassword, newPassword });

      toast({
        title: "Senha atualizada",
        description: "Sua senha foi alterada com sucesso!"
      });

      return { success: true };
    } catch (error) {
      const message = error.response?.data?.error || 'Erro ao atualizar senha';
      toast({
        variant: "destructive",
        title: "Erro ao atualizar senha",
        description: message
      });
      return { success: false, error: message };
    }
  }

  return (
    <AuthContext.Provider value={{
      signed: !!user,
      user,
      loading,
      signIn,
      signOut,
      updateUser,
      updatePassword
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

================
File: frontend/src/pages/Dashboard/Dashboard.jsx
================
import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { api } from '@/services/api';

import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
  BarChart,
  Bar,
  Legend
} from 'recharts';

import {
  Wrench,
  AlertCircle,
  CheckCircle,
  TrendingUp,
  MoreVertical,
  Calendar
} from 'lucide-react';

const STATUS_COLORS = {
  pending: "text-yellow-500",
  inProgress: "text-blue-500",
  completed: "text-green-500"
};

const CHART_COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042'];

function Dashboard() {
  const [loading, setLoading] = useState(true);
  const [timeRange, setTimeRange] = useState('month');
  const [stats, setStats] = useState({
    summary: {
      total: 0,
      active: 0,
      maintenance: 0,
      pendingOrders: 0
    },
    maintenancesByType: [],
    maintenanceTrend: [],
    equipmentStats: [],
    performanceMetrics: {
      avgResolutionTime: 0,
      completionRate: 0,
      avgMaintenanceCost: 0
    }
  });

  useEffect(() => {
    fetchDashboardData();
  }, [timeRange]);

  const fetchDashboardData = async () => {
    try {
      const response = await api.get(`/dashboard/stats?period=${timeRange}`);
      setStats(response.data);
    } catch (error) {
      console.error('Erro ao carregar estatísticas:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div className="flex justify-center items-center h-[calc(100vh-4rem)]">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold tracking-tight">Dashboard</h1>
        <Select value={timeRange} onValueChange={setTimeRange}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Selecione o período" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="week">Última Semana</SelectItem>
            <SelectItem value="month">Último Mês</SelectItem>
            <SelectItem value="year">Último Ano</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Summary Cards */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
        <Card>
          <CardContent className="p-6">
            <div className="flex items-center space-x-4">
              <Wrench className="h-8 w-8 text-primary" />
              <div>
                <p className="text-sm font-medium text-muted-foreground">Total de Equipamentos</p>
                <h3 className="text-2xl font-bold">{stats.summary.total}</h3>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center space-x-4">
              <CheckCircle className="h-8 w-8 text-green-500" />
              <div>
                <p className="text-sm font-medium text-muted-foreground">Equipamentos Ativos</p>
                <h3 className="text-2xl font-bold">{stats.summary.active}</h3>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center space-x-4">
              <AlertCircle className="h-8 w-8 text-yellow-500" />
              <div>
                <p className="text-sm font-medium text-muted-foreground">Em Manutenção</p>
                <h3 className="text-2xl font-bold">{stats.summary.maintenance}</h3>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardContent className="p-6">
            <div className="flex items-center space-x-4">
              <TrendingUp className="h-8 w-8 text-blue-500" />
              <div>
                <p className="text-sm font-medium text-muted-foreground">OS Pendentes</p>
                <h3 className="text-2xl font-bold">{stats.summary.pendingOrders}</h3>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Charts */}
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-7">
        <Card className="col-span-4">
          <CardHeader>
            <CardTitle>Tendência de Manutenções</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-[300px]">
              <ResponsiveContainer width="100%" height="100%">
                <LineChart data={stats.maintenanceTrend}>
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis dataKey="date" />
                  <YAxis />
                  <Tooltip />
                  <Legend />
                  <Line
                    type="monotone"
                    dataKey="preventive"
                    name="Preventivas"
                    stroke="#0088FE"
                  />
                  <Line
                    type="monotone"
                    dataKey="corrective"
                    name="Corretivas"
                    stroke="#00C49F"
                  />
                  <Line
                    type="monotone"
                    dataKey="predictive"
                    name="Preditivas"
                    stroke="#FFBB28"
                  />
                </LineChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
        </Card>

        <Card className="col-span-3">
          <CardHeader>
            <CardTitle>Distribuição por Tipo</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="h-[300px]">
              <ResponsiveContainer width="100%" height="100%">
                <PieChart>
                  <Pie
                    data={stats.maintenancesByType}
                    dataKey="value"
                    nameKey="name"
                    cx="50%"
                    cy="50%"
                    outerRadius={80}
                    label
                  >
                    {stats.maintenancesByType.map((entry, index) => (
                      <Cell key={`cell-${index}`} fill={CHART_COLORS[index % CHART_COLORS.length]} />
                    ))}
                  </Pie>
                  <Tooltip />
                  <Legend />
                </PieChart>
              </ResponsiveContainer>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Performance Metrics */}
      <div className="grid gap-4 md:grid-cols-2">
        <Card>
          <CardHeader>
            <CardTitle>Métricas de Performance</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              <div className="flex justify-between items-center">
                <p className="text-sm font-medium">Tempo Médio de Resolução</p>
                <span className="text-2xl font-bold">
                  {stats.performanceMetrics.avgResolutionTime} horas
                </span>
              </div>
              <div className="flex justify-between items-center">
                <p className="text-sm font-medium">Taxa de Conclusão</p>
                <span className="text-2xl font-bold">
                  {stats.performanceMetrics.completionRate}%
                </span>
              </div>
              <div className="flex justify-between items-center">
                <p className="text-sm font-medium">Custo Médio por Manutenção</p>
                <span className="text-2xl font-bold">
                  R$ {stats.performanceMetrics.avgMaintenanceCost}
                </span>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>Próximas Manutenções</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {stats.upcomingMaintenances?.map((maintenance) => (
                <div
                  key={maintenance.id}
                  className="flex items-center justify-between p-4 rounded-lg bg-muted"
                >
                  <div className="flex items-center space-x-4">
                    <Calendar className="h-5 w-5 text-muted-foreground" />
                    <div>
                      <p className="font-medium">{maintenance.equipment.name}</p>
                      <p className="text-sm text-muted-foreground">
                        {new Date(maintenance.scheduledDate).toLocaleDateString()}
                      </p>
                    </div>
                  </div>
                  <span className={`text-sm font-medium ${STATUS_COLORS[maintenance.status]}`}>
                    {maintenance.type}
                  </span>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}

export default Dashboard;

================
File: frontend/src/pages/Equipment/EquipmentForm.jsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  CircularProgress,
  Switch,
  FormControlLabel,
  Divider
} from '@mui/material';
import { LoadingButton } from '@mui/lab';
import { Save, ArrowBack, Upload } from '@mui/icons-material';
import { useDropzone } from 'react-dropzone';
import api from '../../services/api';

const EquipmentForm = () => {
  const navigate = useNavigate();
  const { id } = useParams();
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState('');
  const [formData, setFormData] = useState({
    name: '',
    code: '',
    serial_number: '',
    department: '',
    description: '',
    maintenance_frequency: 30,
    status: 'active'
  });
  const [images, setImages] = useState([]);
  const [manualFile, setManualFile] = useState(null);

  useEffect(() => {
    if (id) {
      loadEquipment();
    }
  }, [id]);

  const loadEquipment = async () => {
    setLoading(true);
    try {
      const response = await api.get(`/equipment/${id}`);
      setFormData(response.data);
      if (response.data.images) {
        setImages(response.data.images);
      }
      if (response.data.manual_url) {
        setManualFile({ preview: response.data.manual_url });
      }
    } catch (error) {
      setError('Erro ao carregar equipamento');
    } finally {
      setLoading(false);
    }
  };

  const { getRootProps, getInputProps } = useDropzone({
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png']
    },
    onDrop: (acceptedFiles) => {
      setImages([
        ...images,
        ...acceptedFiles.map(file => Object.assign(file, {
          preview: URL.createObjectURL(file)
        }))
      ]);
    }
  });

  const handleManualUpload = (event) => {
    const file = event.target.files[0];
    if (file) {
      setManualFile(Object.assign(file, {
        preview: URL.createObjectURL(file)
      }));
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setSaving(true);
    setError('');

    try {
      const formPayload = new FormData();

      // Adiciona os dados do formulário
      Object.keys(formData).forEach(key => {
        formPayload.append(key, formData[key]);
      });

      // Adiciona as imagens
      images.forEach((image, index) => {
        if (!image.url) { // Apenas envia se for uma nova imagem
          formPayload.append(`images`, image);
        }
      });

      // Adiciona o manual se houver
      if (manualFile && !manualFile.url) {
        formPayload.append('manual', manualFile);
      }

      if (id) {
        await api.put(`/equipment/${id}`, formPayload);
      } else {
        await api.post('/equipment', formPayload);
      }

      navigate('/equipamentos');
    } catch (error) {
      setError(error.response?.data?.message || 'Erro ao salvar equipamento');
    } finally {
      setSaving(false);
    }
  };

  const handleRemoveImage = (index) => {
    const newImages = [...images];
    newImages.splice(index, 1);
    setImages(newImages);
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Box sx={{ mb: 4, display: 'flex', justifyContent: 'space-between' }}>
        <Typography variant="h4" component="h1">
          {id ? 'Editar Equipamento' : 'Novo Equipamento'}
        </Typography>
        <Button
          variant="outlined"
          startIcon={<ArrowBack />}
          onClick={() => navigate('/equipamentos')}
        >
          Voltar
        </Button>
      </Box>

      <Paper sx={{ p: 3 }}>
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <Grid container spacing={3}>
            <Grid item xs={12} sm={6}>
              <TextField
                required
                fullWidth
                label="Nome do Equipamento"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                required
                fullWidth
                label="Código"
                value={formData.code}
                onChange={(e) => setFormData({ ...formData, code: e.target.value })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                label="Número de Série"
                value={formData.serial_number}
                onChange={(e) => setFormData({ ...formData, serial_number: e.target.value })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required>
                <InputLabel>Departamento</InputLabel>
                <Select
                  value={formData.department}
                  onChange={(e) => setFormData({ ...formData, department: e.target.value })}
                  label="Departamento"
                >
                  <MenuItem value="TI">TI</MenuItem>
                  <MenuItem value="Produção">Produção</MenuItem>
                  <MenuItem value="Manutenção">Manutenção</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12}>
              <TextField
                fullWidth
                multiline
                rows={4}
                label="Descrição"
                value={formData.description}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                type="number"
                label="Frequência de Manutenção (dias)"
                value={formData.maintenance_frequency}
                onChange={(e) => setFormData({ 
                  ...formData, 
                  maintenance_frequency: parseInt(e.target.value) 
                })}
                InputProps={{ inputProps: { min: 1 } }}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>Status</InputLabel>
                <Select
                  value={formData.status}
                  onChange={(e) => setFormData({ ...formData, status: e.target.value })}
                  label="Status"
                >
                  <MenuItem value="active">Ativo</MenuItem>
                  <MenuItem value="maintenance">Em Manutenção</MenuItem>
                  <MenuItem value="inactive">Inativo</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" sx={{ mb: 2 }}>
                Imagens do Equipamento
              </Typography>

              <Box
                {...getRootProps()}
                sx={{
                  border: '2px dashed #ccc',
                  borderRadius: 2,
                  p: 3,
                  textAlign: 'center',
                  cursor: 'pointer',
                  mb: 2
                }}
              >
                <input {...getInputProps()} />
                <Upload sx={{ fontSize: 40, color: 'text.secondary', mb: 1 }} />
                <Typography>
                  Arraste imagens aqui ou clique para selecionar
                </Typography>
              </Box>

              <Grid container spacing={2}>
                {images.map((image, index) => (
                  <Grid item key={index} xs={6} sm={4} md={3}>
                    <Box
                      sx={{
                        position: 'relative',
                        paddingTop: '100%',
                        border: '1px solid #eee',
                        borderRadius: 1,
                        overflow: 'hidden'
                      }}
                    >
                      <img
                        src={image.preview || image.url}
                        alt={`Preview ${index + 1}`}
                        style={{
                          position: 'absolute',
                          top: 0,
                          width: '100%',
                          height: '100%',
                          objectFit: 'cover'
                        }}
                      />
                      <Button
                        variant="contained"
                        color="error"
                        size="small"
                        onClick={() => handleRemoveImage(index)}
                        sx={{
                          position: 'absolute',
                          top: 8,
                          right: 8,
                          minWidth: 'auto',
                          width: 32,
                          height: 32,
                          p: 0
                        }}
                      >
                        ×
                      </Button>
                    </Box>
                  </Grid>
                ))}
              </Grid>
            </Grid>

            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" sx={{ mb: 2 }}>
                Manual do Equipamento
              </Typography>

              <input
                type="file"
                accept=".pdf"
                id="manual-upload"
                style={{ display: 'none' }}
                onChange={handleManualUpload}
              />
              <label htmlFor="manual-upload">
                <Button
                  variant="outlined"
                  component="span"
                  startIcon={<Upload />}
                >
                  Upload do Manual (PDF)
                </Button>
              </label>

              {manualFile && (
                <Box sx={{ mt: 2 }}>
                  <Typography variant="body2">
                    Arquivo: {manualFile.name || 'Manual atual'}
                  </Typography>
                  <Button
                    color="error"
                    size="small"
                    onClick={() => setManualFile(null)}
                  >
                    Remover
                  </Button>
                </Box>
              )}
            </Grid>
          </Grid>

          <Box sx={{ mt: 4, display: 'flex', justifyContent: 'flex-end', gap: 2 }}>
            <Button
              variant="outlined"
              onClick={() => navigate('/equipamentos')}
            >
              Cancelar
            </Button>
            <LoadingButton
              type="submit"
              variant="contained"
              loading={saving}
              startIcon={<Save />}
            >
              Salvar
            </LoadingButton>
          </Box>
        </form>
      </Paper>
    </Box>
  );
};

export default EquipmentForm;

================
File: frontend/src/pages/Equipment/EquipmentList.jsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { api } from '@/services/api';

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Card, CardContent } from "@/components/ui/card";
import { useToast } from "@/components/ui/use-toast";

import {
  PlusCircle,
  Search,
  Filter,
  MoreVertical,
  Edit,
  QrCode,
  Trash2,
  Download,
  Loader2
} from 'lucide-react';

const STATUS_COLORS = {
  active: "success",
  maintenance: "warning",
  inactive: "destructive"
};

const STATUS_LABELS = {
  active: "Ativo",
  maintenance: "Em Manutenção",
  inactive: "Inativo"
};

export default function EquipmentList() {
  const navigate = useNavigate();
  const { toast } = useToast();
  const [loading, setLoading] = useState(true);
  const [equipments, setEquipments] = useState([]);
  const [filters, setFilters] = useState({
    search: '',
    department: '',
    status: ''
  });
  const [filterDialogOpen, setFilterDialogOpen] = useState(false);

  useEffect(() => {
    fetchEquipments();
  }, [filters]);

  const fetchEquipments = async () => {
    try {
      setLoading(true);
      const response = await api.get('/equipment', { params: filters });
      setEquipments(response.data);
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Erro ao carregar equipamentos"
      });
    } finally {
      setLoading(false);
    }
  };

  const handleDelete = async (id) => {
    try {
      await api.delete(`/equipment/${id}`);
      toast({
        title: "Sucesso",
        description: "Equipamento excluído com sucesso"
      });
      fetchEquipments();
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Erro ao excluir equipamento"
      });
    }
  };

  const handleExportQRCode = async (id) => {
    try {
      const response = await api.get(`/equipment/${id}/qrcode`, {
        responseType: 'blob'
      });
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `qrcode-${id}.pdf`);
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Erro ao exportar QR Code"
      });
    }
  };

  const EquipmentActions = ({ equipment }) => (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon">
          <MoreVertical className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => navigate(`/equipamentos/${equipment.id}/editar`)}>
          <Edit className="mr-2 h-4 w-4" />
          Editar
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleExportQRCode(equipment.id)}>
          <QrCode className="mr-2 h-4 w-4" />
          QR Code
        </DropdownMenuItem>
        <DropdownMenuItem
          className="text-red-600"
          onClick={() => handleDelete(equipment.id)}
        >
          <Trash2 className="mr-2 h-4 w-4" />
          Excluir
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );

  return (
    <div className="container mx-auto py-6 space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Equipamentos</h1>
          <p className="text-muted-foreground">
            Gerencie os equipamentos cadastrados no sistema
          </p>
        </div>
        <Button onClick={() => navigate('/equipamentos/novo')}>
          <PlusCircle className="mr-2 h-4 w-4" />
          Novo Equipamento
        </Button>
      </div>

      <Card>
        <CardContent className="p-6">
          <div className="flex gap-4 mb-6">
            <div className="flex-1">
              <Input
                placeholder="Buscar equipamentos..."
                value={filters.search}
                onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
                leftIcon={<Search className="h-4 w-4 text-muted-foreground" />}
              />
            </div>
            <Dialog open={filterDialogOpen} onOpenChange={setFilterDialogOpen}>
              <DialogTrigger asChild>
                <Button variant="outline">
                  <Filter className="mr-2 h-4 w-4" />
                  Filtros
                </Button>
              </DialogTrigger>
              <DialogContent>
                <DialogHeader>
                  <DialogTitle>Filtros</DialogTitle>
                  <DialogDescription>
                    Aplique filtros para refinar sua busca
                  </DialogDescription>
                </DialogHeader>
                <div className="space-y-4 py-4">
                  <div className="space-y-2">
                    <label className="text-sm font-medium">Departamento</label>
                    <Select
                      value={filters.department}
                      onValueChange={(value) => setFilters(prev => ({ ...prev, department: value }))}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Todos os departamentos" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="">Todos</SelectItem>
                        <SelectItem value="TI">TI</SelectItem>
                        <SelectItem value="Produção">Produção</SelectItem>
                        <SelectItem value="Manutenção">Manutenção</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                  <div className="space-y-2">
                    <label className="text-sm font-medium">Status</label>
                    <Select
                      value={filters.status}
                      onValueChange={(value) => setFilters(prev => ({ ...prev, status: value }))}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Todos os status" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="">Todos</SelectItem>
                        <SelectItem value="active">Ativo</SelectItem>
                        <SelectItem value="maintenance">Em Manutenção</SelectItem>
                        <SelectItem value="inactive">Inativo</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                </div>
                <div className="flex justify-between">
                  <Button
                    variant="outline"
                    onClick={() => {
                      setFilters({ search: '', department: '', status: '' });
                      setFilterDialogOpen(false);
                    }}
                  >
                    Limpar Filtros
                  </Button>
                  <Button onClick={() => setFilterDialogOpen(false)}>
                    Aplicar Filtros
                  </Button>
                </div>
              </DialogContent>
            </Dialog>
            <Button variant="outline" onClick={() => window.open('/api/equipment/export', '_blank')}>
              <Download className="mr-2 h-4 w-4" />
              Exportar
            </Button>
          </div>

          {loading ? (
            <div className="flex justify-center items-center h-48">
              <Loader2 className="h-8 w-8 animate-spin" />
            </div>
          ) : (
            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Nome</TableHead>
                    <TableHead>Código</TableHead>
                    <TableHead>Departamento</TableHead>
                    <TableHead>Status</TableHead>
                    <TableHead>Última Manutenção</TableHead>
                    <TableHead className="text-right">Ações</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {equipments.map((equipment) => (
                    <TableRow key={equipment.id}>
                      <TableCell className="font-medium">{equipment.name}</TableCell>
                      <TableCell>{equipment.code}</TableCell>
                      <TableCell>{equipment.department}</TableCell>
                      <TableCell>
                        <Badge variant={STATUS_COLORS[equipment.status]}>
                          {STATUS_LABELS[equipment.status]}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        {equipment.last_maintenance
                          ? new Date(equipment.last_maintenance).toLocaleDateString()
                          : 'Nunca realizada'}
                      </TableCell>
                      <TableCell className="text-right">
                        <EquipmentActions equipment={equipment} />
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}

================
File: frontend/src/pages/Equipment/EquipmentQRCode.jsx
================
import React from 'react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Download, Printer } from 'lucide-react';

const EquipmentQRCode = ({ equipment }) => {
  const handlePrint = () => {
    const printWindow = window.open('', '_blank');
    printWindow.document.write(`
      <html>
        <head>
          <title>QR Code - ${equipment.name}</title>
          <style>
            body { font-family: Arial, sans-serif; text-align: center; padding: 20px; }
            img { max-width: 300px; }
            .info { margin-top: 20px; }
          </style>
        </head>
        <body>
          <h2>${equipment.name}</h2>
          <img src="${equipment.qrcode_url}" alt="QR Code" />
          <div class="info">
            <p>Código: ${equipment.code}</p>
            <p>Departamento: ${equipment.department}</p>
          </div>
        </body>
      </html>
    `);
    printWindow.document.close();
    printWindow.focus();
    printWindow.print();
  };

  const handleDownload = () => {
    const link = document.createElement('a');
    link.href = equipment.qrcode_url;
    link.download = `qrcode-${equipment.code}.png`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader className="bg-primary text-white p-4">
        <h2 className="text-xl font-bold">QR Code do Equipamento</h2>
      </CardHeader>

      <CardContent className="p-6 text-center">
        <div className="mb-4">
          <img
            src={equipment.qrcode_url}
            alt="QR Code"
            className="mx-auto max-w-[200px]"
          />
        </div>

        <div className="mb-4 text-sm">
          <p className="font-medium">{equipment.name}</p>
          <p className="text-gray-600">Código: {equipment.code}</p>
        </div>

        <div className="flex justify-center gap-4">
          <button
            onClick={handleDownload}
            className="flex items-center px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            <Download className="w-4 h-4 mr-2" />
            Download
          </button>
          <button
            onClick={handlePrint}
            className="flex items-center px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
          >
            <Printer className="w-4 h-4 mr-2" />
            Imprimir
          </button>
        </div>

        <p className="mt-4 text-sm text-gray-500">
          Escaneie este QR Code para acessar a página de manutenção do equipamento
        </p>
      </CardContent>
    </Card>
  );
};

export default EquipmentQRCode;

================
File: frontend/src/pages/Login/Login.jsx
================
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';

import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Wrench, Loader2 } from 'lucide-react';

const formSchema = z.object({
  email: z.string()
    .min(1, 'E-mail é obrigatório')
    .email('E-mail inválido'),
  password: z.string()
    .min(1, 'Senha é obrigatória')
});

function Login() {
  const navigate = useNavigate();
  const { signIn } = useAuth();
  
  const form = useForm({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: '',
      password: ''
    }
  });

  const onSubmit = async (values) => {
    try {
      const response = await signIn(values);
      if (response.success) {
        navigate('/dashboard');
      }
    } catch (error) {
      console.error('Erro no login:', error);
    }
  };

  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <Card className="w-full max-w-md mx-4">
        <CardHeader className="space-y-1">
          <div className="flex justify-center mb-4">
            <Wrench className="h-12 w-12 text-primary" />
          </div>
          <CardTitle className="text-2xl text-center">
            Sistema de Gestão de Equipamentos
          </CardTitle>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              <FormField
                control={form.control}
                name="email"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>E-mail</FormLabel>
                    <FormControl>
                      <Input
                        type="email"
                        placeholder="seu@email.com"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />
              
              <FormField
                control={form.control}
                name="password"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Senha</FormLabel>
                    <FormControl>
                      <Input
                        type="password"
                        placeholder="••••••••"
                        {...field}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <Button
                type="submit"
                className="w-full"
                disabled={form.formState.isSubmitting}
              >
                {form.formState.isSubmitting ? (
                  <>
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    Entrando...
                  </>
                ) : (
                  'Entrar'
                )}
              </Button>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
}

export default Login;

================
File: frontend/src/pages/Maintenance/MaintenanceForm.jsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { api } from '@/services/api';

import { Button } from "@/components/ui/button";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { useToast } from "@/components/ui/use-toast";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";

import {
  ArrowLeft,
  Save,
  Camera,
  X,
  Plus,
  Loader2,
  Image as ImageIcon,
  FileText,
  Trash2
} from 'lucide-react';

const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
const ACCEPTED_IMAGE_TYPES = ["image/jpeg", "image/jpg", "image/png", "image/webp"];

const formSchema = z.object({
  equipment_id: z.string().min(1, 'Equipamento é obrigatório'),
  description: z.string().min(10, 'Descrição deve ter no mínimo 10 caracteres'),
  type: z.enum(['corrective', 'preventive', 'predictive']),
  priority: z.enum(['low', 'medium', 'high', 'critical']),
  scheduled_for: z.string().min(1, 'Data agendada é obrigatória'),
  notes: z.string().optional(),
  parts_replaced: z.array(z.object({
    name: z.string().min(1, 'Nome da peça é obrigatório'),
    quantity: z.number().min(1, 'Quantidade deve ser maior que 0'),
    cost: z.number().min(0, 'Custo não pode ser negativo')
  })).optional()
});

export default function MaintenanceForm() {
  const navigate = useNavigate();
  const { id } = useParams();
  const { toast } = useToast();
  const [loading, setLoading] = useState(false);
  const [equipments, setEquipments] = useState([]);
  const [photos, setPhotos] = useState([]);
  const [files, setFiles] = useState([]);

  const form = useForm({
    resolver: zodResolver(formSchema),
    defaultValues: {
      equipment_id: '',
      description: '',
      type: 'corrective',
      priority: 'medium',
      scheduled_for: new Date().toISOString().split('T')[0],
      notes: '',
      parts_replaced: []
    }
  });

  useEffect(() => {
    fetchEquipments();
    if (id) {
      loadMaintenance();
    }
  }, [id]);

  const fetchEquipments = async () => {
    try {
      const response = await api.get('/equipment');
      setEquipments(response.data);
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Erro ao carregar equipamentos"
      });
    }
  };

  const loadMaintenance = async () => {
    try {
      setLoading(true);
      const response = await api.get(`/maintenance/${id}`);
      form.reset({
        ...response.data,
        scheduled_for: new Date(response.data.scheduled_for).toISOString().split('T')[0]
      });
      
      if (response.data.photos) {
        setPhotos(response.data.photos.map(photo => ({
          preview: photo.url,
          id: photo.id
        })));
      }
      
      if (response.data.files) {
        setFiles(response.data.files);
      }
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Erro ao carregar manutenção"
      });
    } finally {
      setLoading(false);
    }
  };

  const handlePhotoUpload = (event) => {
    const files = Array.from(event.target.files);
    
    const validFiles = files.filter(file => {
      if (file.size > MAX_FILE_SIZE) {
        toast({
          variant: "destructive",
          title: "Erro",
          description: `Arquivo ${file.name} muito grande. Máximo: 5MB`
        });
        return false;
      }
      
      if (!ACCEPTED_IMAGE_TYPES.includes(file.type)) {
        toast({
          variant: "destructive",
          title: "Erro",
          description: `Tipo de arquivo não aceito: ${file.name}`
        });
        return false;
      }
      
      return true;
    });

    const newPhotos = validFiles.map(file => ({
      file,
      preview: URL.createObjectURL(file)
    }));

    setPhotos(prev => [...prev, ...newPhotos]);
  };

  const handleFileUpload = async (event) => {
    const newFiles = Array.from(event.target.files);
    
    const validFiles = newFiles.filter(file => {
      if (file.size > MAX_FILE_SIZE) {
        toast({
          variant: "destructive",
          title: "Erro",
          description: `Arquivo ${file.name} muito grande. Máximo: 5MB`
        });
        return false;
      }
      return true;
    });

    setFiles(prev => [...prev, ...validFiles]);
  };

  const handleAddPart = () => {
    const currentParts = form.getValues('parts_replaced') || [];
    form.setValue('parts_replaced', [
      ...currentParts,
      { name: '', quantity: 1, cost: 0 }
    ]);
  };

  const handleRemovePart = (index) => {
    const currentParts = form.getValues('parts_replaced');
    const newParts = currentParts.filter((_, i) => i !== index);
    form.setValue('parts_replaced', newParts);
  };

  const onSubmit = async (data) => {
    try {
      setLoading(true);
      const formData = new FormData();

      // Dados básicos
      Object.keys(data).forEach(key => {
        if (key === 'parts_replaced') {
          formData.append(key, JSON.stringify(data[key]));
        } else {
          formData.append(key, data[key]);
        }
      });

      // Fotos
      photos.forEach((photo) => {
        if (photo.file) {
          formData.append('photos', photo.file);
        }
      });

      // Arquivos
      files.forEach((file) => {
        if (!file.id) {
          formData.append('files', file);
        }
      });

      if (id) {
        await api.put(`/maintenance/${id}`, formData);
        toast({
          title: "Sucesso",
          description: "Manutenção atualizada com sucesso"
        });
      } else {
        await api.post('/maintenance', formData);
        toast({
          title: "Sucesso",
          description: "Manutenção criada com sucesso"
        });
      }

      navigate('/manutencoes');
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: error.response?.data?.error || "Erro ao salvar manutenção"
      });
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="container mx-auto py-6 space-y-6">
      <div className="flex justify-between items-center">
        <div className="space-y-1">
          <h1 className="text-3xl font-bold tracking-tight">
            {id ? 'Editar Manutenção' : 'Nova Manutenção'}
          </h1>
          <p className="text-muted-foreground">
            {id ? 'Atualize os dados da manutenção' : 'Registre uma nova manutenção no sistema'}
          </p>
        </div>
        <Button
          variant="outline"
          onClick={() => navigate('/manutencoes')}
        >
          <ArrowLeft className="mr-2 h-4 w-4" />
          Voltar
        </Button>
      </div>

      <Card>
        <CardContent className="p-6">
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
              <FormField
                control={form.control}
                name="equipment_id"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Equipamento</FormLabel>
                    <Select
                      onValueChange={field.onChange}
                      defaultValue={field.value}
                    >
                      <FormControl>
                        <SelectTrigger>
                          <SelectValue placeholder="Selecione um equipamento" />
                        </SelectTrigger>
                      </FormControl>
                      <SelectContent>
                        {equipments.map(equipment => (
                          <SelectItem
                            key={equipment.id}
                            value={equipment.id.toString()}
                          >
                            {equipment.name} - {equipment.code}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                    <FormMessage />
                  </FormItem>
                )}
              />

              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <FormField
                  control={form.control}
                  name="type"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Tipo</FormLabel>
                      <Select
                        onValueChange={field.onChange}
                        defaultValue={field.value}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Selecione o tipo" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          <SelectItem value="corrective">Corretiva</SelectItem>
                          <SelectItem value="preventive">Preventiva</SelectItem>
                          <SelectItem value="predictive">Preditiva</SelectItem>
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="priority"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Prioridade</FormLabel>
                      <Select
                        onValueChange={field.onChange}
                        defaultValue={field.value}
                      >
                        <FormControl>
                          <SelectTrigger>
                            <SelectValue placeholder="Selecione a prioridade" />
                          </SelectTrigger>
                        </FormControl>
                        <SelectContent>
                          <SelectItem value="low">Baixa</SelectItem>
                          <SelectItem value="medium">Média</SelectItem>
                          <SelectItem value="high">Alta</SelectItem>
                          <SelectItem value="critical">Crítica</SelectItem>
                        </SelectContent>
                      </Select>
                      <FormMessage />
                    </FormItem>
                  )}
                />

                <FormField
                  control={form.control}
                  name="scheduled_for"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Data Agendada</FormLabel>
                      <FormControl>
                        <Input type="date" {...field} />
                      </FormControl>
                      <FormMessage />
                    </FormItem>
                  )}
                />
              </div>

              <FormField
                control={form.control}
                name="description"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Descrição</FormLabel>
                    <FormControl>
                      <Textarea
                        {...field}
                        rows={4}
                        placeholder="Descreva o problema ou serviço a ser realizado"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Peças Substituídas */}
              <div className="space-y-4">
                <div className="flex justify-between items-center">
                  <FormLabel>Peças Substituídas</FormLabel>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={handleAddPart}
                  >
                    <Plus className="mr-2 h-4 w-4" />
                    Adicionar Peça
                  </Button>
                </div>

                <div className="rounded-md border">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead>Nome da Peça</TableHead>
                        <TableHead>Quantidade</TableHead>
                        <TableHead>Custo Unitário</TableHead>
                        <TableHead className="w-[70px]"></TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {form.watch('parts_replaced')?.map((_, index) => (
                        <TableRow key={index}>
                          <TableCell>
                            <FormField
                              control={form.control}
                              name={`parts_replaced.${index}.name`}
                              render={({ field }) => (
                                <FormItem>
                                  <FormControl>
                                    <Input {...field} placeholder="Nome da peça" />
                                  </FormControl>
                                </FormItem>
                              )}
                            />
                          </TableCell>
                          <TableCell>
                            <FormField
                              control={form.control}
                              name={`parts_replaced.${index}.quantity`}
                              render={({ field }) => (
                                <FormItem>
                                  <FormControl>
                                    <Input
                                      type="number"
                                      min="1"
                                      {...field}
                                      onChange={(e) => field.onChange(parseInt(e.target.value))}
                                    />
                                  </FormControl>
                                </FormItem>
                              )}
                            />
                          </TableCell>
                          <TableCell>
                            <FormField
                              control={form.control}
                              name={`parts_replaced.${index}.cost`}
                              render={({ field }) => (
                                <FormItem>
                                  <FormControl>
                                    <Input
                                      type="number"
                                      min="0"
                                      step="0.01"
                                      {...field}
                                      onChange={(e) => field.onChange(parseFloat(e.target.value))}
                                    />
                                  </FormControl>
                                </FormItem>
                              )}
                            />
                          </TableCell>
                          <TableCell>
                            <Button
                              type="button"
                              variant="ghost"
                              size="icon"
                              onClick={() => handleRemovePart(index)}
                            >
                              <Trash2 className="h-4 w-4" />
                            </Button>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              </div>

              {/* Fotos */}
              <div className="space-y-4">
                <FormLabel>Fotos</FormLabel>
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                  {photos.map((photo, index) => (
                    <div key={index} className="relative">
                      <img
                        src={photo.preview}
                        alt={`Foto ${index + 1}`}
                        className="w-full h-32 object-cover rounded-lg"
                      />
                      <Button
                        type="button"
                        variant="destructive"
                        size="icon"
                        className="absolute -top-2 -right-2"
                        onClick={() => {
                          const newPhotos = [...photos];
                          newPhotos.splice(index, 1);
                          setPhotos(newPhotos);
                        }}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  ))}
                  <label className="flex flex-col items-center justify-center h-32 border-2 border-dashed rounded-lg cursor-pointer hover:border-primary">
                    <input
                      type="file"
                      accept="image/*"
                      multiple
                      className="hidden"
                      onChange={handlePhotoUpload}
                    />
                    <Camera className="h-8 w-8 text-muted-foreground" />
                    <span className="mt-2 text-sm text-muted-foreground">
                      Adicionar fotos
                    </span>
                  </label>
                </div>
              </div>

              {/* Arquivos */}
              <div className="space-y-4">
                <FormLabel>Arquivos Anexos</FormLabel>
                <div className="space-y-2">
                  {files.map((file, index) => (
                    <div
                      key={index}
                      className="flex items-center justify-between p-3 bg-muted rounded-lg"
                    >
                      <div className="flex items-center space-x-3">
                        <FileText className="h-5 w-5 text-muted-foreground" />
                        <span className="text-sm font-medium">{file.name}</span>
                      </div>
                      <Button
                        type="button"
                        variant="ghost"
                        size="icon"
                        onClick={() => {
                          const newFiles = [...files];
                          newFiles.splice(index, 1);
                          setFiles(newFiles);
                        }}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  ))}
                  <label className="flex items-center justify-center p-8 border-2 border-dashed rounded-lg cursor-pointer hover:border-primary">
                    <input
                      type="file"
                      multiple
                      className="hidden"
                      onChange={handleFileUpload}
                    />
                    <div className="flex flex-col items-center">
                      <ImageIcon className="h-8 w-8 text-muted-foreground" />
                      <span className="mt-2 text-sm text-muted-foreground">
                        Arraste arquivos ou clique para selecionar
                      </span>
                      <span className="mt-1 text-xs text-muted-foreground">
                        PDF, Word ou imagens até 5MB
                      </span>
                    </div>
                  </label>
                </div>
              </div>

              {/* Observações */}
              <FormField
                control={form.control}
                name="notes"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>Observações Adicionais</FormLabel>
                    <FormControl>
                      <Textarea
                        {...field}
                        rows={3}
                        placeholder="Informações adicionais sobre a manutenção"
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />

              {/* Botões de Ação */}
              <div className="flex justify-end space-x-4">
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => navigate('/manutencoes')}
                >
                  Cancelar
                </Button>
                <Button type="submit" disabled={loading}>
                  {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                  {loading ? 'Salvando...' : 'Salvar Manutenção'}
                </Button>
              </div>
            </form>
          </Form>
        </CardContent>
      </Card>
    </div>
  );
}

================
File: frontend/src/pages/Maintenance/MaintenanceList.jsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { api } from '@/services/api';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent } from "@/components/ui/card";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { useToast } from "@/components/ui/use-toast";

import {
  PlusCircle,
  Search,
  Filter,
  MoreVertical,
  Edit,
  FileText,
  Calendar as CalendarIcon,
  ChevronDown,
  Loader2,
} from 'lucide-react';

const STATUS_COLORS = {
  pending: "warning",
  in_progress: "info",
  completed: "success",
  cancelled: "destructive"
};

const STATUS_LABELS = {
  pending: "Pendente",
  in_progress: "Em Andamento",
  completed: "Concluído",
  cancelled: "Cancelado"
};

const TYPE_LABELS = {
  corrective: "Corretiva",
  preventive: "Preventiva",
  predictive: "Preditiva"
};

export default function MaintenanceList() {
  const navigate = useNavigate();
  const { toast } = useToast();
  const [loading, setLoading] = useState(true);
  const [maintenances, setMaintenances] = useState([]);
  const [filters, setFilters] = useState({
    search: '',
    status: '',
    type: '',
    dateRange: {
      from: null,
      to: null
    }
  });

  useEffect(() => {
    fetchMaintenances();
  }, [filters]);

  const fetchMaintenances = async () => {
    try {
      setLoading(true);
      const params = {
        ...filters,
        start_date: filters.dateRange.from?.toISOString(),
        end_date: filters.dateRange.to?.toISOString()
      };

      const response = await api.get('/maintenance', { params });
      setMaintenances(response.data);
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Erro ao carregar manutenções"
      });
    } finally {
      setLoading(false);
    }
  };

  const handleStatusChange = async (id, newStatus) => {
    try {
      await api.patch(`/maintenance/${id}/status`, { status: newStatus });
      toast({
        title: "Status atualizado",
        description: "Status da manutenção atualizado com sucesso"
      });
      fetchMaintenances();
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Erro ao atualizar status"
      });
    }
  };

  const handleGenerateReport = async (id) => {
    try {
      const response = await api.get(`/maintenance/${id}/report`, {
        responseType: 'blob'
      });
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `manutencao-${id}.pdf`);
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erro",
        description: "Erro ao gerar relatório"
      });
    }
  };

  const MaintenanceActions = ({ maintenance }) => (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" size="icon">
          <MoreVertical className="h-4 w-4" />
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end">
        <DropdownMenuItem onClick={() => navigate(`/manutencoes/${maintenance.id}/editar`)}>
          <Edit className="mr-2 h-4 w-4" />
          Editar
        </DropdownMenuItem>
        <DropdownMenuItem onClick={() => handleGenerateReport(maintenance.id)}>
          <FileText className="mr-2 h-4 w-4" />
          Gerar Relatório
        </DropdownMenuItem>
        {maintenance.status !== 'completed' && (
          <DropdownMenuItem onClick={() => handleStatusChange(maintenance.id, 'completed')}>
            <FileText className="mr-2 h-4 w-4" />
            Marcar como Concluída
          </DropdownMenuItem>
        )}
      </DropdownMenuContent>
    </DropdownMenu>
  );

  return (
    <div className="container mx-auto py-6 space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-3xl font-bold tracking-tight">Manutenções</h1>
          <p className="text-muted-foreground">
            Gerencie as manutenções do sistema
          </p>
        </div>
        <Button onClick={() => navigate('/manutencoes/nova')}>
          <PlusCircle className="mr-2 h-4 w-4" />
          Nova Manutenção
        </Button>
      </div>

      <Card>
        <CardContent className="p-6">
          {/* Filtros */}
          <div className="flex flex-wrap gap-4 mb-6">
            <div className="flex-1 min-w-[200px]">
              <Input
                placeholder="Buscar manutenções..."
                value={filters.search}
                onChange={(e) => setFilters(prev => ({
                  ...prev,
                  search: e.target.value
                }))}
                leftIcon={<Search className="h-4 w-4 text-muted-foreground" />}
              />
            </div>
            
            <Select
              value={filters.status}
              onValueChange={(value) => setFilters(prev => ({
                ...prev,
                status: value
              }))}
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Status" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">Todos</SelectItem>
                <SelectItem value="pending">Pendente</SelectItem>
                <SelectItem value="in_progress">Em Andamento</SelectItem>
                <SelectItem value="completed">Concluído</SelectItem>
                <SelectItem value="cancelled">Cancelado</SelectItem>
              </SelectContent>
            </Select>

            <Select
              value={filters.type}
              onValueChange={(value) => setFilters(prev => ({
                ...prev,
                type: value
              }))}
            >
              <SelectTrigger className="w-[180px]">
                <SelectValue placeholder="Tipo" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="">Todos</SelectItem>
                <SelectItem value="corrective">Corretiva</SelectItem>
                <SelectItem value="preventive">Preventiva</SelectItem>
                <SelectItem value="predictive">Preditiva</SelectItem>
              </SelectContent>
            </Select>

            <Popover>
              <PopoverTrigger asChild>
                <Button
                  variant="outline"
                  className="w-[240px] justify-start text-left font-normal"
                >
                  <CalendarIcon className="mr-2 h-4 w-4" />
                  {filters.dateRange.from ? (
                    filters.dateRange.to ? (
                      <>
                        {format(filters.dateRange.from, "P", { locale: ptBR })} -{" "}
                        {format(filters.dateRange.to, "P", { locale: ptBR })}
                      </>
                    ) : (
                      format(filters.dateRange.from, "P", { locale: ptBR })
                    )
                  ) : (
                    <span>Selecione o período</span>
                  )}
                </Button>
              </PopoverTrigger>
              <PopoverContent className="w-auto p-0" align="start">
                <Calendar
                  mode="range"
                  selected={filters.dateRange}
                  onSelect={(range) => setFilters(prev => ({
                    ...prev,
                    dateRange: range || { from: null, to: null }
                  }))}
                  locale={ptBR}
                />
              </PopoverContent>
            </Popover>

            <Button
              variant="outline"
              onClick={() => setFilters({
                search: '',
                status: '',
                type: '',
                dateRange: { from: null, to: null }
              })}
            >
              Limpar Filtros
            </Button>
          </div>

          {/* Lista de Manutenções */}
          {loading ? (
            <div className="flex justify-center items-center h-48">
              <Loader2 className="h-8 w-8 animate-spin" />
            </div>
          ) : (
            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead>Equipamento</TableHead>
                    <TableHead>Tipo</TableHead>
                    <TableHead>Status</TableHead>
                    <TableHead>Data Agendada</TableHead>
                    <TableHead>Técnico</TableHead>
                    <TableHead>Prioridade</TableHead>
                    <TableHead className="text-right">Ações</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {maintenances.map((maintenance) => (
                    <TableRow key={maintenance.id}>
                      <TableCell>
                        <div>
                          <div className="font-medium">{maintenance.equipment.name}</div>
                          <div className="text-sm text-muted-foreground">
                            {maintenance.equipment.code}
                          </div>
                        </div>
                      </TableCell>
                      <TableCell>{TYPE_LABELS[maintenance.type]}</TableCell>
                      <TableCell>
                        <Badge variant={STATUS_COLORS[maintenance.status]}>
                          {STATUS_LABELS[maintenance.status]}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        {format(new Date(maintenance.scheduled_for), "PP", { locale: ptBR })}
                      </TableCell>
                      <TableCell>
                        {maintenance.technician?.name || '-'}
                      </TableCell>
                      <TableCell>
                        <Badge
                          variant={
                            maintenance.priority === 'critical' ? 'destructive' :
                            maintenance.priority === 'high' ? 'warning' :
                            maintenance.priority === 'medium' ? 'default' :
                            'secondary'
                          }
                        >
                          {maintenance.priority === 'critical' ? 'Crítica' :
                           maintenance.priority === 'high' ? 'Alta' :
                           maintenance.priority === 'medium' ? 'Média' :
                           'Baixa'}
                        </Badge>
                      </TableCell>
                      <TableCell className="text-right">
                        <MaintenanceActions maintenance={maintenance} />
                      </TableCell>
                    </TableRow>
                  ))}
                  {maintenances.length === 0 && (
                    <TableRow>
                      <TableCell colSpan={7} className="text-center py-8">
                        <div className="flex flex-col items-center text-muted-foreground">
                          <FileText className="h-8 w-8 mb-2" />
                          <p>Nenhuma manutenção encontrada</p>
                        </div>
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
}

================
File: frontend/src/pages/Profile/Profile.jsx
================
import React, { useState } from 'react';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  Grid,
  Alert,
  Avatar,
  IconButton,
  Divider
} from '@mui/material';
import { LoadingButton } from '@mui/lab';
import { 
  Save, 
  PhotoCamera,
  Delete as DeleteIcon
} from '@mui/icons-material';
import { useAuth } from '../../contexts/AuthContext';
import api from '../../services/api';

const Profile = () => {
  const { user, updateUser } = useAuth();
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [formData, setFormData] = useState({
    name: user?.name || '',
    email: user?.email || '',
    currentPassword: '',
    newPassword: '',
    passwordConfirmation: ''
  });
  const [avatar, setAvatar] = useState({
    preview: user?.avatar_url,
    file: null
  });

  const handleAvatarChange = (event) => {
    if (event.target.files?.[0]) {
      const file = event.target.files[0];
      setAvatar({
        preview: URL.createObjectURL(file),
        file
      });
    }
  };

  const removeAvatar = () => {
    setAvatar({
      preview: null,
      file: null
    });
  };

  const validateForm = () => {
    if (!formData.name.trim()) {
      setError('Nome é obrigatório');
      return false;
    }

    if (formData.newPassword) {
      if (!formData.currentPassword) {
        setError('Senha atual é obrigatória para alterar a senha');
        return false;
      }

      if (formData.newPassword.length < 6) {
        setError('A nova senha deve ter no mínimo 6 caracteres');
        return false;
      }

      if (formData.newPassword !== formData.passwordConfirmation) {
        setError('As senhas não conferem');
        return false;
      }
    }

    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!validateForm()) return;

    setLoading(true);
    setError('');
    setSuccess('');

    try {
      const formPayload = new FormData();
      formPayload.append('name', formData.name);
      
      if (formData.currentPassword) {
        formPayload.append('currentPassword', formData.currentPassword);
        formPayload.append('newPassword', formData.newPassword);
      }

      if (avatar.file) {
        formPayload.append('avatar', avatar.file);
      }

      if (avatar.preview === null && user?.avatar_url) {
        formPayload.append('removeAvatar', 'true');
      }

      const response = await api.put('/users/profile', formPayload);
      await updateUser(response.data);
      setSuccess('Perfil atualizado com sucesso!');
      
      // Limpa os campos de senha
      setFormData(prev => ({
        ...prev,
        currentPassword: '',
        newPassword: '',
        passwordConfirmation: ''
      }));
    } catch (error) {
      setError(error.response?.data?.message || 'Erro ao atualizar perfil');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box>
      <Typography variant="h4" component="h1" sx={{ mb: 4 }}>
        Meu Perfil
      </Typography>

      <Paper sx={{ p: 3 }}>
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}

        {success && (
          <Alert severity="success" sx={{ mb: 3 }}>
            {success}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <Grid container spacing={3}>
            <Grid item xs={12} sx={{ display: 'flex', justifyContent: 'center', mb: 2 }}>
              <Box sx={{ position: 'relative' }}>
                <Avatar
                  src={avatar.preview}
                  sx={{ width: 120, height: 120 }}
                />
                <IconButton
                  color="primary"
                  component="label"
                  sx={{
                    position: 'absolute',
                    bottom: 0,
                    right: 0,
                    backgroundColor: 'background.paper'
                  }}
                >
                  <input
                    hidden
                    accept="image/*"
                    type="file"
                    onChange={handleAvatarChange}
                  />
                  <PhotoCamera />
                </IconButton>
                {(avatar.preview || user?.avatar_url) && (
                  <IconButton
                    color="error"
                    onClick={removeAvatar}
                    sx={{
                      position: 'absolute',
                      bottom: 0,
                      left: 0,
                      backgroundColor: 'background.paper'
                    }}
                  >
                    <DeleteIcon />
                  </IconButton>
                )}
              </Box>
            </Grid>

            <Grid item xs={12}>
              <TextField
                required
                fullWidth
                label="Nome"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
              />
            </Grid>

            <Grid item xs={12}>
              <TextField
                fullWidth
                disabled
                label="Email"
                value={formData.email}
              />
            </Grid>

            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" gutterBottom>
                Alterar Senha
              </Typography>
            </Grid>

            <Grid item xs={12}>
              <TextField
                fullWidth
                type="password"
                label="Senha Atual"
                value={formData.currentPassword}
                onChange={(e) => setFormData({ ...formData, currentPassword: e.target.value })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                type="password"
                label="Nova Senha"
                value={formData.newPassword}
                onChange={(e) => setFormData({ ...formData, newPassword: e.target.value })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                type="password"
                label="Confirmar Nova Senha"
                value={formData.passwordConfirmation}
                onChange={(e) => setFormData({ ...formData, passwordConfirmation: e.target.value })}
              />
            </Grid>
          </Grid>

          <Box sx={{ mt: 4, display: 'flex', justifyContent: 'flex-end' }}>
            <LoadingButton
              type="submit"
              variant="contained"
              loading={loading}
              startIcon={<Save />}
            >
              Salvar Alterações
            </LoadingButton>
          </Box>
        </form>
      </Paper>
    </Box>
  );
};

export default Profile;

================
File: frontend/src/pages/ServiceOrder/ServiceOrderForm.jsx
================
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  CircularProgress,
  Divider,
  Card,
  CardMedia,
  IconButton
} from '@mui/material';
import { LoadingButton } from '@mui/lab';
import { 
  Save, 
  ArrowBack, 
  Upload, 
  Delete,
  Camera,
  ClearAll
} from '@mui/icons-material';
import SignatureCanvas from 'react-signature-canvas';
import { useDropzone } from 'react-dropzone';
import { DateTimePicker } from '@mui/x-date-pickers';
import api from '../../services/api';

const ServiceOrderForm = () => {
  const navigate = useNavigate();
  const { id } = useParams();
  const signatureRef = useRef();
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState('');
  const [equipments, setEquipments] = useState([]);
  const [formData, setFormData] = useState({
    equipment_id: '',
    description: '',
    type: 'corrective',
    priority: 'medium',
    scheduled_for: new Date(),
    notes: '',
    cost: '',
    parts_replaced: []
  });
  const [photos, setPhotos] = useState([]);
  const [signature, setSignature] = useState(null);

  useEffect(() => {
    fetchEquipments();
    if (id) {
      loadServiceOrder();
    }
  }, [id]);

  const fetchEquipments = async () => {
    try {
      const response = await api.get('/equipment');
      setEquipments(response.data);
    } catch (error) {
      console.error('Erro ao carregar equipamentos:', error);
    }
  };

  const loadServiceOrder = async () => {
    setLoading(true);
    try {
      const response = await api.get(`/service-orders/${id}`);
      const { photos: servicePhotos, signature: serviceSignature, ...orderData } = response.data;
      
      setFormData(orderData);
      if (servicePhotos) {
        setPhotos(servicePhotos.map(photo => ({
          preview: photo.url,
          id: photo.id
        })));
      }
      if (serviceSignature) {
        setSignature(serviceSignature);
      }
    } catch (error) {
      setError('Erro ao carregar ordem de serviço');
    } finally {
      setLoading(false);
    }
  };

  const { getRootProps, getInputProps } = useDropzone({
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png']
    },
    onDrop: (acceptedFiles) => {
      setPhotos([
        ...photos,
        ...acceptedFiles.map(file => Object.assign(file, {
          preview: URL.createObjectURL(file)
        }))
      ]);
    }
  });

  const handleSubmit = async (e) => {
    e.preventDefault();
    setSaving(true);
    setError('');

    try {
      const formPayload = new FormData();

      // Adiciona os dados do formulário
      Object.keys(formData).forEach(key => {
        if (key === 'parts_replaced') {
          formPayload.append(key, JSON.stringify(formData[key]));
        } else {
          formPayload.append(key, formData[key]);
        }
      });

      // Adiciona as fotos
      photos.forEach((photo) => {
        if (!photo.id) { // Apenas envia se for uma nova foto
          formPayload.append('photos', photo);
        }
      });

      // Adiciona a assinatura se houver
      if (signature && !signature.id) {
        const signatureBlob = await new Promise(resolve => signatureRef.current.toBlob(resolve));
        formPayload.append('signature', signatureBlob, 'signature.png');
      }

      if (id) {
        await api.put(`/service-orders/${id}`, formPayload);
      } else {
        await api.post('/service-orders', formPayload);
      }

      navigate('/ordens-servico');
    } catch (error) {
      setError(error.response?.data?.message || 'Erro ao salvar ordem de serviço');
    } finally {
      setSaving(false);
    }
  };

  const handleRemovePhoto = (index) => {
    const newPhotos = [...photos];
    newPhotos.splice(index, 1);
    setPhotos(newPhotos);
  };

  const handleAddPart = () => {
    setFormData({
      ...formData,
      parts_replaced: [
        ...formData.parts_replaced,
        { name: '', quantity: 1, cost: 0 }
      ]
    });
  };

  const handleRemovePart = (index) => {
    const newParts = [...formData.parts_replaced];
    newParts.splice(index, 1);
    setFormData({
      ...formData,
      parts_replaced: newParts
    });
  };

  const handlePartChange = (index, field, value) => {
    const newParts = [...formData.parts_replaced];
    newParts[index][field] = value;
    setFormData({
      ...formData,
      parts_replaced: newParts
    });
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Box sx={{ mb: 4, display: 'flex', justifyContent: 'space-between' }}>
        <Typography variant="h4" component="h1">
          {id ? 'Editar Ordem de Serviço' : 'Nova Ordem de Serviço'}
        </Typography>
        <Button
          variant="outlined"
          startIcon={<ArrowBack />}
          onClick={() => navigate('/ordens-servico')}
        >
          Voltar
        </Button>
      </Box>

      <Paper sx={{ p: 3 }}>
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <Grid container spacing={3}>
            <Grid item xs={12}>
              <FormControl fullWidth required>
                <InputLabel>Equipamento</InputLabel>
                <Select
                  value={formData.equipment_id}
                  onChange={(e) => setFormData({
                    ...formData,
                    equipment_id: e.target.value
                  })}
                  label="Equipamento"
                >
                  {equipments.map((equipment) => (
                    <MenuItem key={equipment.id} value={equipment.id}>
                      {equipment.name} - {equipment.code}
                    </MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12}>
              <TextField
                required
                fullWidth
                multiline
                rows={4}
                label="Descrição do Problema/Serviço"
                value={formData.description}
                onChange={(e) => setFormData({
                  ...formData,
                  description: e.target.value
                })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required>
                <InputLabel>Tipo</InputLabel>
                <Select
                  value={formData.type}
                  onChange={(e) => setFormData({
                    ...formData,
                    type: e.target.value
                  })}
                  label="Tipo"
                >
                  <MenuItem value="corrective">Corretiva</MenuItem>
                  <MenuItem value="preventive">Preventiva</MenuItem>
                  <MenuItem value="predictive">Preditiva</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6}>
              <FormControl fullWidth required>
                <InputLabel>Prioridade</InputLabel>
                <Select
                  value={formData.priority}
                  onChange={(e) => setFormData({
                    ...formData,
                    priority: e.target.value
                  })}
                  label="Prioridade"
                >
                  <MenuItem value="low">Baixa</MenuItem>
                  <MenuItem value="medium">Média</MenuItem>
                  <MenuItem value="high">Alta</MenuItem>
                  <MenuItem value="critical">Crítica</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12}>
              <DateTimePicker
                label="Data e Hora Agendada"
                value={formData.scheduled_for}
                onChange={(date) => setFormData({
                  ...formData,
                  scheduled_for: date
                })}
                slotProps={{ textField: { fullWidth: true } }}
              />
            </Grid>

            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" sx={{ mb: 2 }}>
                Fotos
              </Typography>

              <Box
                {...getRootProps()}
                sx={{
                  border: '2px dashed #ccc',
                  borderRadius: 2,
                  p: 3,
                  textAlign: 'center',
                  cursor: 'pointer',
                  mb: 2
                }}
              >
                <input {...getInputProps()} />
                <Camera sx={{ fontSize: 40, color: 'text.secondary', mb: 1 }} />
                <Typography>
                  Arraste fotos aqui ou clique para selecionar
                </Typography>
              </Box>

              <Grid container spacing={2}>
                {photos.map((photo, index) => (
                  <Grid item key={index} xs={6} sm={4} md={3}>
                    <Card>
                      <CardMedia
                        component="img"
                        height="140"
                        image={photo.preview}
                        alt={`Foto ${index + 1}`}
                      />
                      <IconButton
                        size="small"
                        color="error"
                        onClick={() => handleRemovePhoto(index)}
                        sx={{
                          position: 'absolute',
                          top: 4,
                          right: 4,
                          bgcolor: 'background.paper'
                        }}
                      >
                        <Delete />
                      </IconButton>
                    </Card>
                  </Grid>
                ))}
              </Grid>
            </Grid>

            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" sx={{ mb: 2 }}>
                Peças Substituídas
              </Typography>

              {formData.parts_replaced.map((part, index) => (
                <Box key={index} sx={{ mb: 2 }}>
                  <Grid container spacing={2} alignItems="center">
                    <Grid item xs={12} sm={6}>
                      <TextField
                        fullWidth
                        label="Nome da Peça"
                        value={part.name}
                        onChange={(e) => handlePartChange(index, 'name', e.target.value)}
                      />
                    </Grid>
                    <Grid item xs={6} sm={2}>
                      <TextField
                        fullWidth
                        type="number"
                        label="Quantidade"
                        value={part.quantity}
                        onChange={(e) => handlePartChange(index, 'quantity', e.target.value)}
                      />
                    </Grid>
                    <Grid item xs={6} sm={3}>
                      <TextField
                        fullWidth
                        type="number"
                        label="Custo Unitário"
                        value={part.cost}
                        onChange={(e) => handlePartChange(index, 'cost', e.target.value)}
                      />
                    </Grid>
                    <Grid item xs={12} sm={1}>
                      <IconButton
                        color="error"
                        onClick={() => handleRemovePart(index)}
                      >
                        <Delete />
                      </IconButton>
                    </Grid>
                  </Grid>
                </Box>
              ))}

              <Button
                variant="outlined"
                startIcon={<Add />}
                onClick={handleAddPart}
                sx={{ mt: 1 }}
              >
                Adicionar Peça
              </Button>
            </Grid>

            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" sx={{ mb: 2 }}>
                Assinatura do Técnico
              </Typography>

              <Box
                sx={{
                  border: '1px solid #ccc',
                  borderRadius: 1,
                  bgcolor: '#fff',
                  mb: 1
                }}
              >
                <SignatureCanvas
                  ref={signatureRef}
                  canvasProps={{
                    width: 600,
                    height: 200,
                    className: 'signature-canvas'
                  }}
                  backgroundColor="white"
                />
              </Box>

              <Button
                variant="outlined"
                startIcon={<ClearAll />}
                onClick={() => {
                  signatureRef.current?.clear();
                  setSignature(null);
                }}
                sx={{ mb: 2 }}
              >
                Limpar Assinatura
              </Button>
            </Grid>

            <Grid item xs={12}>
              <TextField
                fullWidth
                multiline
                rows={3}
                label="Observações Adicionais"
                value={formData.notes}
                onChange={(e) => setFormData({
                  ...formData,
                  notes: e.target.value
                })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                type="number"
                label="Custo Total"
                value={formData.cost}
                onChange={(e) => setFormData({
                  ...formData,
                  cost: e.target.value
                })}
                InputProps={{
                  startAdornment: 'R$'
                }}
              />
            </Grid>
          </Grid>

          <Box sx={{ mt: 4, display: 'flex', justifyContent: 'flex-end', gap: 2 }}>
            <Button
              variant="outlined"
              onClick={() => navigate('/ordens-servico')}
            >
              Cancelar
            </Button>
            <LoadingButton
              type="submit"
              variant="contained"
              loading={saving}
              startIcon={<Save />}
            >
              Salvar
            </LoadingButton>
          </Box>
        </form>
      </Paper>
    </Box>
  );
};

export default ServiceOrderForm;

================
File: frontend/src/pages/ServiceOrder/ServiceOrderList.jsx
================
import React, { useState, useEffect } from 'react';
import { Card, Badge } from '@/components/ui';
import { Calendar, Clock, Tool, AlertTriangle } from 'lucide-react';
import api from '../services/api';

export default function ServiceOrderList() {
  const [orders, setOrders] = useState([]);
  const [loading, setLoading] = useState(true);
  const [filters, setFilters] = useState({
    status: '',
    search: '',
  });

  useEffect(() => {
    fetchOrders();
  }, [filters]);

  const fetchOrders = async () => {
    try {
      const response = await api.get('/service-orders', { params: filters });
      setOrders(response.data);
    } catch (error) {
      console.error('Erro ao buscar ordens de serviço:', error);
    } finally {
      setLoading(false);
    }
  };

  const getStatusBadge = (status) => {
    const styles = {
      pending: 'bg-yellow-100 text-yellow-800',
      in_progress: 'bg-blue-100 text-blue-800',
      completed: 'bg-green-100 text-green-800',
      cancelled: 'bg-red-100 text-red-800'
    };

    const labels = {
      pending: 'Pendente',
      in_progress: 'Em Andamento',
      completed: 'Concluído',
      cancelled: 'Cancelado'
    };

    return (
      <Badge className={styles[status]}>
        {labels[status]}
      </Badge>
    );
  };

  return (
    <div className="space-y-6 p-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Ordens de Serviço</h1>
        <button className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded">
          Nova Ordem
        </button>
      </div>

      {loading ? (
        <div className="flex justify-center py-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
        </div>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {orders.map((order) => (
            <Card key={order.id} className="p-4 hover:shadow-lg transition-shadow">
              <div className="space-y-4">
                <div className="flex justify-between items-start">
                  <h3 className="font-semibold text-lg">{order.equipment.name}</h3>
                  {getStatusBadge(order.status)}
                </div>

                <p className="text-gray-600 line-clamp-2">{order.description}</p>

                <div className="space-y-2 text-sm text-gray-500">
                  <div className="flex items-center gap-2">
                    <Calendar className="w-4 h-4" />
                    <span>Agendado para: {new Date(order.scheduled_for).toLocaleDateString()}</span>
                  </div>

                  <div className="flex items-center gap-2">
                    <Clock className="w-4 h-4" />
                    <span>Horário: {new Date(order.scheduled_for).toLocaleTimeString()}</span>
                  </div>

                  <div className="flex items-center gap-2">
                    <Tool className="w-4 h-4" />
                    <span>Técnico: {order.technician?.name || 'Não atribuído'}</span>
                  </div>

                  {order.priority === 'high' && (
                    <div className="flex items-center gap-2 text-red-600">
                      <AlertTriangle className="w-4 h-4" />
                      <span>Prioridade Alta</span>
                    </div>
                  )}
                </div>
              </div>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}

================
File: frontend/src/pages/Settings/Settings.jsx
================
import React, { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  Grid,
  FormControlLabel,
  Switch,
  TextField,
  Button,
  Alert,
  Divider,
  Card,
  CardContent,
  Select,
  MenuItem,
  FormControl,
  InputLabel
} from '@mui/material';
import { LoadingButton } from '@mui/lab';
import { 
  Save,
  Notifications,
  Email,
  Settings as SettingsIcon
} from '@mui/icons-material';
import api from '../../services/api';

const Settings = () => {
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const [settings, setSettings] = useState({
    notifications: {
      email: true,
      push: true,
      maintenanceReminder: true,
      maintenanceOverdue: true,
      equipmentStatusChange: true
    },
    maintenance: {
      defaultFrequency: 30,
      reminderDays: 7,
      criticalAgeMonths: 12
    },
    email: {
      reminderTime: '08:00',
      dailyReportTime: '18:00',
      reportRecipients: ''
    }
  });

  useEffect(() => {
    loadSettings();
  }, []);

  const loadSettings = async () => {
    try {
      const response = await api.get('/settings');
      setSettings(response.data);
    } catch (error) {
      setError('Erro ao carregar configurações');
    } finally {
      setLoading(false);
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setSaving(true);
    setError('');
    setSuccess('');

    try {
      await api.put('/settings', settings);
      setSuccess('Configurações salvas com sucesso!');
    } catch (error) {
      setError('Erro ao salvar configurações');
    } finally {
      setSaving(false);
    }
  };

  const handleNotificationChange = (field) => (event) => {
    setSettings({
      ...settings,
      notifications: {
        ...settings.notifications,
        [field]: event.target.checked
      }
    });
  };

  const handleMaintenanceChange = (field, value) => {
    setSettings({
      ...settings,
      maintenance: {
        ...settings.maintenance,
        [field]: value
      }
    });
  };

  const handleEmailChange = (field, value) => {
    setSettings({
      ...settings,
      email: {
        ...settings.email,
        [field]: value
      }
    });
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
        Carregando...
      </Box>
    );
  }

  return (
    <Box>
      <Typography variant="h4" component="h1" sx={{ mb: 4 }}>
        Configurações
      </Typography>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      {success && (
        <Alert severity="success" sx={{ mb: 3 }}>
          {success}
        </Alert>
      )}

      <form onSubmit={handleSubmit}>
        <Grid container spacing={3}>
          <Grid item xs={12} md={6}>
            <Card>
              <CardContent>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <Notifications sx={{ mr: 1 }} />
                  <Typography variant="h6">Notificações</Typography>
                </Box>
                <Divider sx={{ mb: 2 }} />

                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.notifications.email}
                        onChange={handleNotificationChange('email')}
                      />
                    }
                    label="Notificações por Email"
                  />
                  
                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.notifications.push}
                        onChange={handleNotificationChange('push')}
                      />
                    }
                    label="Notificações Push"
                  />

                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.notifications.maintenanceReminder}
                        onChange={handleNotificationChange('maintenanceReminder')}
                      />
                    }
                    label="Lembrete de Manutenção"
                  />

                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.notifications.maintenanceOverdue}
                        onChange={handleNotificationChange('maintenanceOverdue')}
                      />
                    }
                    label="Alerta de Manutenção Atrasada"
                  />

                  <FormControlLabel
                    control={
                      <Switch
                        checked={settings.notifications.equipmentStatusChange}
                        onChange={handleNotificationChange('equipmentStatusChange')}
                      />
                    }
                    label="Mudança de Status do Equipamento"
                  />
                </Box>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12} md={6}>
            <Card>
              <CardContent>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <SettingsIcon sx={{ mr: 1 }} />
                  <Typography variant="h6">Manutenção</Typography>
                </Box>
                <Divider sx={{ mb: 2 }} />

                <Grid container spacing={2}>
                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      type="number"
                      label="Frequência Padrão de Manutenção (dias)"
                      value={settings.maintenance.defaultFrequency}
                      onChange={(e) => handleMaintenanceChange('defaultFrequency', Number(e.target.value))}
                      InputProps={{ inputProps: { min: 1 } }}
                    />
                  </Grid>

                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      type="number"
                      label="Dias de Antecedência para Lembrete"
                      value={settings.maintenance.reminderDays}
                      onChange={(e) => handleMaintenanceChange('reminderDays', Number(e.target.value))}
                      InputProps={{ inputProps: { min: 1 } }}
                    />
                  </Grid>

                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      type="number"
                      label="Idade Crítica do Equipamento (meses)"
                      value={settings.maintenance.criticalAgeMonths}
                      onChange={(e) => handleMaintenanceChange('criticalAgeMonths', Number(e.target.value))}
                      InputProps={{ inputProps: { min: 1 } }}
                    />
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          </Grid>

          <Grid item xs={12}>
            <Card>
              <CardContent>
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
                  <Email sx={{ mr: 1 }} />
                  <Typography variant="h6">Configurações de Email</Typography>
                </Box>
                <Divider sx={{ mb: 2 }} />

                <Grid container spacing={2}>
                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      type="time"
                      label="Horário dos Lembretes"
                      value={settings.email.reminderTime}
                      onChange={(e) => handleEmailChange('reminderTime', e.target.value)}
                      InputLabelProps={{ shrink: true }}
                    />
                  </Grid>

                  <Grid item xs={12} md={6}>
                    <TextField
                      fullWidth
                      type="time"
                      label="Horário do Relatório Diário"
                      value={settings.email.dailyReportTime}
                      onChange={(e) => handleEmailChange('dailyReportTime', e.target.value)}
                      InputLabelProps={{ shrink: true }}
                    />
                  </Grid>

                  <Grid item xs={12}>
                    <TextField
                      fullWidth
                      multiline
                      rows={3}
                      label="Destinatários dos Relatórios (um por linha)"
                      value={settings.email.reportRecipients}
                      onChange={(e) => handleEmailChange('reportRecipients', e.target.value)}
                      placeholder="email@exemplo.com&#10;outro@exemplo.com"
                      helperText="Digite um endereço de email por linha"
                    />
                  </Grid>
                </Grid>
              </CardContent>
            </Card>
          </Grid>
        </Grid>

        <Box sx={{ mt: 4, display: 'flex', justifyContent: 'flex-end' }}>
          <LoadingButton
            type="submit"
            variant="contained"
            loading={saving}
            startIcon={<Save />}
          >
            Salvar Configurações
          </LoadingButton>
        </Box>
      </form>
    </Box>
  );
};

export default Settings;

================
File: frontend/src/pages/User/UserForm.jsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  TextField,
  Button,
  Grid,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Alert,
  FormControlLabel,
  Switch,
  Divider
} from '@mui/material';
import { LoadingButton } from '@mui/lab';
import { Save, ArrowBack } from '@mui/icons-material';
import { useAuth } from '../../contexts/AuthContext';
import api from '../../services/api';

const UserForm = () => {
  const navigate = useNavigate();
  const { id } = useParams();
  const { user: currentUser } = useAuth();
  const [loading, setLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState('');
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    password: '',
    passwordConfirmation: '',
    role: 'technician',
    active: true
  });

  useEffect(() => {
    if (id) {
      loadUser();
    }
  }, [id]);

  const loadUser = async () => {
    setLoading(true);
    try {
      const response = await api.get(`/users/${id}`);
      const { password, ...userData } = response.data;
      setFormData(userData);
    } catch (error) {
      setError('Erro ao carregar usuário');
    } finally {
      setLoading(false);
    }
  };

  const validateForm = () => {
    if (!formData.name.trim()) {
      setError('Nome é obrigatório');
      return false;
    }

    if (!formData.email.trim()) {
      setError('Email é obrigatório');
      return false;
    }

    if (!id && !formData.password) {
      setError('Senha é obrigatória para novos usuários');
      return false;
    }

    if (formData.password && formData.password !== formData.passwordConfirmation) {
      setError('As senhas não conferem');
      return false;
    }

    if (formData.password && formData.password.length < 6) {
      setError('A senha deve ter no mínimo 6 caracteres');
      return false;
    }

    return true;
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (!validateForm()) return;

    setSaving(true);
    setError('');

    try {
      const { passwordConfirmation, ...submitData } = formData;
      
      if (id) {
        if (!submitData.password) {
          delete submitData.password;
        }
        await api.put(`/users/${id}`, submitData);
      } else {
        await api.post('/users', submitData);
      }

      navigate('/usuarios');
    } catch (error) {
      setError(error.response?.data?.message || 'Erro ao salvar usuário');
    } finally {
      setSaving(false);
    }
  };

  return (
    <Box>
      <Box sx={{ mb: 4, display: 'flex', justifyContent: 'space-between' }}>
        <Typography variant="h4" component="h1">
          {id ? 'Editar Usuário' : 'Novo Usuário'}
        </Typography>
        <Button
          variant="outlined"
          startIcon={<ArrowBack />}
          onClick={() => navigate('/usuarios')}
        >
          Voltar
        </Button>
      </Box>

      <Paper sx={{ p: 3 }}>
        {error && (
          <Alert severity="error" sx={{ mb: 3 }}>
            {error}
          </Alert>
        )}

        <form onSubmit={handleSubmit}>
          <Grid container spacing={3}>
            <Grid item xs={12} sm={6}>
              <TextField
                required
                fullWidth
                label="Nome"
                value={formData.name}
                onChange={(e) => setFormData({ ...formData, name: e.target.value })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                required
                fullWidth
                type="email"
                label="Email"
                value={formData.email}
                onChange={(e) => setFormData({ ...formData, email: e.target.value })}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>Função</InputLabel>
                <Select
                  value={formData.role}
                  onChange={(e) => setFormData({ ...formData, role: e.target.value })}
                  label="Função"
                  disabled={id === currentUser?.id}
                >
                  <MenuItem value="technician">Técnico</MenuItem>
                  <MenuItem value="manager">Gerente</MenuItem>
                  <MenuItem value="admin">Administrador</MenuItem>
                </Select>
              </FormControl>
            </Grid>

            <Grid item xs={12} sm={6}>
              <FormControlLabel
                control={
                  <Switch
                    checked={formData.active}
                    onChange={(e) => setFormData({ ...formData, active: e.target.checked })}
                    disabled={id === currentUser?.id}
                  />
                }
                label="Usuário Ativo"
              />
            </Grid>

            <Grid item xs={12}>
              <Divider sx={{ my: 2 }} />
              <Typography variant="h6" gutterBottom>
                Senha
              </Typography>
              {id && (
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  Preencha apenas se desejar alterar a senha
                </Typography>
              )}
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                type="password"
                label={id ? "Nova Senha" : "Senha"}
                value={formData.password}
                onChange={(e) => setFormData({ ...formData, password: e.target.value })}
                required={!id}
              />
            </Grid>

            <Grid item xs={12} sm={6}>
              <TextField
                fullWidth
                type="password"
                label="Confirmar Senha"
                value={formData.passwordConfirmation}
                onChange={(e) => setFormData({ ...formData, passwordConfirmation: e.target.value })}
                required={!id || formData.password}
              />
            </Grid>
          </Grid>

          <Box sx={{ mt: 4, display: 'flex', justifyContent: 'flex-end', gap: 2 }}>
            <Button
              variant="outlined"
              onClick={() => navigate('/usuarios')}
            >
              Cancelar
            </Button>
            <LoadingButton
              type="submit"
              variant="contained"
              loading={saving}
              startIcon={<Save />}
            >
              Salvar
            </LoadingButton>
          </Box>
        </form>
      </Paper>
    </Box>
  );
};

export default UserForm;

================
File: frontend/src/pages/User/UserList.jsx
================
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Paper,
  Typography,
  Button,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  TablePagination,
  IconButton,
  Chip,
  Menu,
  MenuItem,
  Alert,
  TextField,
  InputAdornment
} from '@mui/material';
import {
  Add,
  Search,
  MoreVert,
  Edit,
  Delete,
  Lock
} from '@mui/icons-material';
import api from '../../services/api';

const UserList = () => {
  const navigate = useNavigate();
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [totalCount, setTotalCount] = useState(0);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedUser, setSelectedUser] = useState(null);
  const [menuAnchorEl, setMenuAnchorEl] = useState(null);

  useEffect(() => {
    fetchUsers();
  }, [page, rowsPerPage, searchTerm]);

  const fetchUsers = async () => {
    try {
      const response = await api.get('/users', {
        params: {
          page: page + 1,
          limit: rowsPerPage,
          search: searchTerm
        }
      });

      setUsers(response.data.items);
      setTotalCount(response.data.total);
    } catch (error) {
      setError('Erro ao carregar usuários');
    } finally {
      setLoading(false);
    }
  };

  const handleSearchChange = (event) => {
    setSearchTerm(event.target.value);
    setPage(0);
  };

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleMenuOpen = (event, user) => {
    setSelectedUser(user);
    setMenuAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setMenuAnchorEl(null);
    setSelectedUser(null);
  };

  const handleEdit = () => {
    navigate(`/usuarios/${selectedUser.id}/editar`);
    handleMenuClose();
  };

  const handleResetPassword = async () => {
    try {
      await api.post(`/users/${selectedUser.id}/reset-password`);
      alert('Email de redefinição de senha enviado com sucesso!');
    } catch (error) {
      alert('Erro ao enviar email de redefinição de senha');
    }
    handleMenuClose();
  };

  const handleDelete = async () => {
    if (window.confirm('Tem certeza que deseja excluir este usuário?')) {
      try {
        await api.delete(`/users/${selectedUser.id}`);
        fetchUsers();
      } catch (error) {
        alert('Erro ao excluir usuário');
      }
    }
    handleMenuClose();
  };

  const getRoleColor = (role) => {
    switch (role) {
      case 'admin':
        return 'error';
      case 'manager':
        return 'warning';
      default:
        return 'primary';
    }
  };

  const getRoleText = (role) => {
    switch (role) {
      case 'admin':
        return 'Administrador';
      case 'manager':
        return 'Gerente';
      default:
        return 'Técnico';
    }
  };

  return (
    <Box>
      <Box sx={{ mb: 4, display: 'flex', justifyContent: 'space-between' }}>
        <Typography variant="h4" component="h1">
          Usuários
        </Typography>
        <Button
          variant="contained"
          startIcon={<Add />}
          onClick={() => navigate('/usuarios/novo')}
        >
          Novo Usuário
        </Button>
      </Box>

      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>
          {error}
        </Alert>
      )}

      <Paper sx={{ width: '100%', mb: 2 }}>
        <Box sx={{ p: 2 }}>
          <TextField
            fullWidth
            value={searchTerm}
            onChange={handleSearchChange}
            placeholder="Buscar usuários..."
            InputProps={{
              startAdornment: (
                <InputAdornment position="start">
                  <Search />
                </InputAdornment>
              ),
            }}
          />
        </Box>

        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>Nome</TableCell>
                <TableCell>Email</TableCell>
                <TableCell>Função</TableCell>
                <TableCell>Status</TableCell>
                <TableCell>Data de Cadastro</TableCell>
                <TableCell align="right">Ações</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {users.map((user) => (
                <TableRow key={user.id}>
                  <TableCell>{user.name}</TableCell>
                  <TableCell>{user.email}</TableCell>
                  <TableCell>
                    <Chip
                      label={getRoleText(user.role)}
                      color={getRoleColor(user.role)}
                      size="small"
                    />
                  </TableCell>
                  <TableCell>
                    <Chip
                      label={user.active ? 'Ativo' : 'Inativo'}
                      color={user.active ? 'success' : 'default'}
                      size="small"
                    />
                  </TableCell>
                  <TableCell>
                    {new Date(user.created_at).toLocaleDateString()}
                  </TableCell>
                  <TableCell align="right">
                    <IconButton
                      onClick={(event) => handleMenuOpen(event, user)}
                    >
                      <MoreVert />
                    </IconButton>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>

        <TablePagination
          component="div"
          count={totalCount}
          page={page}
          onPageChange={handleChangePage}
          rowsPerPage={rowsPerPage}
          onRowsPerPageChange={handleChangeRowsPerPage}
          rowsPerPageOptions={[5, 10, 25]}
        />
      </Paper>

      <Menu
        anchorEl={menuAnchorEl}
        open={Boolean(menuAnchorEl)}
        onClose={handleMenuClose}
      >
        <MenuItem onClick={handleEdit}>
          <Edit fontSize="small" sx={{ mr: 1 }} /> Editar
        </MenuItem>
        <MenuItem onClick={handleResetPassword}>
          <Lock fontSize="small" sx={{ mr: 1 }} /> Resetar Senha
        </MenuItem>
        <MenuItem onClick={handleDelete}>
          <Delete fontSize="small" sx={{ mr: 1 }} /> Excluir
        </MenuItem>
      </Menu>
    </Box>
  );
};

export default UserList;

================
File: frontend/src/routes/index.jsx
================
import React from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import Layout from '../components/Layout/Layout';

// Pages
import Login from '../pages/Login/Login';
import Dashboard from '../pages/Dashboard/Dashboard';
import EquipmentList from '../pages/Equipment/EquipmentList';
import EquipmentForm from '../pages/Equipment/EquipmentForm';
import ServiceOrderList from '../pages/ServiceOrder/ServiceOrderList';
import ServiceOrderForm from '../pages/ServiceOrder/ServiceOrderForm';
import UserList from '../pages/User/UserList';
import UserForm from '../pages/User/UserForm';
import Profile from '../pages/Profile/Profile';
import Settings from '../pages/Settings/Settings';

const PrivateRoute = ({ children }) => {
  const { signed, loading } = useAuth();

  if (loading) {
    return <div>Carregando...</div>;
  }

  return signed ? children : <Navigate to="/login" />;
};

const AdminRoute = ({ children }) => {
  const { user, loading } = useAuth();

  if (loading) {
    return <div>Carregando...</div>;
  }

  return user?.role === 'admin' ? children : <Navigate to="/dashboard" />;
};

const AppRoutes = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<Login />} />
        
        <Route
          path="/"
          element={
            <PrivateRoute>
              <Layout />
            </PrivateRoute>
          }
        >
          <Route index element={<Navigate to="/dashboard" />} />
          <Route path="dashboard" element={<Dashboard />} />
          
          <Route path="equipamentos">
            <Route index element={<EquipmentList />} />
            <Route path="novo" element={<EquipmentForm />} />
            <Route path=":id/editar" element={<EquipmentForm />} />
          </Route>

          <Route path="ordens-servico">
            <Route index element={<ServiceOrderList />} />
            <Route path="nova" element={<ServiceOrderForm />} />
            <Route path=":id/editar" element={<ServiceOrderForm />} />
          </Route>

          <Route
            path="usuarios"
            element={
              <AdminRoute>
                <UserList />
              </AdminRoute>
            }
          />
          <Route
            path="usuarios/novo"
            element={
              <AdminRoute>
                <UserForm />
              </AdminRoute>
            }
          />
          <Route
            path="usuarios/:id/editar"
            element={
              <AdminRoute>
                <UserForm />
              </AdminRoute>
            }
          />

          <Route path="perfil" element={<Profile />} />
          <Route path="configuracoes" element={<Settings />} />
        </Route>

        <Route path="*" element={<Navigate to="/dashboard" />} />
      </Routes>
    </BrowserRouter>
  );
};

export default AppRoutes;

================
File: frontend/src/services/api.js
================
import axios from 'axios';
import { toast } from '@/components/ui/use-toast';

export const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:3000/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  }
});

// Interceptor para adicionar token em todas as requisições
api.interceptors.request.use((config) => {
  const token = localStorage.getItem('@EquipmentManagement:token');
  
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }

  // Para requisições com FormData, remover o Content-Type para que o navegador defina automaticamente
  if (config.data instanceof FormData) {
    delete config.headers['Content-Type'];
  }

  return config;
}, (error) => {
  return Promise.reject(error);
});

// Interceptor para tratamento de respostas e erros
api.interceptors.response.use(
  (response) => response.data,
  (error) => {
    if (!error.response) {
      toast({
        variant: "destructive",
        title: "Erro de conexão",
        description: "Não foi possível conectar ao servidor"
      });
      return Promise.reject(new Error('Erro de conexão'));
    }

    // Token expirado ou inválido
    if (error.response.status === 401) {
      localStorage.removeItem('@EquipmentManagement:token');
      localStorage.removeItem('@EquipmentManagement:user');
      
      // Recarrega a página apenas se não estiver na página de login
      if (!window.location.pathname.includes('/login')) {
        toast({
          variant: "destructive",
          title: "Sessão expirada",
          description: "Por favor, faça login novamente"
        });
        window.location.href = '/login';
      }
      return Promise.reject(new Error('Sessão expirada'));
    }

    // Erro de permissão
    if (error.response.status === 403) {
      toast({
        variant: "destructive",
        title: "Acesso negado",
        description: "Você não tem permissão para realizar esta ação"
      });
      return Promise.reject(new Error('Acesso negado'));
    }

    // Erro de validação
    if (error.response.status === 422) {
      const errors = error.response.data.errors;
      if (Array.isArray(errors)) {
        errors.forEach(err => {
          toast({
            variant: "destructive",
            title: "Erro de validação",
            description: err.message
          });
        });
      }
      return Promise.reject(error.response.data);
    }

    // Outros erros
    const errorMessage = error.response.data?.message || error.response.data?.error || 'Ocorreu um erro inesperado';
    toast({
      variant: "destructive",
      title: "Erro",
      description: errorMessage
    });

    return Promise.reject(error.response.data);
  }
);

// Funções auxiliares para endpoints comuns
export const endpoints = {
  auth: {
    login: (data) => api.post('/auth/login', data),
    forgotPassword: (data) => api.post('/auth/forgot-password', data),
    resetPassword: (data) => api.post('/auth/reset-password', data),
    validateToken: (token) => api.post('/auth/validate-token', { token }),
  },

  equipment: {
    list: (params) => api.get('/equipment', { params }),
    get: (id) => api.get(`/equipment/${id}`),
    create: (data) => api.post('/equipment', data),
    update: (id, data) => api.put(`/equipment/${id}`, data),
    delete: (id) => api.delete(`/equipment/${id}`),
    getQRCode: (id) => api.get(`/equipment/${id}/qrcode`),
    exportAll: (format = 'pdf') => api.get(`/equipment/export?format=${format}`, {
      responseType: 'blob'
    }),
  },

  maintenance: {
    list: (params) => api.get('/maintenance', { params }),
    get: (id) => api.get(`/maintenance/${id}`),
    create: (data) => api.post('/maintenance', data),
    update: (id, data) => api.put(`/maintenance/${id}`, data),
    updateStatus: (id, status) => api.patch(`/maintenance/${id}/status`, { status }),
    getReport: (id, format = 'pdf') => api.get(`/maintenance/${id}/report?format=${format}`, {
      responseType: 'blob'
    }),
  },

  users: {
    list: (params) => api.get('/users', { params }),
    get: (id) => api.get(`/users/${id}`),
    create: (data) => api.post('/users', data),
    update: (id, data) => api.put(`/users/${id}`, data),
    updateProfile: (data) => api.put('/users/profile', data),
    updatePassword: (data) => api.put('/users/password', data),
    delete: (id) => api.delete(`/users/${id}`),
  },

  dashboard: {
    getStats: (period = 'month') => api.get(`/dashboard/stats?period=${period}`),
    getMaintenanceMetrics: (params) => api.get('/dashboard/maintenance-metrics', { params }),
    getEquipmentPerformance: () => api.get('/dashboard/equipment-performance'),
  },

  notifications: {
    list: (params) => api.get('/notifications', { params }),
    markAsRead: (id) => api.put(`/notifications/${id}/read`),
    markAllAsRead: () => api.put('/notifications/mark-all-read'),
    getPreferences: () => api.get('/notifications/preferences'),
    updatePreferences: (data) => api.put('/notifications/preferences', data),
  },

  files: {
    upload: (file, type = 'general') => {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('type', type);
      return api.post('/files', formData);
    },
    delete: (id) => api.delete(`/files/${id}`),
  },

  reports: {
    generate: (type, params) => api.get(`/reports/${type}`, {
      params,
      responseType: 'blob'
    }),
    getStatus: (jobId) => api.get(`/reports/status/${jobId}`),
    download: (reportId) => api.get(`/reports/${reportId}/download`, {
      responseType: 'blob'
    }),
  }
};

export const handleApiError = (error) => {
  if (axios.isAxiosError(error)) {
    const message = error.response?.data?.message || error.message;
    toast({
      variant: "destructive",
      title: "Erro",
      description: message
    });
  } else {
    toast({
      variant: "destructive",
      title: "Erro",
      description: "Ocorreu um erro inesperado"
    });
  }
  return error;
};

export default api;

================
File: frontend/src/services/cacheService.jsx
================
class CacheService {
    constructor() {
      this.prefix = 'equipment_management_';
      this.defaultTTL = 5 * 60 * 1000; // 5 minutos em milissegundos
    }
  
    async get(key, fetchCallback = null) {
      const fullKey = this.prefix + key;
      const stored = localStorage.getItem(fullKey);
  
      if (stored) {
        const { value, timestamp, ttl } = JSON.parse(stored);
        const now = new Date().getTime();
  
        // Verifica se o cache ainda é válido
        if (timestamp + ttl > now) {
          return value;
        }
        
        // Remove o cache expirado
        this.remove(key);
      }
  
      // Se há um callback para buscar dados, executa e armazena
      if (fetchCallback) {
        const value = await fetchCallback();
        this.set(key, value);
        return value;
      }
  
      return null;
    }
  
    set(key, value, ttl = this.defaultTTL) {
      const fullKey = this.prefix + key;
      const data = {
        value,
        timestamp: new Date().getTime(),
        ttl
      };
  
      try {
        localStorage.setItem(fullKey, JSON.stringify(data));
        return true;
      } catch (error) {
        console.error('Erro ao armazenar em cache:', error);
        this.clearOldItems(); // Tenta liberar espaço
        return false;
      }
    }
  
    remove(key) {
      const fullKey = this.prefix + key;
      localStorage.removeItem(fullKey);
    }
  
    clear() {
      Object.keys(localStorage)
        .filter(key => key.startsWith(this.prefix))
        .forEach(key => localStorage.removeItem(key));
    }
  
    clearOldItems() {
      const now = new Date().getTime();
  
      Object.keys(localStorage)
        .filter(key => key.startsWith(this.prefix))
        .forEach(key => {
          try {
            const stored = JSON.parse(localStorage.getItem(key));
            if (stored.timestamp + stored.ttl < now) {
              localStorage.removeItem(key);
            }
          } catch (error) {
            localStorage.removeItem(key);
          }
        });
    }
  
    async getEquipmentList() {
      return this.get('equipment_list', async () => {
        const response = await api.get('/equipment');
        return response.data;
      });
    }
  
    async getEquipmentDetails(id) {
      return this.get(`equipment_${id}`, async () => {
        const response = await api.get(`/equipment/${id}`);
        return response.data;
      });
    }
  
    async getUserPreferences() {
      return this.get('user_preferences', async () => {
        const response = await api.get('/users/preferences');
        return response.data;
      });
    }
  
    updateEquipmentCache(equipment) {
      this.set(`equipment_${equipment.id}`, equipment);
      
      // Atualiza também a lista de equipamentos
      this.get('equipment_list').then(list => {
        if (list) {
          const updatedList = list.map(item => 
            item.id === equipment.id ? equipment : item
          );
          this.set('equipment_list', updatedList);
        }
      });
    }
  
    invalidateEquipmentCache(equipmentId) {
      this.remove(`equipment_${equipmentId}`);
      this.remove('equipment_list');
    }
  
    getOfflineCapableData() {
      const offlineData = {
        equipment: [],
        serviceOrders: [],
        preferences: null
      };
  
      Object.keys(localStorage)
        .filter(key => key.startsWith(this.prefix))
        .forEach(key => {
          try {
            const stored = JSON.parse(localStorage.getItem(key));
            if (key.includes('equipment_list')) {
              offlineData.equipment = stored.value;
            } else if (key.includes('service_orders')) {
              offlineData.serviceOrders = stored.value;
            } else if (key.includes('user_preferences')) {
              offlineData.preferences = stored.value;
            }
          } catch (error) {
            console.error('Erro ao ler dados offline:', error);
          }
        });
  
      return offlineData;
    }
  
    estimateCacheSize() {
      let totalSize = 0;
      Object.keys(localStorage)
        .filter(key => key.startsWith(this.prefix))
        .forEach(key => {
          totalSize += localStorage.getItem(key).length * 2; // Aproximação em bytes
        });
      return totalSize;
    }
  
    setupPeriodicCleanup(interval = 60 * 60 * 1000) { // 1 hora
      setInterval(() => this.clearOldItems(), interval);
    }
  }
  
  export default new CacheService();

================
File: frontend/src/services/dashboardService.jsx
================
import api from './api';

class DashboardService {
  async getStatistics(period = 'month') {
    try {
      const response = await api.get('/dashboard/stats', {
        params: { period }
      });
      return this.formatStatistics(response.data);
    } catch (error) {
      console.error('Erro ao carregar estatísticas:', error);
      throw new Error('Falha ao carregar dados do dashboard');
    }
  }

  async getMaintenanceMetrics(startDate, endDate) {
    try {
      const response = await api.get('/dashboard/maintenance-metrics', {
        params: { start_date: startDate, end_date: endDate }
      });
      return this.formatMaintenanceMetrics(response.data);
    } catch (error) {
      console.error('Erro ao carregar métricas de manutenção:', error);
      throw new Error('Falha ao carregar métricas de manutenção');
    }
  }

  async getEquipmentPerformance() {
    try {
      const response = await api.get('/dashboard/equipment-performance');
      return this.formatEquipmentPerformance(response.data);
    } catch (error) {
      console.error('Erro ao carregar performance dos equipamentos:', error);
      throw new Error('Falha ao carregar performance dos equipamentos');
    }
  }

  formatStatistics(data) {
    return {
      summary: {
        totalEquipments: data.totalEquipments,
        activeEquipments: data.activeEquipments,
        maintenanceInProgress: data.maintenanceInProgress,
        pendingMaintenances: data.pendingMaintenances
      },
      maintenancesByType: [
        {
          name: 'Preventiva',
          value: data.preventiveMaintenances,
          color: '#4CAF50'
        },
        {
          name: 'Corretiva',
          value: data.correctiveMaintenances,
          color: '#FFA000'
        },
        {
          name: 'Preditiva',
          value: data.predictiveMaintenances,
          color: '#2196F3'
        }
      ],
      maintenanceTrend: data.maintenanceTrend.map(item => ({
        date: new Date(item.date).toLocaleDateString(),
        preventive: item.preventive,
        corrective: item.corrective,
        predictive: item.predictive
      })),
      departmentStats: data.departmentStats.map(item => ({
        name: item.department,
        maintenances: item.maintenanceCount,
        equipments: item.equipmentCount,
        costs: item.totalCosts
      }))
    };
  }

  formatMaintenanceMetrics(data) {
    return {
      averageResolutionTime: this.formatDuration(data.averageResolutionTime),
      completionRate: `${data.completionRate.toFixed(1)}%`,
      averageCost: this.formatCurrency(data.averageCost),
      maintenanceEfficiency: data.maintenanceEfficiency.map(item => ({
        technician: item.technicianName,
        completedCount: item.completedCount,
        averageTime: this.formatDuration(item.averageTime),
        satisfactionRate: `${item.satisfactionRate.toFixed(1)}%`
      }))
    };
  }

  formatEquipmentPerformance(data) {
    return {
      mostMaintained: data.mostMaintained.map(item => ({
        name: item.name,
        code: item.code,
        maintenanceCount: item.maintenanceCount,
        totalCost: this.formatCurrency(item.totalCost),
        lastMaintenance: new Date(item.lastMaintenance).toLocaleDateString()
      })),
      criticalEquipments: data.criticalEquipments.map(item => ({
        name: item.name,
        code: item.code,
        status: item.status,
        lastMaintenance: new Date(item.lastMaintenance).toLocaleDateString(),
        daysOverdue: item.daysOverdue
      }))
    };
  }

  formatDuration(minutes) {
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;
    return hours > 0 
      ? `${hours}h ${remainingMinutes}min`
      : `${remainingMinutes}min`;
  }

  formatCurrency(value) {
    return new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);
  }

  calculateKPIs(data) {
    return {
      mtbf: this.calculateMTBF(data.failures, data.operatingHours),
      mttr: this.calculateMTTR(data.repairTimes),
      availability: this.calculateAvailability(data.uptime, data.downtime),
      oee: this.calculateOEE(data.availability, data.performance, data.quality)
    };
  }

  calculateMTBF(failures, operatingHours) {
    if (!failures || failures === 0) return 0;
    return (operatingHours / failures).toFixed(2);
  }

  calculateMTTR(repairTimes) {
    if (!repairTimes || repairTimes.length === 0) return 0;
    const total = repairTimes.reduce((sum, time) => sum + time, 0);
    return (total / repairTimes.length).toFixed(2);
  }

  calculateAvailability(uptime, downtime) {
    const total = uptime + downtime;
    if (total === 0) return 0;
    return ((uptime / total) * 100).toFixed(2);
  }

  calculateOEE(availability, performance, quality) {
    return ((availability * performance * quality) / 10000).toFixed(2);
  }

  getPerformanceLevel(value, type) {
    const levels = {
      availability: { low: 85, medium: 95 },
      mtbf: { low: 24, medium: 72 },
      mttr: { low: 4, medium: 2 },
      oee: { low: 65, medium: 85 }
    };

    const thresholds = levels[type];
    if (!thresholds) return 'unknown';

    const numValue = parseFloat(value);
    if (numValue < thresholds.low) return 'critical';
    if (numValue < thresholds.medium) return 'warning';
    return 'good';
  }

  getPriorityLevel(metrics) {
    const scores = {
      age: this.getAgeScore(metrics.age),
      failures: this.getFailureScore(metrics.failureCount),
      cost: this.getCostScore(metrics.maintenanceCost),
      criticality: this.getCriticalityScore(metrics.criticalityLevel)
    };

    const totalScore = Object.values(scores).reduce((sum, score) => sum + score, 0);
    return this.getPriorityFromScore(totalScore);
  }

  getAgeScore(monthsOld) {
    if (monthsOld > 60) return 3;
    if (monthsOld > 36) return 2;
    return 1;
  }

  getFailureScore(failures) {
    if (failures > 5) return 3;
    if (failures > 2) return 2;
    return 1;
  }

  getCostScore(cost) {
    if (cost > 10000) return 3;
    if (cost > 5000) return 2;
    return 1;
  }

  getCriticalityScore(level) {
    const scores = { high: 3, medium: 2, low: 1 };
    return scores[level] || 1;
  }

  getPriorityFromScore(score) {
    if (score >= 10) return 'critical';
    if (score >= 7) return 'high';
    if (score >= 5) return 'medium';
    return 'low';
  }
}

export default new DashboardService();

================
File: frontend/src/services/i18nService.jsx
================
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

// Importando os arquivos de tradução
const resources = {
  'pt-BR': {
    translation: {
      common: {
        save: 'Salvar',
        cancel: 'Cancelar',
        edit: 'Editar',
        delete: 'Excluir',
        back: 'Voltar',
        add: 'Adicionar',
        search: 'Buscar',
        filter: 'Filtrar',
        yes: 'Sim',
        no: 'Não',
        loading: 'Carregando...',
        noData: 'Nenhum dado encontrado',
        error: 'Erro',
        success: 'Sucesso',
        confirm: 'Confirmar',
      },
      equipment: {
        title: 'Equipamentos',
        new: 'Novo Equipamento',
        edit: 'Editar Equipamento',
        name: 'Nome do Equipamento',
        code: 'Código',
        serialNumber: 'Número de Série',
        department: 'Departamento',
        status: {
          active: 'Ativo',
          maintenance: 'Em Manutenção',
          inactive: 'Inativo'
        },
        maintenanceFrequency: 'Frequência de Manutenção',
        lastMaintenance: 'Última Manutenção',
        description: 'Descrição',
        deleteConfirm: 'Tem certeza que deseja excluir este equipamento?'
      },
      serviceOrder: {
        title: 'Ordens de Serviço',
        new: 'Nova Ordem de Serviço',
        edit: 'Editar Ordem de Serviço',
        description: 'Descrição',
        type: {
          corrective: 'Corretiva',
          preventive: 'Preventiva',
          predictive: 'Preditiva'
        },
        priority: {
          low: 'Baixa',
          medium: 'Média',
          high: 'Alta',
          critical: 'Crítica'
        },
        status: {
          pending: 'Pendente',
          inProgress: 'Em Andamento',
          completed: 'Concluída',
          cancelled: 'Cancelada'
        },
        scheduledFor: 'Data Agendada',
        completedAt: 'Data de Conclusão',
        technician: 'Técnico Responsável',
        cost: 'Custo',
        attachments: 'Anexos',
        deleteConfirm: 'Tem certeza que deseja excluir esta ordem de serviço?'
      },
      users: {
        title: 'Usuários',
        new: 'Novo Usuário',
        edit: 'Editar Usuário',
        name: 'Nome',
        email: 'E-mail',
        role: {
          admin: 'Administrador',
          manager: 'Gerente',
          technician: 'Técnico'
        },
        password: 'Senha',
        confirmPassword: 'Confirmar Senha',
        active: 'Usuário Ativo',
        deleteConfirm: 'Tem certeza que deseja excluir este usuário?'
      },
      dashboard: {
        title: 'Dashboard',
        summary: {
          totalEquipments: 'Total de Equipamentos',
          activeEquipments: 'Equipamentos Ativos',
          maintenanceInProgress: 'Em Manutenção',
          pendingMaintenances: 'Manutenções Pendentes'
        },
        charts: {
          maintenanceByType: 'Manutenções por Tipo',
          maintenanceTrend: 'Tendência de Manutenções',
          departmentStats: 'Estatísticas por Departamento',
          equipmentPerformance: 'Performance de Equipamentos'
        },
        kpis: {
          mtbf: 'Tempo Médio Entre Falhas',
          mttr: 'Tempo Médio de Reparo',
          availability: 'Disponibilidade',
          oee: 'Eficiência Global'
        }
      },
      notifications: {
        success: {
          save: 'Dados salvos com sucesso!',
          delete: 'Item excluído com sucesso!',
          update: 'Dados atualizados com sucesso!'
        },
        error: {
          general: 'Ocorreu um erro. Tente novamente.',
          save: 'Erro ao salvar os dados.',
          delete: 'Erro ao excluir o item.',
          update: 'Erro ao atualizar os dados.',
          invalidForm: 'Por favor, preencha todos os campos obrigatórios.'
        }
      },
      validation: {
        required: 'Campo obrigatório',
        email: 'E-mail inválido',
        minLength: 'Mínimo de {{count}} caracteres',
        maxLength: 'Máximo de {{count}} caracteres',
        passwordMatch: 'As senhas não conferem',
        invalidDate: 'Data inválida'
      }
    }
  },
  'en': {
    translation: {
      // Traduções em inglês aqui...
    }
  }
};

const i18nService = {
  async initialize() {
    await i18n
      .use(initReactI18next)
      .init({
        resources,
        lng: 'pt-BR', // Idioma padrão
        fallbackLng: 'pt-BR',
        interpolation: {
          escapeValue: false
        }
      });

    return i18n;
  },

  changeLanguage(language) {
    return i18n.changeLanguage(language);
  },

  getCurrentLanguage() {
    return i18n.language;
  },

  formatDate(date, format = 'default') {
    const d = new Date(date);
    const options = {
      default: { 
        day: '2-digit', 
        month: '2-digit', 
        year: 'numeric' 
      },
      long: {
        day: '2-digit',
        month: 'long',
        year: 'numeric'
      },
      short: {
        day: '2-digit',
        month: '2-digit'
      },
      datetime: {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      }
    };

    return d.toLocaleDateString(i18n.language, options[format]);
  },

  formatCurrency(value) {
    return new Intl.NumberFormat(i18n.language, {
      style: 'currency',
      currency: i18n.language === 'pt-BR' ? 'BRL' : 'USD'
    }).format(value);
  },

  formatNumber(value, decimals = 0) {
    return new Intl.NumberFormat(i18n.language, {
      minimumFractionDigits: decimals,
      maximumFractionDigits: decimals
    }).format(value);
  },

  formatDuration(minutes) {
    const hours = Math.floor(minutes / 60);
    const remainingMinutes = minutes % 60;

    if (i18n.language === 'pt-BR') {
      return hours > 0 
        ? `${hours}h ${remainingMinutes}min`
        : `${remainingMinutes}min`;
    }

    return hours > 0 
      ? `${hours}h ${remainingMinutes}m`
      : `${remainingMinutes}m`;
  },

  getWeekDays(short = false) {
    const format = new Intl.DateTimeFormat(i18n.language, { weekday: short ? 'short' : 'long' });
    const weekDays = [];
    
    for(let i = 0; i < 7; i++) {
      const date = new Date(2021, 8, i + 5); // Uma semana começando em domingo
      weekDays.push(format.format(date));
    }
    
    return weekDays;
  },

  getMonths(short = false) {
    const format = new Intl.DateTimeFormat(i18n.language, { month: short ? 'short' : 'long' });
    const months = [];
    
    for(let i = 0; i < 12; i++) {
      const date = new Date(2021, i, 1);
      months.push(format.format(date));
    }
    
    return months;
  }
};

export default i18nService;

================
File: frontend/src/services/notificationService.jsx
================
import { toast } from 'react-toastify';

class NotificationService {
  constructor() {
    this.permission = null;
    this.registration = null;
    this.publicVapidKey = process.env.REACT_APP_VAPID_PUBLIC_KEY;
  }

  async init() {
    try {
      // Solicita permissão para notificações Push
      if ('Notification' in window) {
        this.permission = await Notification.requestPermission();
      }

      // Registra o service worker
      if ('serviceWorker' in navigator && 'PushManager' in window) {
        this.registration = await navigator.serviceWorker.register('/service-worker.js');
        
        if (this.permission === 'granted') {
          await this.subscribeToPush();
        }
      }
    } catch (error) {
      console.error('Erro ao inicializar notificações:', error);
    }
  }

  async subscribeToPush() {
    try {
      const subscription = await this.registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: this.urlBase64ToUint8Array(this.publicVapidKey)
      });

      // Envia a subscription para o backend
      await api.post('/notifications/subscribe', subscription);
    } catch (error) {
      console.error('Erro ao se inscrever nas notificações push:', error);
    }
  }

  urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding)
      .replace(/\-/g, '+')
      .replace(/_/g, '/');

    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);

    for (let i = 0; i < rawData.length; ++i) {
      outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
  }

  // Exibe mensagem de sucesso
  showSuccess(message) {
    toast.success(message, {
      position: "top-right",
      autoClose: 5000,
      hideProgressBar: false,
      closeOnClick: true,
      pauseOnHover: true,
      draggable: true
    });
  }

  // Exibe mensagem de erro
  showError(message) {
    toast.error(message, {
      position: "top-right",
      autoClose: 5000,
      hideProgressBar: false,
      closeOnClick: true,
      pauseOnHover: true,
      draggable: true
    });
  }

  // Exibe mensagem de aviso
  showWarning(message) {
    toast.warning(message, {
      position: "top-right",
      autoClose: 5000,
      hideProgressBar: false,
      closeOnClick: true,
      pauseOnHover: true,
      draggable: true
    });
  }

  // Exibe mensagem de informação
  showInfo(message) {
    toast.info(message, {
      position: "top-right",
      autoClose: 5000,
      hideProgressBar: false,
      closeOnClick: true,
      pauseOnHover: true,
      draggable: true
    });
  }
}

export default new NotificationService();

================
File: frontend/src/services/qrcodeService.jsx
================
import QrScanner from 'qr-scanner';

class QRCodeService {
  constructor() {
    this.scanner = null;
    this.stream = null;
  }

  async initializeScanner(videoElement, onDecode, onError) {
    try {
      // Verifica se o navegador suporta a API de mídia
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('Seu navegador não suporta acesso à câmera');
      }

      // Inicializa o scanner
      this.scanner = new QrScanner(
        videoElement,
        result => {
          if (this.validateQRCode(result)) {
            onDecode(result);
          } else {
            onError('QR Code inválido para o sistema');
          }
        },
        {
          highlightScanRegion: true,
          highlightCodeOutline: true,
        }
      );

      // Inicia o scanner
      await this.scanner.start();

      return true;
    } catch (error) {
      console.error('Erro ao inicializar scanner:', error);
      onError(error.message);
      return false;
    }
  }

  stopScanner() {
    if (this.scanner) {
      this.scanner.stop();
      this.scanner.destroy();
      this.scanner = null;
    }
  }

  async switchCamera() {
    if (!this.scanner) return;

    const cameras = await QrScanner.listCameras();
    const currentCamera = this.scanner.currentCamera();
    const nextCamera = cameras.find(camera => camera.id !== currentCamera.id);

    if (nextCamera) {
      await this.scanner.setCamera(nextCamera.id);
    }
  }

  validateQRCode(result) {
    // Verifica se o QR Code contém uma URL válida do sistema
    const baseUrl = process.env.REACT_APP_BASE_URL;
    return result.startsWith(baseUrl);
  }

  async generateQRCode(data) {
    try {
      const response = await api.post('/qrcode/generate', { data });
      return response.data.qrcode;
    } catch (error) {
      console.error('Erro ao gerar QR Code:', error);
      throw new Error('Falha ao gerar QR Code');
    }
  }

  extractEquipmentId(qrCodeData) {
    try {
      const url = new URL(qrCodeData);
      const pathParts = url.pathname.split('/');
      return pathParts[pathParts.length - 1];
    } catch (error) {
      console.error('Erro ao extrair ID do equipamento:', error);
      return null;
    }
  }

  // Retorna as dimensões ideais para o QR Code baseado no tamanho da tela
  getQRCodeDimensions() {
    const width = window.innerWidth;
    if (width < 600) {
      return 200; // Mobile
    } else if (width < 960) {
      return 250; // Tablet
    } else {
      return 300; // Desktop
    }
  }

  // Verifica se o dispositivo tem câmera disponível
  async hasCamera() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      return devices.some(device => device.kind === 'videoinput');
    } catch (error) {
      console.error('Erro ao verificar câmera:', error);
      return false;
    }
  }
}

export default new QRCodeService();

================
File: frontend/src/services/reportService.jsx
================
import api from './api';

class ReportService {
  async generateMaintenanceReport(filters = {}, format = 'pdf') {
    try {
      const response = await api.get(`/reports/maintenance`, {
        params: { ...filters, format },
        responseType: 'blob'
      });

      const fileName = `maintenance-report-${new Date().toISOString().split('T')[0]}.${format}`;
      this.downloadFile(response.data, fileName, format);

      return true;
    } catch (error) {
      console.error('Erro ao gerar relatório de manutenção:', error);
      throw new Error('Não foi possível gerar o relatório');
    }
  }

  async generateEquipmentReport(filters = {}, format = 'pdf') {
    try {
      const response = await api.get(`/reports/equipment`, {
        params: { ...filters, format },
        responseType: 'blob'
      });

      const fileName = `equipment-report-${new Date().toISOString().split('T')[0]}.${format}`;
      this.downloadFile(response.data, fileName, format);

      return true;
    } catch (error) {
      console.error('Erro ao gerar relatório de equipamentos:', error);
      throw new Error('Não foi possível gerar o relatório');
    }
  }

  async generateServiceOrderReport(id, format = 'pdf') {
    try {
      const response = await api.get(`/reports/service-order/${id}`, {
        params: { format },
        responseType: 'blob'
      });

      const fileName = `service-order-${id}.${format}`;
      this.downloadFile(response.data, fileName, format);

      return true;
    } catch (error) {
      console.error('Erro ao gerar relatório da ordem de serviço:', error);
      throw new Error('Não foi possível gerar o relatório');
    }
  }

  async generateDashboardReport(period = 'month', format = 'pdf') {
    try {
      const response = await api.get(`/reports/dashboard`, {
        params: { period, format },
        responseType: 'blob'
      });

      const fileName = `dashboard-report-${period}-${new Date().toISOString().split('T')[0]}.${format}`;
      this.downloadFile(response.data, fileName, format);

      return true;
    } catch (error) {
      console.error('Erro ao gerar relatório do dashboard:', error);
      throw new Error('Não foi possível gerar o relatório');
    }
  }

  async exportEquipmentQRCodes(ids = [], format = 'pdf') {
    try {
      const response = await api.post(`/reports/qrcodes`, 
        { equipment_ids: ids },
        { 
          params: { format },
          responseType: 'blob' 
        }
      );

      const fileName = `equipment-qrcodes.${format}`;
      this.downloadFile(response.data, fileName, format);

      return true;
    } catch (error) {
      console.error('Erro ao exportar QR Codes:', error);
      throw new Error('Não foi possível exportar os QR Codes');
    }
  }

  async downloadFile(data, fileName, format) {
    const blob = new Blob([data], { 
      type: format === 'pdf' 
        ? 'application/pdf' 
        : 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    });
    
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.setAttribute('download', fileName);
    document.body.appendChild(link);
    link.click();
    link.remove();
    window.URL.revokeObjectURL(url);
  }
}

export default new ReportService();

================
File: frontend/src/services/storageService.jsx
================
const STORAGE_PREFIX = '@EquipmentApp:';

export const storage = {
  getItem(key) {
    try {
      const item = localStorage.getItem(`${STORAGE_PREFIX}${key}`);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error('Erro ao ler do storage:', error);
      return null;
    }
  },

  setItem(key, value) {
    try {
      localStorage.setItem(`${STORAGE_PREFIX}${key}`, JSON.stringify(value));
      return true;
    } catch (error) {
      console.error('Erro ao salvar no storage:', error);
      return false;
    }
  },

  removeItem(key) {
    try {
      localStorage.removeItem(`${STORAGE_PREFIX}${key}`);
      return true;
    } catch (error) {
      console.error('Erro ao remover do storage:', error);
      return false;
    }
  },

  clear() {
    try {
      // Remove apenas os itens com o prefix da aplicação
      Object.keys(localStorage)
        .filter(key => key.startsWith(STORAGE_PREFIX))
        .forEach(key => localStorage.removeItem(key));
      return true;
    } catch (error) {
      console.error('Erro ao limpar storage:', error);
      return false;
    }
  },

  // Métodos específicos da aplicação
  getToken() {
    return this.getItem('token');
  },

  setToken(token) {
    return this.setItem('token', token);
  },

  getUser() {
    return this.getItem('user');
  },

  setUser(user) {
    return this.setItem('user', user);
  },

  clearAuth() {
    this.removeItem('token');
    this.removeItem('user');
  }
};

export default storage;

================
File: frontend/src/services/themeService.jsx
================
import { createTheme } from '@mui/material/styles';

class ThemeService {
  constructor() {
    this.defaultTheme = {
      light: this.createLightTheme(),
      dark: this.createDarkTheme()
    };
  }

  createLightTheme() {
    return createTheme({
      palette: {
        mode: 'light',
        primary: {
          main: '#2196F3',
          light: '#64B5F6',
          dark: '#1976D2',
          contrastText: '#fff'
        },
        secondary: {
          main: '#FF9800',
          light: '#FFB74D',
          dark: '#F57C00',
          contrastText: '#fff'
        },
        error: {
          main: '#F44336',
          light: '#E57373',
          dark: '#D32F2F',
          contrastText: '#fff'
        },
        warning: {
          main: '#FFA726',
          light: '#FFB74D',
          dark: '#F57C00',
          contrastText: '#fff'
        },
        info: {
          main: '#29B6F6',
          light: '#4FC3F7',
          dark: '#0288D1',
          contrastText: '#fff'
        },
        success: {
          main: '#66BB6A',
          light: '#81C784',
          dark: '#388E3C',
          contrastText: '#fff'
        },
        background: {
          default: '#F5F5F5',
          paper: '#FFFFFF'
        }
      },
      typography: {
        fontFamily: [
          'Roboto',
          'Arial',
          'sans-serif'
        ].join(','),
        h1: {
          fontSize: '2.5rem',
          fontWeight: 500
        },
        h2: {
          fontSize: '2rem',
          fontWeight: 500
        },
        h3: {
          fontSize: '1.75rem',
          fontWeight: 500
        },
        h4: {
          fontSize: '1.5rem',
          fontWeight: 500
        },
        h5: {
          fontSize: '1.25rem',
          fontWeight: 500
        },
        h6: {
          fontSize: '1rem',
          fontWeight: 500
        }
      },
      shape: {
        borderRadius: 8
      },
      components: {
        MuiButton: {
          styleOverrides: {
            root: {
              textTransform: 'none',
              fontWeight: 500
            }
          }
        },
        MuiCard: {
          styleOverrides: {
            root: {
              boxShadow: '0px 2px 4px rgba(0, 0, 0, 0.05)'
            }
          }
        },
        MuiPaper: {
          styleOverrides: {
            root: {
              backgroundImage: 'none'
            }
          }
        }
      }
    });
  }

  createDarkTheme() {
    return createTheme({
      palette: {
        mode: 'dark',
        primary: {
          main: '#90CAF9',
          light: '#BBDEFB',
          dark: '#42A5F5',
          contrastText: '#000'
        },
        secondary: {
          main: '#FFB74D',
          light: '#FFCC80',
          dark: '#FFA726',
          contrastText: '#000'
        },
        background: {
          default: '#121212',
          paper: '#1E1E1E'
        }
      },
      components: {
        MuiCard: {
          styleOverrides: {
            root: {
              boxShadow: '0px 2px 4px rgba(0, 0, 0, 0.2)'
            }
          }
        }
      }
    });
  }

  getCustomTheme(options = {}) {
    const {
      primaryColor,
      secondaryColor,
      fontFamily,
      borderRadius,
      mode = 'light'
    } = options;

    const baseTheme = mode === 'light' ? this.createLightTheme() : this.createDarkTheme();

    return createTheme({
      ...baseTheme,
      palette: {
        ...baseTheme.palette,
        primary: primaryColor ? {
          main: primaryColor,
          light: this.adjustColor(primaryColor, 20),
          dark: this.adjustColor(primaryColor, -20)
        } : baseTheme.palette.primary,
        secondary: secondaryColor ? {
          main: secondaryColor,
          light: this.adjustColor(secondaryColor, 20),
          dark: this.adjustColor(secondaryColor, -20)
        } : baseTheme.palette.secondary
      },
      typography: fontFamily ? {
        ...baseTheme.typography,
        fontFamily: [
          fontFamily,
          'Roboto',
          'Arial',
          'sans-serif'
        ].join(',')
      } : baseTheme.typography,
      shape: borderRadius ? {
        ...baseTheme.shape,
        borderRadius
      } : baseTheme.shape
    });
  }

  adjustColor(hex, percent) {
    const num = parseInt(hex.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;

    return '#' + (0x1000000 +
      (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
      (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
      (B < 255 ? B < 1 ? 0 : B : 255)
    ).toString(16).slice(1);
  }

  getContrastText(backgroundColor) {
    const hex = backgroundColor.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
    return yiq >= 128 ? '#000000' : '#FFFFFF';
  }

  getCustomStyles(overrides = {}) {
    return {
      globalStyles: {
        '.page-container': {
          padding: '24px',
          maxWidth: '1200px',
          margin: '0 auto'
        },
        '.card-hover': {
          transition: 'transform 0.2s, box-shadow 0.2s',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: '0 4px 20px rgba(0, 0, 0, 0.1)'
          }
        },
        '.truncate': {
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          whiteSpace: 'nowrap'
        },
        ...overrides
      },
      components: {
        dashboardCard: {
          padding: '20px',
          borderRadius: '10px',
          boxShadow: '0 2px 10px rgba(0, 0, 0, 0.05)',
          backgroundColor: '#ffffff',
          height: '100%'
        },
        dataTable: {
          root: {
            boxShadow: 'none',
            border: '1px solid rgba(224, 224, 224, 1)'
          },
          head: {
            backgroundColor: '#f5f5f5'
          }
        },
        form: {
          container: {
            maxWidth: '800px',
            margin: '0 auto'
          },
          section: {
            marginBottom: '32px'
          }
        }
      }
    };
  }

  getStatusColors() {
    return {
      active: '#4CAF50',
      inactive: '#9E9E9E',
      maintenance: '#FFA726',
      warning: '#FF9800',
      error: '#F44336',
      success: '#4CAF50',
      info: '#2196F3'
    };
  }

  getPriorityColors() {
    return {
      low: '#66BB6A',
      medium: '#FFA726',
      high: '#F44336',
      critical: '#D32F2F'
    };
  }

  getMaintenanceTypeColors() {
    return {
      preventive: '#4CAF50',
      corrective: '#FF9800',
      predictive: '#2196F3'
    };
  }

  getChartColors() {
    return {
      primary: ['#2196F3', '#64B5F6', '#90CAF9', '#BBDEFB'],
      secondary: ['#FF9800', '#FFB74D', '#FFCC80', '#FFE0B2'],
      success: ['#4CAF50', '#81C784', '#A5D6A7', '#C8E6C9'],
      error: ['#F44336', '#E57373', '#EF9A9A', '#FFCDD2']
    };
  }

  getAccessibilityStyles(isHighContrast = false) {
    return {
      typography: {
        fontSize: isHighContrast ? 16 : 14,
        fontWeight: isHighContrast ? 500 : 400
      },
      components: {
        MuiButton: {
          styleOverrides: {
            root: {
              padding: isHighContrast ? '12px 24px' : '8px 16px',
              fontSize: isHighContrast ? '1.1rem' : '1rem'
            }
          }
        },
        MuiInputLabel: {
          styleOverrides: {
            root: {
              fontSize: isHighContrast ? '1.1rem' : '1rem'
            }
          }
        }
      }
    };
  }

  generateCustomPalette(baseColor) {
    const colors = [];
    for (let i = 900; i >= 50; i -= 100) {
      colors.push(this.adjustColor(baseColor, (i - 500) / 10));
    }
    return {
      50: colors[8],
      100: colors[7],
      200: colors[6],
      300: colors[5],
      400: colors[4],
      500: colors[3], // Base color
      600: colors[2],
      700: colors[1],
      800: colors[0],
      900: this.adjustColor(colors[0], -10)
    };
  }

  applyThemeToElements() {
    document.documentElement.style.setProperty('--primary-color', this.defaultTheme.light.palette.primary.main);
    document.documentElement.style.setProperty('--secondary-color', this.defaultTheme.light.palette.secondary.main);
    document.documentElement.style.setProperty('--background-color', this.defaultTheme.light.palette.background.default);
    document.documentElement.style.setProperty('--text-color', this.defaultTheme.light.palette.text.primary);
  }
}

export default new ThemeService();

================
File: frontend/src/services/uploadService.jsx
================
import api from './api';

class UploadService {
  async uploadFile(file, onProgress) {
    try {
      const formData = new FormData();
      formData.append('file', file);

      const response = await api.post('/files', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: (progressEvent) => {
          if (onProgress) {
            const percentCompleted = Math.round(
              (progressEvent.loaded * 100) / progressEvent.total
            );
            onProgress(percentCompleted);
          }
        }
      });

      return response.data;
    } catch (error) {
      console.error('Erro no upload do arquivo:', error);
      throw new Error('Falha no upload do arquivo');
    }
  }

  async uploadMultipleFiles(files, onProgress) {
    try {
      const formData = new FormData();
      files.forEach((file, index) => {
        formData.append(`files[${index}]`, file);
      });

      const response = await api.post('/files/batch', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: (progressEvent) => {
          if (onProgress) {
            const percentCompleted = Math.round(
              (progressEvent.loaded * 100) / progressEvent.total
            );
            onProgress(percentCompleted);
          }
        }
      });

      return response.data;
    } catch (error) {
      console.error('Erro no upload dos arquivos:', error);
      throw new Error('Falha no upload dos arquivos');
    }
  }

  async deleteFile(fileId) {
    try {
      await api.delete(`/files/${fileId}`);
      return true;
    } catch (error) {
      console.error('Erro ao excluir arquivo:', error);
      throw new Error('Falha ao excluir arquivo');
    }
  }

  getFileUrl(fileId) {
    return `${api.defaults.baseURL}/files/${fileId}`;
  }

  validateFileSize(file, maxSizeMB = 5) {
    const maxSize = maxSizeMB * 1024 * 1024; // Converter para bytes
    return file.size <= maxSize;
  }

  validateFileType(file, allowedTypes = []) {
    if (allowedTypes.length === 0) return true;
    return allowedTypes.includes(file.type);
  }

  getFileTypeIcon(mimeType) {
    // Retorna o nome do ícone baseado no tipo do arquivo
    if (mimeType.startsWith('image/')) {
      return 'image';
    } else if (mimeType === 'application/pdf') {
      return 'pdf';
    } else if (mimeType.includes('spreadsheet') || mimeType.includes('excel')) {
      return 'excel';
    } else if (mimeType.includes('word')) {
      return 'word';
    } else if (mimeType.includes('presentation') || mimeType.includes('powerpoint')) {
      return 'powerpoint';
    } else {
      return 'file';
    }
  }
}

export default new UploadService();

================
File: frontend/src/services/validationService.jsx
================
import * as yup from 'yup';

class ValidationService {
  constructor() {
    this.setCustomValidations();
  }

  setCustomValidations() {
    yup.addMethod(yup.string, 'cnpj', function () {
      return this.test('cnpj', 'CNPJ inválido', value => {
        if (!value) return true;
        return this.validateCNPJ(value);
      });
    });

    yup.addMethod(yup.string, 'phone', function () {
      return this.test('phone', 'Telefone inválido', value => {
        if (!value) return true;
        return this.validatePhone(value);
      });
    });
  }

  getEquipmentSchema() {
    return yup.object().shape({
      name: yup.string()
        .required('Nome é obrigatório')
        .min(3, 'Nome deve ter no mínimo 3 caracteres'),
      code: yup.string()
        .required('Código é obrigatório')
        .matches(/^[A-Za-z0-9-]+$/, 'Código deve conter apenas letras, números e hífen'),
      serial_number: yup.string(),
      department: yup.string()
        .required('Departamento é obrigatório'),
      description: yup.string()
        .max(500, 'Descrição deve ter no máximo 500 caracteres'),
      maintenance_frequency: yup.number()
        .required('Frequência de manutenção é obrigatória')
        .min(1, 'Frequência deve ser maior que 0'),
      status: yup.string()
        .oneOf(['active', 'maintenance', 'inactive'], 'Status inválido')
        .required('Status é obrigatório')
    });
  }

  getServiceOrderSchema() {
    return yup.object().shape({
      equipment_id: yup.number()
        .required('Equipamento é obrigatório'),
      description: yup.string()
        .required('Descrição é obrigatória')
        .min(10, 'Descrição deve ter no mínimo 10 caracteres'),
      type: yup.string()
        .oneOf(['corrective', 'preventive', 'predictive'], 'Tipo inválido')
        .required('Tipo é obrigatório'),
      priority: yup.string()
        .oneOf(['low', 'medium', 'high', 'critical'], 'Prioridade inválida')
        .required('Prioridade é obrigatória'),
      scheduled_for: yup.date()
        .required('Data agendada é obrigatória')
        .min(new Date(), 'Data deve ser futura'),
      notes: yup.string()
        .max(1000, 'Observações devem ter no máximo 1000 caracteres'),
      cost: yup.number()
        .min(0, 'Custo não pode ser negativo'),
      parts_replaced: yup.array().of(
        yup.object().shape({
          name: yup.string().required('Nome da peça é obrigatório'),
          quantity: yup.number()
            .required('Quantidade é obrigatória')
            .min(1, 'Quantidade deve ser maior que 0'),
          cost: yup.number()
            .min(0, 'Custo não pode ser negativo')
        })
      )
    });
  }

  getUserSchema(isEditing = false) {
    return yup.object().shape({
      name: yup.string()
        .required('Nome é obrigatório')
        .min(3, 'Nome deve ter no mínimo 3 caracteres'),
      email: yup.string()
        .required('Email é obrigatório')
        .email('Email inválido'),
      password: yup.string()
        .when('$isEditing', {
          is: false,
          then: yup.string()
            .required('Senha é obrigatória')
            .min(6, 'Senha deve ter no mínimo 6 caracteres')
        }),
      passwordConfirmation: yup.string()
        .when('password', {
          is: val => val && val.length > 0,
          then: yup.string()
            .oneOf([yup.ref('password')], 'Senhas não conferem')
            .required('Confirmação de senha é obrigatória')
        }),
      role: yup.string()
        .oneOf(['admin', 'manager', 'technician'], 'Função inválida')
        .required('Função é obrigatória')
    }).context({ isEditing });
  }

  getSettingsSchema() {
    return yup.object().shape({
      notifications: yup.object().shape({
        email: yup.boolean(),
        push: yup.boolean(),
        maintenanceReminder: yup.boolean(),
        maintenanceOverdue: yup.boolean(),
        equipmentStatusChange: yup.boolean()
      }),
      maintenance: yup.object().shape({
        defaultFrequency: yup.number()
          .required('Frequência padrão é obrigatória')
          .min(1, 'Frequência deve ser maior que 0'),
        reminderDays: yup.number()
          .required('Dias de lembrete é obrigatório')
          .min(1, 'Deve ter pelo menos 1 dia'),
        criticalAgeMonths: yup.number()
          .required('Idade crítica é obrigatória')
          .min(1, 'Deve ter pelo menos 1 mês')
      }),
      email: yup.object().shape({
        reminderTime: yup.string()
          .matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Horário inválido'),
        dailyReportTime: yup.string()
          .matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Horário inválido'),
        reportRecipients: yup.string()
          .test('emails', 'Email(s) inválido(s)', value => {
            if (!value) return true;
            const emails = value.split('\n');
            return emails.every(email => 
              yup.string().email().isValidSync(email.trim())
            );
          })
      })
    });
  }

  async validateForm(schema, data) {
    try {
      await schema.validate(data, { abortEarly: false });
      return { isValid: true, errors: {} };
    } catch (validationError) {
      const errors = {};
      validationError.inner.forEach(error => {
        errors[error.path] = error.message;
      });
      return { isValid: false, errors };
    }
  }

  validateCNPJ(cnpj) {
    cnpj = cnpj.replace(/[^\d]/g, '');

    if (cnpj.length !== 14) return false;

    if (/^(\d)\1+$/.test(cnpj)) return false;

    let size = cnpj.length - 2;
    let numbers = cnpj.substring(0, size);
    let digits = cnpj.substring(size);
    let sum = 0;
    let pos = size - 7;

    for (let i = size; i >= 1; i--) {
      sum += numbers.charAt(size - i) * pos--;
      if (pos < 2) pos = 9;
    }

    let result = sum % 11 < 2 ? 0 : 11 - (sum % 11);
    if (result !== parseInt(digits.charAt(0))) return false;

    size = size + 1;
    numbers = cnpj.substring(0, size);
    sum = 0;
    pos = size - 7;

    for (let i = size; i >= 1; i--) {
      sum += numbers.charAt(size - i) * pos--;
      if (pos < 2) pos = 9;
    }

    result = sum % 11 < 2 ? 0 : 11 - (sum % 11);
    return result === parseInt(digits.charAt(1));
  }

  validatePhone(phone) {
    phone = phone.replace(/[^\d]/g, '');
    return /^(\d{10,11})$/.test(phone);
  }

  formatErrorMessage(error) {
    if (error.inner) {
      return error.inner.map(err => err.message).join(', ');
    }
    return error.message;
  }
}

export default new ValidationService();

================
File: frontend/src/services/websocketService.js
================
import { toast } from '@/components/ui/use-toast';

class WebSocketService {
  constructor() {
    this.ws = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    this.reconnectTimeout = null;
    this.messageHandlers = new Map();
    this.connectionPromise = null;
    this.isConnecting = false;
  }

  async connect() {
    if (this.ws?.readyState === WebSocket.OPEN) return;
    if (this.isConnecting) return this.connectionPromise;

    this.isConnecting = true;
    this.connectionPromise = new Promise((resolve, reject) => {
      try {
        const token = localStorage.getItem('@EquipmentManagement:token');
        if (!token) {
          throw new Error('Token não encontrado');
        }

        const wsUrl = `${import.meta.env.VITE_WS_URL}?token=${token}`;
        this.ws = new WebSocket(wsUrl);

        this.ws.onopen = () => {
          this.reconnectAttempts = 0;
          this.isConnecting = false;
          resolve();

          // Enviar ping a cada 30 segundos para manter a conexão
          this.pingInterval = setInterval(() => {
            if (this.ws?.readyState === WebSocket.OPEN) {
              this.ws.send(JSON.stringify({ type: 'ping' }));
            }
          }, 30000);
        };

        this.ws.onclose = () => {
          this.handleDisconnect();
        };

        this.ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          this.handleDisconnect();
        };

        this.ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            this.handleMessage(data);
          } catch (error) {
            console.error('Error parsing WebSocket message:', error);
          }
        };
      } catch (error) {
        this.isConnecting = false;
        reject(error);
      }
    });

    return this.connectionPromise;
  }

  handleDisconnect() {
    this.isConnecting = false;
    clearInterval(this.pingInterval);

    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      const timeout = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 10000);
      this.reconnectTimeout = setTimeout(() => {
        this.reconnectAttempts++;
        this.connect();
      }, timeout);
    } else {
      toast({
        variant: "destructive",
        title: "Erro de conexão",
        description: "Não foi possível reconectar ao servidor"
      });
    }
  }

  handleMessage(message) {
    const { type, data } = message;

    // Resposta do ping
    if (type === 'pong') return;

    // Notificações do sistema
    if (type === 'NOTIFICATION') {
      toast({
        title: data.title,
        description: data.message,
        variant: data.priority === 'high' ? 'destructive' : 'default'
      });
    }

    // Executar handlers registrados para o tipo de mensagem
    const handlers = this.messageHandlers.get(type) || [];
    handlers.forEach(handler => handler(data));
  }

  subscribe(type, handler) {
    if (!this.messageHandlers.has(type)) {
      this.messageHandlers.set(type, []);
    }
    this.messageHandlers.get(type).push(handler);

    // Retorna uma função para cancelar a inscrição
    return () => {
      const handlers = this.messageHandlers.get(type);
      const index = handlers.indexOf(handler);
      if (index > -1) {
        handlers.splice(index, 1);
      }
    };
  }

  send(type, data) {
    if (this.ws?.readyState !== WebSocket.OPEN) {
      throw new Error('WebSocket não está conectado');
    }

    this.ws.send(JSON.stringify({ type, data }));
  }

  async joinRoom(roomId) {
    await this.connect();
    this.send('JOIN_ROOM', { roomId });
  }

  async leaveRoom(roomId) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.send('LEAVE_ROOM', { roomId });
    }
  }

  disconnect() {
    clearTimeout(this.reconnectTimeout);
    clearInterval(this.pingInterval);
    
    if (this.ws) {
      this.ws.onclose = null; // Prevenir tentativa de reconexão
      this.ws.close();
      this.ws = null;
    }

    this.messageHandlers.clear();
    this.isConnecting = false;
    this.reconnectAttempts = 0;
  }
}

export const wsService = new WebSocketService();

// Hooks para usar o WebSocket em componentes React
export const useWebSocket = (type, handler) => {
  React.useEffect(() => {
    wsService.connect();
    const unsubscribe = wsService.subscribe(type, handler);
    return () => unsubscribe();
  }, [type, handler]);
};

export const useEquipmentUpdates = (equipmentId, handler) => {
  React.useEffect(() => {
    const roomId = `equipment_${equipmentId}`;
    wsService.joinRoom(roomId);
    const unsubscribe = wsService.subscribe('EQUIPMENT_UPDATED', handler);
    
    return () => {
      unsubscribe();
      wsService.leaveRoom(roomId);
    };
  }, [equipmentId, handler]);
};

export default wsService;

================
File: frontend/src/utils/formatters.jsx
================
export const formatCurrency = (value) => {
    return new Intl.NumberFormat('pt-BR', {
      style: 'currency',
      currency: 'BRL'
    }).format(value);
  };
  
  export const formatDate = (date) => {
    if (!date) return '';
    return new Date(date).toLocaleDateString('pt-BR');
  };
  
  export const formatDateTime = (date) => {
    if (!date) return '';
    return new Date(date).toLocaleString('pt-BR');
  };
  
  export const formatStatus = (status) => {
    const statusMap = {
      active: 'Ativo',
      inactive: 'Inativo',
      maintenance: 'Em Manutenção',
      pending: 'Pendente',
      completed: 'Concluído',
      in_progress: 'Em Andamento'
    };
    return statusMap[status] || status;
  };
  
  export const formatMaintenanceType = (type) => {
    const typeMap = {
      corrective: 'Corretiva',
      preventive: 'Preventiva',
      predictive: 'Preditiva'
    };
    return typeMap[type] || type;
  };

================
File: frontend/src/App.jsx
================
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import Layout from './components/Layout/Layout';
import Login from './pages/Login/Login';
import Dashboard from './pages/Dashboard/Dashboard';
import EquipmentList from './pages/Equipment/EquipmentList';
import EquipmentForm from './pages/Equipment/EquipmentForm';
import EquipmentQRCode from './pages/Equipment/EquipmentQRCode';
import MaintenanceList from './pages/Maintenance/MaintenanceList';
import MaintenanceForm from './pages/Maintenance/MaintenanceForm';
import Profile from './pages/Profile/Profile';

function App() {
  return (
    <Router>
      <AuthProvider>
        <Routes>
          <Route path="/login" element={<Login />} />
          <Route path="/" element={<Layout />}>
            <Route path="/" element={<Dashboard />} />
            <Route path="/equipment" element={<EquipmentList />} />
            <Route path="/equipment/new" element={<EquipmentForm />} />
            <Route path="/equipment/:id/edit" element={<EquipmentForm />} />
            <Route path="/equipment/:id/qrcode" element={<EquipmentQRCode />} />
            <Route path="/maintenance" element={<MaintenanceList />} />
            <Route path="/maintenance/new" element={<MaintenanceForm />} />
            <Route path="/maintenance/:id/edit" element={<MaintenanceForm />} />
            <Route path="/profile" element={<Profile />} />
          </Route>
        </Routes>
      </AuthProvider>
    </Router>
  );
}

export default App;

================
File: frontend/src/main.jsx
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
    <ToastContainer
      position="top-right"
      autoClose={5000}
      hideProgressBar={false}
      newestOnTop={false}
      closeOnClick
      rtl={false}
      pauseOnFocusLoss
      draggable
      pauseOnHover
    />
  </React.StrictMode>
);

================
File: frontend/.env
================
VITE_API_URL=http://localhost:3000/api
VITE_WS_URL=ws://localhost:3000

================
File: frontend/componentes.sh
================
#!/bin/bash

# Instalar dependências base do shadcn/ui
npm install @shadcn/ui class-variance-authority clsx tailwind-merge lucide-react

# Instalar componentes necessários
npx shadcn@latest add alert
npx shadcn@latest add button
npx shadcn@latest add card
npx shadcn@latest add form
npx shadcn@latest add input
npx shadcn@latest add label
npx shadcn@latest add select
npx shadcn@latest add badge
npx shadcn@latest add table
npx shadcn@latest add avatar
npx shadcn@latest add dialog
npx shadcn@latest add dropdown-menu
npx shadcn@latest add toast
npx shadcn@latest add tabs
npx shadcn@latest add calendar
npx shadcn@latest add separator
npx shadcn@latest add sheet
npx shadcn@latest add skeleton
npx shadcn@latest add scroll-area
npx shadcn@latest add popover

# Instalar dependências adicionais necessárias
npm install @hookform/resolvers date-fns react-hook-form zod

================
File: frontend/package.json
================
{
  "name": "equipment-management-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "lint": "eslint src/**/*.{js,jsx}",
    "lint:fix": "eslint src/**/*.{js,jsx} --fix",
    "setup-ui": "sh componentes.sh"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.3.2",
    "@radix-ui/react-alert-dialog": "^1.0.5",
    "@radix-ui/react-avatar": "^1.0.4",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-separator": "^1.0.3",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-toast": "^1.1.5",
    "@tanstack/react-table": "^8.10.7",
    "axios": "^1.6.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.0.0",
    "cmdk": "^0.2.0",
    "date-fns": "^2.30.0",
    "lucide-react": "^0.294.0",
    "react": "^18.2.0",
    "react-day-picker": "^8.9.1",
    "react-dom": "^18.2.0",
    "react-hook-form": "^7.49.2",
    "react-router-dom": "^6.20.1",
    "recharts": "^2.10.3",
    "socket.io-client": "^4.7.2",
    "tailwind-merge": "^2.1.0",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.22.4",
    "@emotion/react": "^11.11.1",
    "@emotion/styled": "^11.11.0",
    "@mui/icons-material": "^5.14.19",
    "@mui/lab": "^5.0.0-alpha.155",
    "@mui/material": "^5.14.20",
    "react-signature-canvas": "^1.0.6",
    "react-toastify": "^9.1.3"
  },
  "devDependencies": {
    "@types/node": "^20.10.4",
    "@types/react": "^18.2.42",
    "@types/react-dom": "^18.2.17",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-plugin-react": "^7.33.2",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "vite": "^5.0.7"
  }
}

================
File: frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
    darkMode: ["class"],
    content: [
      './pages/**/*.{js,jsx}',
      './components/**/*.{js,jsx}',
      './app/**/*.{js,jsx}',
      './src/**/*.{js,jsx}',
    ],
    prefix: "",
    theme: {
      container: {
        center: true,
        padding: "2rem",
        screens: {
          "2xl": "1400px",
        },
      },
      extend: {
        colors: {
          border: "hsl(var(--border))",
          input: "hsl(var(--input))",
          ring: "hsl(var(--ring))",
          background: "hsl(var(--background))",
          foreground: "hsl(var(--foreground))",
          primary: {
            DEFAULT: "hsl(var(--primary))",
            foreground: "hsl(var(--primary-foreground))",
          },
          secondary: {
            DEFAULT: "hsl(var(--secondary))",
            foreground: "hsl(var(--secondary-foreground))",
          },
          destructive: {
            DEFAULT: "hsl(var(--destructive))",
            foreground: "hsl(var(--destructive-foreground))",
          },
          muted: {
            DEFAULT: "hsl(var(--muted))",
            foreground: "hsl(var(--muted-foreground))",
          },
          accent: {
            DEFAULT: "hsl(var(--accent))",
            foreground: "hsl(var(--accent-foreground))",
          },
          popover: {
            DEFAULT: "hsl(var(--popover))",
            foreground: "hsl(var(--popover-foreground))",
          },
          card: {
            DEFAULT: "hsl(var(--card))",
            foreground: "hsl(var(--card-foreground))",
          },
        },
        borderRadius: {
          lg: "var(--radius)",
          md: "calc(var(--radius) - 2px)",
          sm: "calc(var(--radius) - 4px)",
        },
        keyframes: {
          "accordion-down": {
            from: { height: "0" },
            to: { height: "var(--radix-accordion-content-height)" },
          },
          "accordion-up": {
            from: { height: "var(--radix-accordion-content-height)" },
            to: { height: "0" },
          },
        },
        animation: {
          "accordion-down": "accordion-down 0.2s ease-out",
          "accordion-up": "accordion-up 0.2s ease-out",
        },
      },
    },
    plugins: [require("tailwindcss-animate")],
  }

================
File: frontend/vite.config.js
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
})

================
File: mobile/DashboardScreen.jsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  RefreshControl,
  ActivityIndicator
} from 'react-native';
import { LineChart, BarChart, PieChart } from 'react-native-chart-kit';
import { Dimensions } from 'react-native';
import Icon from '@expo/vector-icons/MaterialCommunityIcons';

const screenWidth = Dimensions.get('window').width;

const DashboardScreen = () => {
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [stats, setStats] = useState({
    maintenancesByType: {
      preventive: 0,
      corrective: 0,
      predictive: 0
    },
    maintenancesByStatus: {
      pending: 0,
      in_progress: 0,
      completed: 0
    },
    monthlyStats: [],
    equipmentStats: []
  });

  const fetchDashboardData = async () => {
    try {
      const response = await fetch(`${process.env.API_URL}/dashboard/stats`);
      const data = await response.json();
      setStats(data);
    } catch (error) {
      console.error('Erro ao carregar estatísticas:', error);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const onRefresh = React.useCallback(() => {
    setRefreshing(true);
    fetchDashboardData();
  }, []);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#2196F3" />
      </View>
    );
  }

  return (
    <ScrollView 
      style={styles.container}
      refreshControl={
        <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
      }
    >
      {/* Cards de Resumo */}
      <View style={styles.summaryContainer}>
        <View style={styles.summaryCard}>
          <Icon name="wrench" size={30} color="#2196F3" />
          <Text style={styles.summaryNumber}>
            {stats.maintenancesByStatus.pending}
          </Text>
          <Text style={styles.summaryText}>Pendentes</Text>
        </View>

        <View style={styles.summaryCard}>
          <Icon name="progress-wrench" size={30} color="#FFA000" />
          <Text style={styles.summaryNumber}>
            {stats.maintenancesByStatus.in_progress}
          </Text>
          <Text style={styles.summaryText}>Em Andamento</Text>
        </View>

        <View style={styles.summaryCard}>
          <Icon name="check-circle" size={30} color="#4CAF50" />
          <Text style={styles.summaryNumber}>
            {stats.maintenancesByStatus.completed}
          </Text>
          <Text style={styles.summaryText}>Concluídas</Text>
        </View>
      </View>

      {/* Gráfico de Linha - Manutenções por Mês */}
      <View style={styles.chartContainer}>
        <Text style={styles.chartTitle}>Manutenções por Mês</Text>
        <LineChart
          data={{
            labels: stats.monthlyStats.map(item => item.month),
            datasets: [{
              data: stats.monthlyStats.map(item => item.count)
            }]
          }}
          width={screenWidth - 40}
          height={220}
          chartConfig={{
            backgroundColor: '#ffffff',
            backgroundGradientFrom: '#ffffff',
            backgroundGradientTo: '#ffffff',
            decimalPlaces: 0,
            color: (opacity = 1) => `rgba(33, 150, 243, ${opacity})`,
            style: {
              borderRadius: 16
            }
          }}
          bezier
          style={styles.chart}
        />
      </View>

      {/* Gráfico de Pizza - Tipos de Manutenção */}
      <View style={styles.chartContainer}>
        <Text style={styles.chartTitle}>Tipos de Manutenção</Text>
        <PieChart
          data={[
            {
              name: 'Preventiva',
              count: stats.maintenancesByType.preventive,
              color: '#4CAF50',
              legendFontColor: '#7F7F7F',
            },
            {
              name: 'Corretiva',
              count: stats.maintenancesByType.corrective,
              color: '#FFA000',
              legendFontColor: '#7F7F7F',
            },
            {
              name: 'Preditiva',
              count: stats.maintenancesByType.predictive,
              color: '#2196F3',
              legendFontColor: '#7F7F7F',
            }
          ]}
          width={screenWidth - 40}
          height={220}
          chartConfig={{
            color: (opacity = 1) => `rgba(0, 0, 0, ${opacity})`
          }}
          accessor="count"
          backgroundColor="transparent"
          paddingLeft="15"
          style={styles.chart}
        />
      </View>

      {/* Gráfico de Barras - Equipamentos mais Manutenidos */}
      <View style={styles.chartContainer}>
        <Text style={styles.chartTitle}>Equipamentos Mais Manutenidos</Text>
        <BarChart
          data={{
            labels: stats.equipmentStats.map(item => item.name),
            datasets: [{
              data: stats.equipmentStats.map(item => item.maintenance_count)
            }]
          }}
          width={screenWidth - 40}
          height={220}
          chartConfig={{
            backgroundColor: '#ffffff',
            backgroundGradientFrom: '#ffffff',
            backgroundGradientTo: '#ffffff',
            decimalPlaces: 0,
            color: (opacity = 1) => `rgba(33, 150, 243, ${opacity})`,
            barPercentage: 0.5,
          }}
          style={styles.chart}
          showValuesOnTopOfBars
        />
      </View>

      {/* Indicadores de Desempenho */}
      <View style={styles.kpiContainer}>
        <View style={styles.kpiCard}>
          <Text style={styles.kpiTitle}>Tempo Médio de Resolução</Text>
          <Text style={styles.kpiValue}>
            {stats.averageResolutionTime} horas
          </Text>
        </View>

        <View style={styles.kpiCard}>
          <Text style={styles.kpiTitle}>Taxa de Conclusão</Text>
          <Text style={styles.kpiValue}>
            {stats.completionRate}%
          </Text>
        </View>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  summaryContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 20,
  },
  summaryCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 15,
    alignItems: 'center',
    width: '30%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  summaryNumber: {
    fontSize: 24,
    fontWeight: 'bold',
    marginTop: 8,
  },
  summaryText: {
    fontSize: 12,
    color: '#666',
    marginTop: 4,
  },
  chartContainer: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    margin: 20,
    padding: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  chartTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 15,
    color: '#333',
  },
  chart: {
    borderRadius: 12,
    marginVertical: 8,
  },
  kpiContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 20,
  },
  kpiCard: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 15,
    width: '48%',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  kpiTitle: {
    fontSize: 14,
    color: '#666',
    marginBottom: 8,
  },
  kpiValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#2196F3',
  },
});

export default DashboardScreen;

================
File: mobile/MainScreen.jsx
================
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  Platform,
  Alert
} from 'react-native';
import { BarCodeScanner } from 'expo-barcode-scanner';
import { Camera } from 'expo-camera';
import { useNavigation } from '@react-navigation/native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import Icon from '@expo/vector-icons/MaterialCommunityIcons';

const MainScreen = () => {
  const [hasPermission, setHasPermission] = useState(null);
  const [scanned, setScanned] = useState(false);
  const [isCameraVisible, setIsCameraVisible] = useState(false);
  const [recentEquipments, setRecentEquipments] = useState([]);
  const navigation = useNavigation();

  useEffect(() => {
    requestPermissions();
    loadRecentEquipments();
  }, []);

  const requestPermissions = async () => {
    const { status } = await Camera.requestCameraPermissionsAsync();
    setHasPermission(status === 'granted');
  };

  const loadRecentEquipments = async () => {
    try {
      const recent = await AsyncStorage.getItem('recentEquipments');
      if (recent) {
        setRecentEquipments(JSON.parse(recent));
      }
    } catch (error) {
      console.error('Erro ao carregar equipamentos recentes:', error);
    }
  };

  const handleBarCodeScanned = async ({ data }) => {
    setScanned(true);
    setIsCameraVisible(false);

    try {
      // Verifica se o QR Code é válido para o sistema
      if (!data.startsWith(process.env.APP_URL)) {
        Alert.alert('Erro', 'QR Code inválido');
        return;
      }

      const equipmentId = data.split('/').pop();
      const response = await fetch(`${process.env.API_URL}/equipment/${equipmentId}`);
      
      if (!response.ok) {
        throw new Error('Equipamento não encontrado');
      }

      const equipment = await response.json();

      // Salva nos equipamentos recentes
      const updatedRecent = [equipment, ...recentEquipments.filter(eq => eq.id !== equipment.id)].slice(0, 5);
      await AsyncStorage.setItem('recentEquipments', JSON.stringify(updatedRecent));
      setRecentEquipments(updatedRecent);

      // Navega para a tela de manutenção
      navigation.navigate('MaintenanceForm', { equipment });

    } catch (error) {
      Alert.alert('Erro', error.message);
    }
  };

  if (hasPermission === null) {
    return <View style={styles.container}><Text>Solicitando permissão da câmera...</Text></View>;
  }

  if (hasPermission === false) {
    return <View style={styles.container}><Text>Sem acesso à câmera</Text></View>;
  }

  return (
    <View style={styles.container}>
      {isCameraVisible ? (
        <View style={styles.cameraContainer}>
          <BarCodeScanner
            onBarCodeScanned={scanned ? undefined : handleBarCodeScanned}
            style={styles.camera}
          />
          <TouchableOpacity 
            style={styles.closeButton}
            onPress={() => setIsCameraVisible(false)}
          >
            <Icon name="close" size={30} color="#FFF" />
          </TouchableOpacity>
        </View>
      ) : (
        <View style={styles.content}>
          <TouchableOpacity 
            style={styles.scanButton}
            onPress={() => {
              setScanned(false);
              setIsCameraVisible(true);
            }}
          >
            <Icon name="qrcode-scan" size={40} color="#FFF" />
            <Text style={styles.scanButtonText}>Escanear QR Code</Text>
          </TouchableOpacity>

          <View style={styles.recentContainer}>
            <Text style={styles.recentTitle}>Equipamentos Recentes</Text>
            {recentEquipments.map(equipment => (
              <TouchableOpacity
                key={equipment.id}
                style={styles.recentItem}
                onPress={() => navigation.navigate('MaintenanceForm', { equipment })}
              >
                <Icon name="wrench" size={24} color="#666" />
                <View style={styles.recentInfo}>
                  <Text style={styles.recentName}>{equipment.name}</Text>
                  <Text style={styles.recentCode}>Código: {equipment.code}</Text>
                </View>
                <Icon name="chevron-right" size={24} color="#666" />
              </TouchableOpacity>
            ))}
          </View>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    flex: 1,
    padding: 20,
  },
  cameraContainer: {
    flex: 1,
    position: 'relative',
  },
  camera: {
    flex: 1,
  },
  closeButton: {
    position: 'absolute',
    top: 40,
    right: 20,
    padding: 10,
    backgroundColor: 'rgba(0,0,0,0.5)',
    borderRadius: 25,
  },
  scanButton: {
    backgroundColor: '#2196F3',
    padding: 20,
    borderRadius: 10,
    alignItems: 'center',
    marginVertical: 20,
    elevation: 3,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
  },
  scanButtonText: {
    color: '#FFF',
    fontSize: 18,
    marginTop: 10,
    fontWeight: '500',
  },
  recentContainer: {
    backgroundColor: '#FFF',
    borderRadius: 10,
    padding: 15,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.22,
    shadowRadius: 2.22,
  },
  recentTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    color: '#333',
  },
  recentItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  recentInfo: {
    flex: 1,
    marginLeft: 15,
  },
  recentName: {
    fontSize: 16,
    fontWeight: '500',
    color: '#333',
  },
  recentCode: {
    fontSize: 14,
    color: '#666',
    marginTop: 2,
  },
});

export default MainScreen;

================
File: mobile/MaintenanceForm.jsx
================
import React, { useState, useRef } from 'react';
import {
  View,
  Text,
  ScrollView,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  Image,
  Alert,
  ActivityIndicator
} from 'react-native';
import { Camera } from 'expo-camera';
import * as ImagePicker from 'expo-image-picker';
import * as DocumentPicker from 'expo-document-picker';
import Icon from '@expo/vector-icons/MaterialCommunityIcons';
import SignatureScreen from 'react-native-signature-canvas';
import { useRoute, useNavigation } from '@react-navigation/native';

const MaintenanceForm = () => {
  const route = useRoute();
  const navigation = useNavigation();
  const { equipment } = route.params;
  
  const [formData, setFormData] = useState({
    description: '',
    type: 'corrective',
    priority: 'medium',
    notes: ''
  });
  
  const [photos, setPhotos] = useState([]);
  const [files, setFiles] = useState([]);
  const [signature, setSignature] = useState(null);
  const [loading, setLoading] = useState(false);
  const [showCamera, setShowCamera] = useState(false);
  const [showSignature, setShowSignature] = useState(false);
  
  const cameraRef = useRef(null);

  const handleTakePhoto = async () => {
    if (cameraRef.current) {
      try {
        const photo = await cameraRef.current.takePictureAsync({
          quality: 0.7,
          base64: true
        });
        setPhotos([...photos, photo]);
        setShowCamera(false);
      } catch (error) {
        Alert.alert('Erro', 'Não foi possível capturar a foto');
      }
    }
  };

  const handlePickImage = async () => {
    try {
      const result = await ImagePicker.launchImageLibraryAsync({
        mediaTypes: ImagePicker.MediaTypeOptions.Images,
        quality: 0.7,
        base64: true
      });

      if (!result.canceled) {
        setPhotos([...photos, result]);
      }
    } catch (error) {
      Alert.alert('Erro', 'Não foi possível selecionar a imagem');
    }
  };

  const handlePickDocument = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ['application/pdf', 'image/*']
      });

      if (result.type === 'success') {
        setFiles([...files, result]);
      }
    } catch (error) {
      Alert.alert('Erro', 'Não foi possível selecionar o documento');
    }
  };

  const handleSave = async () => {
    if (!formData.description.trim()) {
      Alert.alert('Erro', 'A descrição é obrigatória');
      return;
    }

    setLoading(true);

    try {
      const form = new FormData();

      // Dados básicos
      Object.keys(formData).forEach(key => {
        form.append(key, formData[key]);
      });

      // Equipment ID
      form.append('equipment_id', equipment.id);

      // Fotos
      photos.forEach((photo, index) => {
        form.append('photos', {
          uri: photo.uri,
          type: 'image/jpeg',
          name: `photo_${index}.jpg`
        });
      });

      // Arquivos
      files.forEach((file, index) => {
        form.append('files', {
          uri: file.uri,
          type: file.mimeType,
          name: file.name
        });
      });

      // Assinatura
      if (signature) {
        form.append('signature', {
          uri: signature,
          type: 'image/png',
          name: 'signature.png'
        });
      }

      const response = await fetch(`${process.env.API_URL}/service-orders`, {
        method: 'POST',
        headers: {
          'Content-Type': 'multipart/form-data',
        },
        body: form
      });

      if (!response.ok) {
        throw new Error('Erro ao salvar ordem de serviço');
      }

      Alert.alert(
        'Sucesso', 
        'Ordem de serviço registrada com sucesso',
        [
          { text: 'OK', onPress: () => navigation.goBack() }
        ]
      );

    } catch (error) {
      Alert.alert('Erro', error.message);
    } finally {
      setLoading(false);
    }
  };

  if (showCamera) {
    return (
      <View style={styles.container}>
        <Camera style={styles.camera} ref={cameraRef}>
          <View style={styles.cameraButtons}>
            <TouchableOpacity 
              style={styles.closeButton}
              onPress={() => setShowCamera(false)}
            >
              <Icon name="close" size={30} color="#FFF" />
            </TouchableOpacity>
            <TouchableOpacity 
              style={styles.captureButton}
              onPress={handleTakePhoto}
            >
              <Icon name="camera" size={40} color="#FFF" />
            </TouchableOpacity>
          </View>
        </Camera>
      </View>
    );
  }

  if (showSignature) {
    return (
      <SignatureScreen
        onOK={(signature) => {
          setSignature(signature);
          setShowSignature(false);
        }}
        onEmpty={() => Alert.alert('Erro', 'Por favor, assine antes de confirmar')}
        onClear={() => setSignature(null)}
        descriptionText="Assinatura do Técnico"
        clearText="Limpar"
        confirmText="Salvar"
        webStyle={`.m-signature-pad--footer
          .button {
            background-color: #2196F3;
            color: #FFF;
            padding: 10px 20px;
            border-radius: 5px;
            margin: 0 10px;
          }`}
      />
    );
  }

  return (
    <ScrollView style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.equipmentName}>{equipment.name}</Text>
        <Text style={styles.equipmentCode}>Código: {equipment.code}</Text>
      </View>

      <View style={styles.form}>
        <Text style={styles.label}>Descrição do Problema *</Text>
        <TextInput
          style={styles.input}
          multiline
          numberOfLines={4}
          value={formData.description}
          onChangeText={(text) => setFormData({...formData, description: text})}
          placeholder="Descreva o problema ou serviço necessário"
        />

        <Text style={styles.label}>Tipo de Manutenção</Text>
        <View style={styles.typeContainer}>
          {['corrective', 'preventive', 'predictive'].map((type) => (
            <TouchableOpacity
              key={type}
              style={[
                styles.typeButton,
                formData.type === type && styles.typeButtonActive
              ]}
              onPress={() => setFormData({...formData, type})}
            >
              <Text style={[
                styles.typeButtonText,
                formData.type === type && styles.typeButtonTextActive
              ]}>
                {type === 'corrective' ? 'Corretiva' :
                 type === 'preventive' ? 'Preventiva' : 'Preditiva'}
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        <View style={styles.prioritySection}>
          <Text style={styles.label}>Prioridade</Text>
          <View style={styles.priorityContainer}>
            {[
              { value: 'low', label: 'Baixa' },
              { value: 'medium', label: 'Média' },
              { value: 'high', label: 'Alta' },
              { value: 'critical', label: 'Crítica' }
            ].map((priority) => (
              <TouchableOpacity
                key={priority.value}
                style={[
                  styles.priorityButton,
                  formData.priority === priority.value && styles.priorityButtonActive,
                  { backgroundColor: priority.value === 'critical' ? '#ffebee' : 
                                   priority.value === 'high' ? '#fff3e0' :
                                   priority.value === 'medium' ? '#e8f5e9' :
                                   '#f5f5f5' }
                ]}
                onPress={() => setFormData({...formData, priority: priority.value})}
              >
                <Text style={[
                  styles.priorityButtonText,
                  formData.priority === priority.value && styles.priorityButtonTextActive
                ]}>
                  {priority.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        <View style={styles.mediaSection}>
          <Text style={styles.label}>Fotos</Text>
          <View style={styles.photoGrid}>
            {photos.map((photo, index) => (
              <View key={index} style={styles.photoContainer}>
                <Image source={{ uri: photo.uri }} style={styles.photo} />
                <TouchableOpacity
                  style={styles.removePhoto}
                  onPress={() => {
                    const newPhotos = [...photos];
                    newPhotos.splice(index, 1);
                    setPhotos(newPhotos);
                  }}
                >
                  <Icon name="close-circle" size={24} color="#FF5252" />
                </TouchableOpacity>
              </View>
            ))}
            <TouchableOpacity
              style={styles.addPhotoButton}
              onPress={() => {
                Alert.alert(
                  'Adicionar Foto',
                  'Escolha uma opção',
                  [
                    {
                      text: 'Tirar Foto',
                      onPress: () => setShowCamera(true)
                    },
                    {
                      text: 'Escolher da Galeria',
                      onPress: handlePickImage
                    },
                    {
                      text: 'Cancelar',
                      style: 'cancel'
                    }
                  ]
                );
              }}
            >
              <Icon name="camera-plus" size={32} color="#666" />
            </TouchableOpacity>
          </View>

          <Text style={styles.label}>Arquivos Anexos</Text>
          <View style={styles.fileList}>
            {files.map((file, index) => (
              <View key={index} style={styles.fileItem}>
                <Icon name="file-document" size={24} color="#2196F3" />
                <Text style={styles.fileName} numberOfLines={1}>
                  {file.name}
                </Text>
                <TouchableOpacity
                  onPress={() => {
                    const newFiles = [...files];
                    newFiles.splice(index, 1);
                    setFiles(newFiles);
                  }}
                >
                  <Icon name="close" size={24} color="#FF5252" />
                </TouchableOpacity>
              </View>
            ))}
            <TouchableOpacity
              style={styles.addFileButton}
              onPress={handlePickDocument}
            >
              <Icon name="file-plus" size={24} color="#666" />
              <Text style={styles.addFileText}>Adicionar Arquivo</Text>
            </TouchableOpacity>
          </View>

          <Text style={styles.label}>Observações Adicionais</Text>
          <TextInput
            style={styles.input}
            multiline
            numberOfLines={3}
            value={formData.notes}
            onChangeText={(text) => setFormData({...formData, notes: text})}
            placeholder="Observações ou notas adicionais"
          />

          <View style={styles.signatureSection}>
            <Text style={styles.label}>Assinatura do Técnico</Text>
            {signature ? (
              <View style={styles.signaturePreview}>
                <Image
                  source={{ uri: signature }}
                  style={styles.signatureImage}
                  resizeMode="contain"
                />
                <TouchableOpacity
                  style={styles.clearSignature}
                  onPress={() => setSignature(null)}
                >
                  <Text style={styles.clearSignatureText}>Limpar</Text>
                </TouchableOpacity>
              </View>
            ) : (
              <TouchableOpacity
                style={styles.addSignatureButton}
                onPress={() => setShowSignature(true)}
              >
                <Icon name="pen" size={24} color="#666" />
                <Text style={styles.addSignatureText}>Adicionar Assinatura</Text>
              </TouchableOpacity>
            )}
          </View>
        </View>

        <TouchableOpacity
          style={[styles.submitButton, loading && styles.submitButtonDisabled]}
          onPress={handleSave}
          disabled={loading}
        >
          {loading ? (
            <ActivityIndicator color="#FFF" />
          ) : (
            <>
              <Icon name="check" size={24} color="#FFF" />
              <Text style={styles.submitButtonText}>Registrar Manutenção</Text>
            </>
          )}
        </TouchableOpacity>
      </View>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    backgroundColor: '#2196F3',
    padding: 20,
    paddingTop: 60,
  },
  equipmentName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFF',
  },
  equipmentCode: {
    fontSize: 16,
    color: '#FFF',
    opacity: 0.8,
  },
  form: {
    padding: 20,
  },
  label: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
    marginTop: 16,
    color: '#333',
  },
  input: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#ddd',
    textAlignVertical: 'top',
  },
  typeContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 16,
  },
  typeButton: {
    flex: 1,
    padding: 12,
    borderRadius: 8,
    backgroundColor: '#f5f5f5',
    marginHorizontal: 4,
    alignItems: 'center',
  },
  typeButtonActive: {
    backgroundColor: '#2196F3',
  },
  typeButtonText: {
    color: '#666',
    fontWeight: '500',
  },
  typeButtonTextActive: {
    color: '#FFF',
  },
  priorityContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 16,
  },
  priorityButton: {
    padding: 8,
    borderRadius: 8,
    margin: 4,
    minWidth: 80,
    alignItems: 'center',
  },
  priorityButtonActive: {
    borderWidth: 2,
    borderColor: '#2196F3',
  },
  priorityButtonText: {
    fontWeight: '500',
  },
  photoGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 16,
  },
  photoContainer: {
    width: 100,
    height: 100,
    margin: 4,
    borderRadius: 8,
    overflow: 'hidden',
  },
  photo: {
    width: '100%',
    height: '100%',
  },
  removePhoto: {
    position: 'absolute',
    top: 4,
    right: 4,
    backgroundColor: '#FFF',
    borderRadius: 12,
  },
  addPhotoButton: {
    width: 100,
    height: 100,
    margin: 4,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#ddd',
    borderStyle: 'dashed',
    justifyContent: 'center',
    alignItems: 'center',
  },
  fileList: {
    marginBottom: 16,
  },
  fileItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF',
    padding: 12,
    borderRadius: 8,
    marginBottom: 8,
  },
  fileName: {
    flex: 1,
    marginLeft: 12,
    fontSize: 14,
  },
  addFileButton: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#ddd',
    borderStyle: 'dashed',
  },
  addFileText: {
    marginLeft: 8,
    color: '#666',
    fontSize: 14,
  },
  signatureSection: {
    marginVertical: 16,
  },
  signaturePreview: {
    backgroundColor: '#FFF',
    borderRadius: 8,
    padding: 8,
    alignItems: 'center',
  },
  signatureImage: {
    width: '100%',
    height: 120,
  },
  clearSignature: {
    marginTop: 8,
  },
  clearSignatureText: {
    color: '#FF5252',
    fontSize: 14,
  },
  addSignatureButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    backgroundColor: '#FFF',
    borderRadius: 8,
    borderWidth: 2,
    borderColor: '#ddd',
    borderStyle: 'dashed',
  },
  addSignatureText: {
    marginLeft: 8,
    color: '#666',
    fontSize: 14,
  },
  submitButton: {
    backgroundColor: '#4CAF50',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 16,
    borderRadius: 8,
    marginTop: 24,
  },
  submitButtonDisabled: {
    opacity: 0.7,
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
    marginLeft: 8,
  },
});

export default MaintenanceForm;

================
File: mobile/MaintenanceHistory.jsx
================
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Modal,
  TextInput
} from 'react-native';
import Icon from '@expo/vector-icons/MaterialCommunityIcons';
import { format } from 'date-fns';
import { ptBR } from 'date-fns/locale';

const MaintenanceHistory = ({ route }) => {
  const { equipmentId } = route.params;
  const [loading, setLoading] = useState(true);
  const [maintenances, setMaintenances] = useState([]);
  const [equipment, setEquipment] = useState(null);
  const [filterModalVisible, setFilterModalVisible] = useState(false);
  const [filters, setFilters] = useState({
    startDate: null,
    endDate: null,
    type: null,
    search: ''
  });

  const fetchMaintenanceHistory = async () => {
    try {
      const queryParams = new URLSearchParams({
        ...filters,
        startDate: filters.startDate?.toISOString(),
        endDate: filters.endDate?.toISOString()
      }).toString();

      const response = await fetch(
        `${process.env.API_URL}/equipment/${equipmentId}/maintenance-history?${queryParams}`
      );
      const data = await response.json();
      setMaintenances(data.maintenances);
      setEquipment(data.equipment);
    } catch (error) {
      console.error('Erro ao carregar histórico:', error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMaintenanceHistory();
  }, [equipmentId, filters]);

  const renderMaintenanceItem = ({ item }) => (
    <TouchableOpacity 
      style={styles.maintenanceCard}
      onPress={() => navigation.navigate('MaintenanceDetail', { maintenance: item })}
    >
      <View style={styles.maintenanceHeader}>
        <View style={styles.typeContainer}>
          <Icon 
            name={
              item.type === 'preventive' ? 'shield-check' :
              item.type === 'corrective' ? 'wrench' : 'chart-line'
            }
            size={24}
            color={
              item.type === 'preventive' ? '#4CAF50' :
              item.type === 'corrective' ? '#FFA000' : '#2196F3'
            }
          />
          <Text style={styles.typeText}>
            {item.type === 'preventive' ? 'Preventiva' :
             item.type === 'corrective' ? 'Corretiva' : 'Preditiva'}
          </Text>
        </View>
        <Text style={styles.date}>
          {format(new Date(item.maintenance_date), "dd 'de' MMMM 'de' yyyy", { locale: ptBR })}
        </Text>
      </View>

      <Text style={styles.description}>{item.description}</Text>

      <View style={styles.detailsContainer}>
        <View style={styles.detailItem}>
          <Icon name="account" size={16} color="#666" />
          <Text style={styles.detailText}>{item.technician.name}</Text>
        </View>

        {item.cost && (
          <View style={styles.detailItem}>
            <Icon name="currency-brl" size={16} color="#666" />
            <Text style={styles.detailText}>
              R$ {item.cost.toFixed(2)}
            </Text>
          </View>
        )}

        {item.parts_replaced?.length > 0 && (
          <View style={styles.detailItem}>
            <Icon name="cog" size={16} color="#666" />
            <Text style={styles.detailText}>
              {item.parts_replaced.length} peças substituídas
            </Text>
          </View>
        )}
      </View>

      {item.photos?.length > 0 && (
        <View style={styles.mediaContainer}>
          <Icon name="image" size={16} color="#666" />
          <Text style={styles.mediaText}>{item.photos.length} fotos</Text>
        </View>
      )}
    </TouchableOpacity>
  );

  const FilterModal = () => (
    <Modal
      visible={filterModalVisible}
      transparent
      animationType="slide"
      onRequestClose={() => setFilterModalVisible(false)}
    >
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          <Text style={styles.modalTitle}>Filtros</Text>

          <Text style={styles.filterLabel}>Buscar</Text>
          <TextInput
            style={styles.filterInput}
            value={filters.search}
            onChangeText={(text) => setFilters({...filters, search: text})}
            placeholder="Buscar por descrição..."
          />

          <Text style={styles.filterLabel}>Tipo de Manutenção</Text>
          <View style={styles.typeButtons}>
            {['all', 'preventive', 'corrective', 'predictive'].map((type) => (
              <TouchableOpacity
                key={type}
                style={[
                  styles.typeButton,
                  filters.type === type && styles.typeButtonActive
                ]}
                onPress={() => setFilters({...filters, type})}
              >
                <Text style={[
                  styles.typeButtonText,
                  filters.type === type && styles.typeButtonTextActive
                ]}>
{type === 'all' ? 'Todos' :
                   type === 'preventive' ? 'Preventiva' :
                   type === 'corrective' ? 'Corretiva' : 'Preditiva'}
                </Text>
              </TouchableOpacity>
            ))}
          </View>

          <Text style={styles.filterLabel}>Período</Text>
          <View style={styles.dateContainer}>
            <TouchableOpacity
              style={styles.dateInput}
              onPress={() => showDatePicker('start')}
            >
              <Icon name="calendar" size={20} color="#666" />
              <Text style={styles.dateText}>
                {filters.startDate 
                  ? format(filters.startDate, 'dd/MM/yyyy')
                  : 'Data inicial'}
              </Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.dateInput}
              onPress={() => showDatePicker('end')}
            >
              <Icon name="calendar" size={20} color="#666" />
              <Text style={styles.dateText}>
                {filters.endDate 
                  ? format(filters.endDate, 'dd/MM/yyyy')
                  : 'Data final'}
              </Text>
            </TouchableOpacity>
          </View>

          <View style={styles.modalButtons}>
            <TouchableOpacity
              style={styles.clearButton}
              onPress={() => {
                setFilters({
                  startDate: null,
                  endDate: null,
                  type: null,
                  search: ''
                });
                setFilterModalVisible(false);
              }}
            >
              <Text style={styles.clearButtonText}>Limpar Filtros</Text>
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.applyButton}
              onPress={() => setFilterModalVisible(false)}
            >
              <Text style={styles.applyButtonText}>Aplicar</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  return (
    <View style={styles.container}>
      {/* Header */}
      <View style={styles.header}>
        <View>
          <Text style={styles.equipmentName}>{equipment?.name}</Text>
          <Text style={styles.equipmentCode}>Código: {equipment?.code}</Text>
        </View>
        <TouchableOpacity
          style={styles.filterButton}
          onPress={() => setFilterModalVisible(true)}
        >
          <Icon name="filter-variant" size={24} color="#FFF" />
        </TouchableOpacity>
      </View>

      {/* Lista de Manutenções */}
      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#2196F3" />
        </View>
      ) : (
        <FlatList
          data={maintenances}
          renderItem={renderMaintenanceItem}
          keyExtractor={(item) => item.id.toString()}
          contentContainerStyle={styles.listContainer}
          ListEmptyComponent={() => (
            <View style={styles.emptyContainer}>
              <Icon name="clipboard-text" size={48} color="#666" />
              <Text style={styles.emptyText}>Nenhuma manutenção encontrada</Text>
            </View>
          )}
        />
      )}

      <FilterModal />

      {/* Botão Flutuante para Nova Manutenção */}
      <TouchableOpacity
        style={styles.fab}
        onPress={() => navigation.navigate('MaintenanceForm', { equipmentId })}
      >
        <Icon name="plus" size={24} color="#FFF" />
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  header: {
    backgroundColor: '#2196F3',
    padding: 20,
    paddingTop: 60,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  equipmentName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#FFF',
  },
  equipmentCode: {
    fontSize: 16,
    color: '#FFF',
    opacity: 0.8,
  },
  filterButton: {
    padding: 8,
  },
  listContainer: {
    padding: 16,
  },
  maintenanceCard: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  maintenanceHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  typeContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  typeText: {
    marginLeft: 8,
    fontSize: 16,
    fontWeight: '500',
  },
  date: {
    color: '#666',
    fontSize: 14,
  },
  description: {
    fontSize: 16,
    color: '#333',
    marginBottom: 12,
  },
  detailsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 8,
  },
  detailItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginRight: 16,
    marginBottom: 4,
  },
  detailText: {
    marginLeft: 4,
    color: '#666',
    fontSize: 14,
  },
  mediaContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: 8,
  },
  mediaText: {
    marginLeft: 4,
    color: '#666',
    fontSize: 14,
  },
  fab: {
    position: 'absolute',
    bottom: 24,
    right: 24,
    backgroundColor: '#4CAF50',
    width: 56,
    height: 56,
    borderRadius: 28,
    justifyContent: 'center',
    alignItems: 'center',
    elevation: 4,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 4,
  },
  modalContainer: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#FFF',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
    maxHeight: '80%',
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 20,
  },
  filterLabel: {
    fontSize: 16,
    fontWeight: '500',
    marginBottom: 8,
    color: '#333',
  },
  filterInput: {
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    padding: 12,
    marginBottom: 16,
  },
  typeButtons: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginBottom: 16,
  },
  typeButton: {
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 20,
    backgroundColor: '#f5f5f5',
    marginRight: 8,
    marginBottom: 8,
  },
  typeButtonActive: {
    backgroundColor: '#2196F3',
  },
  typeButtonText: {
    color: '#666',
  },
  typeButtonTextActive: {
    color: '#FFF',
  },
  dateContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  dateInput: {
    flex: 0.48,
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
    borderRadius: 8,
    padding: 12,
  },
  dateText: {
    marginLeft: 8,
    color: '#666',
  },
  modalButtons: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginTop: 20,
  },
  clearButton: {
    padding: 12,
  },
  clearButtonText: {
    color: '#666',
  },
  applyButton: {
    backgroundColor: '#2196F3',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
  },
  applyButtonText: {
    color: '#FFF',
    fontWeight: '500',
  },
  emptyContainer: {
    alignItems: 'center',
    marginTop: 40,
  },
  emptyText: {
    marginTop: 8,
    color: '#666',
    fontSize: 16,
  },
});

export default MaintenanceHistory;

================
File: .gitattributes
================
# Auto detect text files and perform LF normalization
* text=auto

================
File: .gitignore
================
.DS_Store
/backend/node_modules
/frontend/node_modules

================
File: API_DOCS.txt
================
# Documentação da API - Sistema de Gerenciamento de Equipamentos

## Índice
1. [Introdução](#introdução)
2. [Autenticação](#autenticação)
3. [Endpoints](#endpoints)
   - [Usuários](#usuários)
   - [Equipamentos](#equipamentos)
   - [Ordens de Serviço](#ordens-de-serviço)
   - [Arquivos](#arquivos)

## Introdução

Esta API fornece endpoints para gerenciar equipamentos, manutenções e ordens de serviço. A API utiliza JWT para autenticação e retorna os dados em formato JSON.

### Base URL
```
http://localhost:3000/api
```

## Autenticação

A API utiliza Bearer Token para autenticação. Para endpoints protegidos, inclua o token no header:

```
Authorization: Bearer <seu-token>
```

### Login
```http
POST /login

{
  "email": "usuario@exemplo.com",
  "password": "senha123"
}

// Resposta
{
  "token": "jwt-token",
  "user": {
    "id": 1,
    "name": "Usuario",
    "email": "usuario@exemplo.com",
    "role": "admin"
  }
}
```

## Endpoints

### Usuários

#### Criar Usuário
```http
POST /users

{
  "name": "Nome do Usuário",
  "email": "usuario@exemplo.com",
  "password": "senha123",
  "role": "technician"
}
```

#### Listar Usuários
```http
GET /users

// Resposta
[
  {
    "id": 1,
    "name": "Nome do Usuário",
    "email": "usuario@exemplo.com",
    "role": "technician"
  }
]
```

### Equipamentos

#### Criar Equipamento
```http
POST /equipment

{
  "name": "Máquina X",
  "code": "EQ001",
  "serial_number": "SN123456",
  "department": "Produção",
  "description": "Descrição do equipamento",
  "maintenance_frequency": 30
}
```

#### Listar Equipamentos
```http
GET /equipment

// Parâmetros de Query
?department=Produção    // Filtrar por departamento
?status=active         // Filtrar por status
?search=Máquina       // Buscar por nome/código

// Resposta
[
  {
    "id": 1,
    "name": "Máquina X",
    "code": "EQ001",
    "department": "Produção",
    "status": "active",
    "last_maintenance": "2023-01-01T00:00:00.000Z"
  }
]
```

#### Detalhes do Equipamento
```http
GET /equipment/:id

// Resposta
{
  "id": 1,
  "name": "Máquina X",
  "code": "EQ001",
  "serial_number": "SN123456",
  "department": "Produção",
  "description": "Descrição do equipamento",
  "status": "active",
  "maintenance_history": [
    {
      "id": 1,
      "maintenance_date": "2023-01-01T00:00:00.000Z",
      "type": "preventive",
      "description": "Manutenção preventiva realizada"
    }
  ]
}
```

### Ordens de Serviço

#### Criar Ordem de Serviço
```http
POST /service-orders

{
  "equipment_id": 1,
  "description": "Manutenção preventiva",
  "type": "preventive",
  "priority": "medium",
  "scheduled_for": "2023-12-01T10:00:00.000Z"
}
```

#### Listar Ordens de Serviço
```http
GET /service-orders

// Parâmetros de Query
?status=pending       // Filtrar por status
?equipment_id=1      // Filtrar por equipamento
?date_start=2023-12-01&date_end=2023-12-31  // Filtrar por período

// Resposta
[
  {
    "id": 1,
    "equipment": {
      "id": 1,
      "name": "Máquina X"
    },
    "description": "Manutenção preventiva",
    "type": "preventive",
    "status": "pending",
    "scheduled_for": "2023-12-01T10:00:00.000Z"
  }
]
```

#### Atualizar Ordem de Serviço
```http
PUT /service-orders/:id

{
  "status": "completed",
  "description": "Manutenção realizada com sucesso"
}
```

### Arquivos

#### Upload de Arquivo
```http
POST /files
Content-Type: multipart/form-data

file: [arquivo]

// Resposta
{
  "id": 1,
  "name": "documento.pdf",
  "url": "/uploads/documento.pdf"
}
```

## Códigos de Status

- 200: Sucesso
- 201: Criado com sucesso
- 400: Erro de validação
- 401: Não autorizado
- 404: Não encontrado
- 500: Erro interno do servidor

## Exemplos de Uso com cURL

### Login
```bash
curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{"email":"usuario@exemplo.com","password":"senha123"}'
```

### Criar Equipamento
```bash
curl -X POST http://localhost:3000/api/equipment \
  -H "Authorization: Bearer <seu-token>" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Máquina X",
    "code": "EQ001",
    "department": "Produção"
  }'
```

### Upload de Arquivo
```bash
curl -X POST http://localhost:3000/api/files \
  -H "Authorization: Bearer <seu-token>" \
  -F "file=@/caminho/do/arquivo.pdf"
```

================
File: dev.sh
================
#!/bin/bash

# Verificar se o Docker está rodando
if ! docker info > /dev/null 2>&1; then
    echo "🚫 Docker não está rodando. Por favor, inicie o Docker primeiro."
    exit 1
fi

# Iniciar serviços do Docker
echo "🐋 Iniciando serviços Docker..."
docker-compose up -d

# Verificar status dos containers
echo "🔍 Verificando status dos serviços..."
sleep 5

if [ "$(docker inspect -f {{.State.Health.Status}} equipment-postgres)" != "healthy" ]; then
    echo "⚠️  PostgreSQL não está saudável. Verificando logs:"
    docker logs equipment-postgres
    exit 1
fi

if [ "$(docker inspect -f {{.State.Health.Status}} equipment-redis)" != "healthy" ]; then
    echo "⚠️  Redis não está saudável. Verificando logs:"
    docker logs equipment-redis
    exit 1
fi

# Iniciar backend
echo "🚀 Iniciando backend..."
cd backend
npm run dev &
BACKEND_PID=$!

# Aguardar backend inicializar
echo "⏳ Aguardando backend inicializar..."
sleep 5

# Iniciar frontend
echo "🚀 Iniciando frontend..."
cd ../frontend
npm run dev &
FRONTEND_PID=$!

# Função para limpeza ao encerrar
cleanup() {
    echo "🛑 Encerrando serviços..."
    kill $BACKEND_PID
    kill $FRONTEND_PID
    docker-compose down
    exit 0
}

# Registrar função de limpeza
trap cleanup SIGINT SIGTERM

# Manter script rodando
echo "✅ Sistema iniciado!"
echo "
Frontend: http://localhost:5173
Backend: http://localhost:3000
PostgreSQL: localhost:5432
Redis: localhost:6379

Pressione Ctrl+C para encerrar todos os serviços.
"

wait

================
File: docker-compose.yml
================
version: '3.8'

services:
  postgres:
    image: postgres:14-alpine
    container_name: equipment-postgres
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: equipment_management
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:alpine
    container_name: equipment-redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  postgres_data:
  redis_data:

================
File: nsetup.sh
================
#!/bin/bash

echo "🚀 Iniciando setup do sistema de gerenciamento de equipamentos..."

# Configurar frontend
echo "📦 Configurando frontend..."
cd frontend
npm install

# Instalar componentes do shadcn/ui
npx shadcn@latest init --yes
npx shadcn@latest add alert
npx shadcn@latest add button
npx shadcn@latest add card
npx shadcn@latest add form
npx shadcn@latest add input
npx shadcn@latest add select
npx shadcn@latest add table
npx shadcn@latest add badge
npx shadcn@latest add dialog
npx shadcn@latest add avatar
npx shadcn@latest add calendar
npx shadcn@latest add dropdown-menu
npx shadcn@latest add toast

# Criar arquivo .env
echo "VITE_API_URL=http://localhost:3000/api
VITE_WS_URL=ws://localhost:3000" > .env

# Configurar backend
echo "📦 Configurando backend..."
cd ../backend
npm install

# Criar arquivo .env
echo "NODE_ENV=development
PORT=3000
API_URL=http://localhost:3000/api
FRONTEND_URL=http://localhost:5173
CORS_ORIGIN=http://localhost:5173

# Banco de Dados
DB_HOST=localhost
DB_PORT=5432
DB_NAME=equipment_management
DB_USER=postgres
DB_PASS=postgres

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379

# JWT
JWT_SECRET=your-jwt-secret-key
JWT_EXPIRES_IN=7d" > .env

# Configurar banco de dados com Docker
echo "🐋 Configurando Docker..."
docker-compose up -d

# Aguardar banco de dados inicializar
echo "⏳ Aguardando banco de dados inicializar..."
sleep 10

# Executar migrações
echo "🔄 Executando migrações do banco de dados..."
npx sequelize-cli db:migrate

# Criar usuário admin inicial
echo "👤 Criando usuário admin inicial..."
npx sequelize-cli db:seed:all

echo "✅ Setup concluído!"
echo "
Para iniciar o sistema:

1. Inicie o backend:
   cd backend && npm run dev

2. Em outro terminal, inicie o frontend:
   cd frontend && npm run dev

Acesse: http://localhost:5173
Login: admin@example.com
Senha: admin123"

================
File: setup.sh
================
#!/bin/bash

# Configurações
GITHUB_TOKEN=""
INSTALL_DIR="/home/deploy/oss"
DB_NAME="os_app"
DB_USER="os_user"
DB_PASS="99pqcPmkKhQqu5Dw"

echo "Iniciando setup do sistema..."

# Resetar senha do postgres
echo "Alterando senha do usuário postgres..."
sudo -u postgres psql -c "ALTER USER postgres WITH PASSWORD 'postgres';"

# Criar banco de dados
echo "Criando banco de dados..."
sudo -u postgres psql << EOF
CREATE DATABASE $DB_NAME;
\c $DB_NAME
CREATE USER $DB_USER WITH PASSWORD '$DB_PASS';
GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO $DB_USER;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO $DB_USER;
EOF

# Criar diretório e clonar repositório
echo "Clonando repositório..."
sudo -u deploy mkdir -p $INSTALL_DIR
cd /home/deploy
sudo -u deploy git clone https://${GITHUB_TOKEN}@github.com/AutoAtende/os-app.git oss
cd $INSTALL_DIR

# Configurar Redis no Docker
echo "Configurando Redis..."
sudo docker run --name redis-oss \
  -p 6379:6379 \
  --restart unless-stopped \
  -d redis:alpine

# Configurar arquivo .env do Backend
echo "Configurando .env do Backend..."
sudo -u deploy cat > $INSTALL_DIR/backend/.env << EOL
PORT=3000
NODE_ENV=production
API_URL=https://oss-api.autoatende.com
FRONTEND_URL=https://oss.autoatende.com
CORS_ORIGIN=https://oss.autoatende.com

DB_HOST=localhost
DB_PORT=5432
DB_NAME=$DB_NAME
DB_USER=$DB_USER
DB_PASS=$DB_PASS

REDIS_HOST=localhost
REDIS_PORT=6379

JWT_SECRET=$(openssl rand -hex 32)
JWT_EXPIRES_IN=7d
EOL

# Configurar arquivo .env do Frontend
echo "Configurando .env do Frontend..."
sudo -u deploy cat > $INSTALL_DIR/frontend/.env << EOL
VITE_API_URL=https://oss-api.autoatende.com
VITE_WS_URL=wss://oss-api.autoatende.com
EOL

# Build do Frontend
echo "Instalando dependências e buildando Frontend..."
cd $INSTALL_DIR/frontend
sudo -u deploy npm install
sudo -u deploy npm run build

# Build e setup do Backend
echo "Instalando dependências e buildando Backend..."
cd $INSTALL_DIR/backend
sudo -u deploy npm install
sudo -u deploy npm run build

# Rodar migrations
echo "Executando migrations..."
cd $INSTALL_DIR/backend
sudo -u deploy npx sequelize-cli db:migrate

# Configurar Nginx
echo "Configurando Nginx..."
sudo cat > /etc/nginx/sites-available/oss-frontend << EOL
server {
    listen 80;
    server_name oss.autoatende.com;
    root $INSTALL_DIR/frontend/dist;
    index index.html;

    location / {
        try_files \$uri \$uri/ /index.html;
    }
}
EOL

sudo cat > /etc/nginx/sites-available/oss-backend << EOL
server {
    listen 80;
    server_name oss-api.autoatende.com;

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_cache_bypass \$http_upgrade;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
    }
}
EOL

# Ativar sites no Nginx
sudo ln -s /etc/nginx/sites-available/oss-frontend /etc/nginx/sites-enabled/
sudo ln -s /etc/nginx/sites-available/oss-backend /etc/nginx/sites-enabled/
sudo rm -f /etc/nginx/sites-enabled/default

# Configurar SSL
echo "Configurando SSL com Certbot..."
sudo certbot --nginx -d oss.autoatende.com -d oss-api.autoatende.com --non-interactive --agree-tos --email seu-email@dominio.com

# Configurar PM2
echo "Configurando PM2..."
cd $INSTALL_DIR/backend
sudo -u deploy npm install -g pm2
sudo -u deploy pm2 start dist/app.js --name "oss-backend"
sudo -u deploy pm2 save
sudo env PATH=$PATH:/usr/bin /usr/lib/node_modules/pm2/bin/pm2 startup systemd -u deploy --hp /home/deploy

# Recarregar Nginx
sudo nginx -t && sudo systemctl reload nginx

# Ajustar permissões
sudo chown -R deploy:deploy $INSTALL_DIR
sudo chmod -R 755 $INSTALL_DIR

echo "Setup concluído!"
echo "Frontend: https://oss.autoatende.com"
echo "Backend: https://oss-api.autoatende.com"
echo "Banco de dados '$DB_NAME' criado com usuário '$DB_USER'"
echo "Senha do postgres alterada para: postgres"
echo "Redis rodando na porta 6379"
